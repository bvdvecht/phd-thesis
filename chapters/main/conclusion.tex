\chapter{Conclusion}
\label{chp:conclusion}

In this final chapter, we provide a brief summary of the work presented in this thesis and list possible future lines of research and development.

\section{Summary of results}
In \cref{chp:intro} we have explained that for quantum networks, there was previously no programming and execution framework for quantum network (or internet) applications.
Our main goal has hence been to \emph{enable programming and execution of arbitrary quantum network applications in a hardware-agnostic way while optimizing runtime performance}.
In \cref{chp:netqasm,chp:qnodeos,chp:qoala,chp:compiler} we presented novel (system) architectures towards achieving this goal.


\paragraph{NetQASM}
In \cref{chp:netqasm} we introduced NetQASM --- the first ever instruction set that can express quantum network instructions including remote entanglement generation.
NetQASM enables the development of quantum network applications in a hardware\-/agnostic manner by providing a high-level SDK, and by making the instruction set hardware\-/independent (although we also allow hardware-specific optimizations).
We also introduced a model of execution for quantum network nodes, which consists of a CNPU performing classical processing and communication with other nodes, and a QNPU responsible for executing quantum instructions as well as delivering entanglement to user applications.
By using virtualized quantum memory spaces, NetQASM allows multitasking on a node: the concurrent execution of multiple applications, in order to increase device utilization.
We validated and evaluated NetQASM in simulation.


\paragraph{QNodeOS}

In \cref{chp:qnodeos} we extended our execution model from \cref{chp:netqasm}, and presented the first ever full-stack system architecture for quantum network nodes --- QNodeOS --- for executing arbitrary applications on quantum network nodes.
QNodeOS is an architecture that spans both CNPU and QNPU, and describes how user applications written with the NetQASM SDK can be executed, by also incorporating the network stack~\cite{dahlberg2019linklayer,kozlowski_2020_qnp}.
We have validated our architecture by implementing it on real hardware: we showed the successful execution of simple quantum network applications on a setup of two nodes based on NV centers.
Moreover we have shown that QNodeOS is platform-agnostic by also connecting it to a quantum device with trapped ions.
Finally we validated that QNodeOS can do multitasking of multiple applications and can increase quantum device utility this way.

\paragraph{Qoala}
We learned from QNodeOS that there are opportunities to improve compilation and scheduling, which will then lead to better runtime performance.
In \cref{chp:qoala} we explained these opportunities and proposed an improved architecture --- Qoala --- for executing applications on quantum network nodes.
In the Qoala architecture, the split between CNPU and QNPU (in \cref{chp:qoala} called CPS and QPS) is lessened: Qoala describes a hybrid classical-quantum format of programs, allowing more advanced compilation, and a node-wide scheduler that allows more advanced scheduling.
We evaluated how Qoala enables improvement of both compilation and scheduling in simulation.

\paragraph{Compiler}
While the Qoala architecture enables better compilation in the first place, in \cref{chp:compiler} we discussed how such a compiler could look like.
We discussed design considerations and proposed a high-level architecture for such a compiler.
Our overall recommendation is to re-use existing compilation techniques wherever possible, such as for purely classical code segments and purely local quantum code segments.
We also recommend using existing infrastructure such as MLIR in order to (1) re-use existing techniques and (2) represent the hybrid nature of quantum network programs.
Moreover, we have provided pointers for (quantum) network-specific optimizations, including instruction re-ordering and inserting deadlines to code blocks.




\section{Future work}
We believe that our work has contributed to addressing the objective of enabling programming and execution of arbitrary quantum network nodes, by designing and implementing the frameworks mentioned above.
Still, there remain areas for improvement and more research.

\paragraph{Implement Qoala on real hardware}
Although we have validated Qoala's improvements over QNodeOS in simulation, it is important to validate this on a real implementation as well.
A real implementation of Qoala, by upgrading the existing QNodeOS implementation would enable running the same experiments on real hardware with Qoala as we did with QNodeOS in \cref{chp:qnodeos}.
% Such an implementation would require, however, a new classical control hardware as opposed to QNodeOS, e.g. by placing CPS and QPS on a single board with access to an on-chip shared memory. 


\paragraph{Scaling up}
All the work presented here has been evaluated on small networks, whether it be on real hardware (\cref{chp:qnodeos}) or in simulation (\cref{chp:netqasm,chp:qoala}).
Evaluating QNodeOS and Qoala on larger systems (meaning: larger networks, more applications, more qubits per node, more instructions per program) can give insights into how much our architecture scales, and whether changes in the design have to be made before larger scale adoption can be realized.

\paragraph{Qoala compiler}
In \cref{chp:compiler} we discussed possibilities for the design of a compiler for Qoala programs.
Finalizing the design and then implementing it would enable evaluation (in simulation or on hardware), which would in turn point to future improvements of the design.
It would be especially interesting to see how compilation strategies may be combined with scheduling strategies, because of their interplay as shown in \cref{chp:qoala}.
% Furthermore, one could investigate compilation to 
% Qoala uses the HostLang language to represent classical operations, in classical blocks.
% We mentioned in \cref{chp:qoala} that compilation down to native classical code such as x86 would be possible.

\paragraph{Advanced scheduling algorithms}
In \cref{chp:qoala} we evaluated only simple node scheduling algorithms (first-come-first-serve and earliest-deadline-first) since our main objective was to showcase the ability to do node scheduling in the first place, rather than coming up with an optimized scheduler.
More sophisticated scheduling strategies may lead to higher success probabilities and lower makespan when concurrently executing multiple program instances, where inspiration may come from existing strategies such as time-utility functions (TUF, see e.g.~\cite{jensen1993timeliness, li2004utility}) to inform scheduling decisions, and where it is an open question how such TUFs could even be defined in the quantum domain.
Further research on the fundamental tradeoffs between the classical (makespan) and quantum (success probability) performance metrics may also guide further design choices on scheduling algorithms.

\paragraph{Investigate using Qoala for distributed quantum computing}
Although Qoala has been designed with quantum network (or internet) applications in mind, it may also be used for distributed quantum computing (DQC, although not to be confused with Delegated Quantum Computation from \cref{chp:qnodeos}).
Since DQC only needs to do limited classical communication (sending teleportation corrections), Qoala's architecture of having a separate CPS doing arbitrary classical computation and communication may not be the most efficient solution.
However, it may be that overhead is minimal and is made up for by being able to use the same architecture (namely Qoala) as for more general quantum network applications.
Indeed, using Qoala may enable DQC in larger-scale networks comprised of autonomous nodes (like a quantum internet), something not immediately possible with existing frameworks such as~\cite{diadamo_distributed_2021} which assume central control over all nodes.
Because of the more predictable nature of DQC applications (there is typically no complex control-flow depending on runtime information) simple node scheduling algorithms may suffice, although this needs to be investigated.


\paragraph{Capability negotiation}
In \cref{qoala:sec:program_instantiation} we mentioned that the compiler provides advice that the nodes use in capability negotiation and demand registration (\cref{qoala:sec:program_instantiation}).
It is an open question how to best compute such advice, and find efficient protocols for negotiating capabilities and register demand.
This must be fleshed out in coordination with network scheduling research.

\paragraph{Network schedule}
As expected, our evaluation shows that application performance depends on the network schedule, where we emphasize that ensuring network service is out of scope for Qoala as en environment for executing applications.
This highlights a need for understanding the quality of service a quantum network should provide, as well as to design good network scheduling algorithms to satisfy them, in order to achieve good application performance.



\begin{xstretch}
\printbibliography[heading=subbibintoc,title={References},notcategory=noprint]
\end{xstretch}
