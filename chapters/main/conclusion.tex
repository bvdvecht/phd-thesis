\chapter{Conclusion}
\label{chp:conclusion}

In this final chapter, we provide a brief summary of the work presented in this thesis and list possible future lines of research and development.

\section{Summary of results}
In \cref{chp:intro} we have explained that for quantum networks, there is no programming and execution framework for quantum network (or internet) applications.
Our main goal has hence been to \emph{enable programming and execution of arbitrary quantum network applications in a hardware-agnostic way while optimizing runtime performance}.
In \cref{chp:netqasm,chp:qnodeos,chp:qoala} we presented concrete (system) architectures towards achieving this goal, and in \cref{chp:compiler} we have discussed recommendations for another architecture.


\paragraph{NetQASM}
In \cref{chp:netqasm} we introduced the low-level instruction set \ac{NetQASM} which can express quantum network instructions including remote entanglement generation.
\ac{NetQASM} enables the development of quantum internet applications in a platform-independent manner, by providing a high-level SDK as well as hardware-specific flavors.
We also introduced an initial model of execution for quantum network nodes \ac{NetQASM}, which consists of a \ac{CNPU} performing classical processing and communication with other nodes, and a \ac{QNPU} responsible for executing quantum instructions as well as delivering entanglement to user applications.


\paragraph{QNodeOS}

In \cref{chp:qnodeos} we built on top of our execution model from \cref{chp:netqasm}, and presented a detailed full-stack system architecture --- QNodeOS --- for executing arbitrary applications on quantum network nodes.
We implement this architecture on a setup with two real physical quantum network nodes, and show that our architecture can successfully execute quantum network applications.
We have shown that \ac{QNodeOS} is platform-agnostic by also connecting it to a quantum device with trapped ions.
We evaluated the performance of our architecture by looking at application throughput and success probability, and validated that it can do multitasking.

\paragraph{Qoala}
We learned from \ac{QNodeOS} that there are opportunities to improve compilation and scheduling.
In \cref{chp:qoala} we explain these opportunities and propose an improved architecture --- Qoala --- for executing applications on quantum network nodes.
Qoala that addresses the compilation and scheduling challenges found in QNodeOS, by allowing hybrid classical-quantum compilation and scheduling.
We show how this architecture enables strategies to achieve better application performance.

\paragraph{Compiler}
We have discussed design considerations for a Qoala program compiler, and proposed a high-level architecture for such a compiler.
Our overall recommendation is to re-use existing compilation techniques wherever possible, such as for purely classical code segments and purely local quantum code segments.
We also recommend using existing infrastructure such as MLIR in order to (1) re-use existing techniques and (2) represent the hybrid nature of quantum network programs.
Moreover, we have provided pointers for (quantum) network-specific optimizations, including instruction re-ordering and inserting deadlines to code blocks.




\section{Future work}
We believe that our work has contributed to addressing the objective of enabling programming and execution of arbitrary quantum network nodes, by designing and implementing the frameworks mentioned above.
Still, there remain areas for improvement and more research.

\paragraph{Validate Qoala on real hardware}
First, it would be interesting to see how much improvement Qoala has over \ac{QNodeOS} by performing the same experiments with Qoala as we did with QNodeOS in \cref{chp:qnodeos}.
Furthermore, the evaluation of Qoala that has been done in simulation should be repeated on hardware.
Such an implementation would require, however, a new classical control hardware as opposed to QNodeOS, e.g. by placing CPS and QPS on a single board with access to an on-chip shared memory. 


\paragraph{Scaling up}
All the work presented here has been evaluated on small networks, either real ones (\cref{chp:qnodeos}) or in simulation (\cref{chp:netqasm,chp:qoala}).
The experiments on real hardware have been tested only on NV centers, on a network with only two nodes, with one qubit per node.
It would be good to test Qoala on more nodes, and with more applications running with multitasking.

\paragraph{Compiler design}
In \cref{chp:compiler} we discussed recommendations for the design of a compiler.
More research is needed for the ideas presented in this chapter before a detailed compiler design can be completed.
For example, how should developers describe their fidelity constraints in high-level source code?
How can a compiler translate such constraints into deadlines?
Finally, evaluation of the compiler design is crucial to test the merit of these ideas and to guide further research.
However, as discussed in \cref{chp:compiler}, application performance depends not only on compilation, but also on scheduling, which leads to the next point.

\paragraph{Native classical code execution}
Qoala uses the HostLang language to represent classical operations, in classical blocks.
We mentioned in \cref{chp:qoala} that compilation down to native classical code such as x86 would be possible.
It is worth investigating this and also consider using WebAssembly outside of the browser.

\paragraph{Advanced scheduling algorithms}
More sophisticated scheduling strategies may lead to higher success probabilities and lower makespan when concurrently executing multiple program instances, where inspiration may come from existing strategies as explained in \cref{chp:qoala}.
In the quantum domain, missing the deadline will result in a degradation of the success probability as a function of the time by which the deadline was exceeded.
This suggest the use of time-utility functions (TUF, see e.g.~\cite{jensen1993timeliness, li2004utility}) to inform scheduling decisions, where it is an open question how such TUF could even be defined in the quantum domain.
Our work also raises the question on what fundamental tradeoffs between the classical (makespan) and quantum (success probability) performance metrics are at all possible.


\paragraph{Capability negotiation}
We assumed that the compiler provides advice that the nodes use in a capability negotiation and demand registration (Section~\ref{qoala:sec:program_instantiation}).
It is an open question how to best compute such advise, and find efficient protocols for negotiating capabilities and register demand.

\paragraph{Network schedule}
As expected, our evaluation shows that application performance depends on the network schedule, where we emphasize that ensuring network service is out of scope for Qoala as en environment for executing applications.
This highlights a need for understanding the quality of service a quantum network should provide, as well as to design good network scheduling algorithms to satisfy them, in order to achieve good application performance.




\begin{xstretch}
\printbibliography[heading=subbibintoc,title={References},notcategory=noprint]
\end{xstretch}
