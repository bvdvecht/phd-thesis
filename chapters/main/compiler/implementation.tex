\section{Implementation}

We report on a preliminary implementation of our compiler, using the LLVM framework (C++), specifically making use of the MLIR subproject of LLVM~\cite{lattner_mlir_2020}.
This implementation focuses mainly on translating high-level code to a Qoala executable, using \acf{IR}s as proposed in the previous section.
We have not yet implemented any optimizations, but we emphasize that our implementation can easily incorporate optimizations by writing these as \emph{passes} (a construct in LLVM~\cite{lattner_llvm_2004}) that are applied on the IRs.

\subsection{Overview}
The Qoala compiler uses three intermediate representations (IRs):
a high-level IR (QoalaHIR), a mid-level IR (QoalaMIR), and a low-level IR (QoalaLIR).
Each IR is associated with a particular set of MLIR \emph{dialects}~\cite{lattner_mlir_2020}.
The Qoala compiler uses four custom MLIR dialects, called \texttt{qnet}, \texttt{qmem}, \texttt{qoalahost}, and \texttt{netqasm}, explained in more detail below.

\begin{itemize}
    \item QoalaHIR (High-level): A higher-level IR, where operations are closely related
    to the python source.
    Quantum operations are represented using the \texttt{qnet} dialect, which consume and produce quantum \emph{values}.
    Programs in the QoalaHIR format use the following dialects: \texttt{qnet} (Qoala-specific dialect), and \texttt{arith}, \texttt{scf}, \texttt{affine}, \texttt{async}, \texttt{tensor} (default dialects in MLIR, which support complex control-flow and data structures).
    \item QoalaMIR (Mid-level): A mid level IR, similar to QoalaHIR but with explicit memory locations, using the Qoala-specific \texttt{qmem} dialect instead of \texttt{qnet} (\texttt{qmem} uses quantum pointers instead of quantum values).
    \item QoalaLIR (Low-level): A lower level IR, where operations are closer to the classical and quantum assembly instructions.
    Quantum operations are represented using the \texttt{netqasm} dialect, which take quantum quantum memory pointers as operands and have side-effects on the quantum value stored in the registers.
    Programs in the QoalaLIR format use the following dialects: \texttt{qoalahost} (Qoala-specific), \texttt{netqasm} (Qoala-specific), and \texttt{arith}, \texttt{cf}, \texttt{memref}, \texttt{async} (standard MLIR dialects).
    We note that only simple control-flow and data structures are supported (\texttt{cf} and \texttt{memref}), since they map more directly onto the allowed control-flow and data structures in Qoala executables.
\end{itemize}

\subsection{Lowering passes}
We have implemented the following compiler passes for lowering QoalaHIR code into QoalaLIR code (\cref{compiler:fig:overall-design}).

\paragraph{QoalaHIR to QoalaMIR}
Go from a value-semantics representation (qubits are values that are consumed and produces by operations) in the \texttt{qnet} dialect to memory-semantics representation (qubits are pointers and quantum operations acting on qubit pointers have side effects) in the \texttt{qmem} dialect.

\paragraph{QoalaMIR functionizing}
Split QoalaMIR code into functions.
This `functionizing' is done in such a way that the program structure already resembles the final Qoala executable structure.

Functionizing algorithm:
\begin{enumerate}
\item Loop over all operations in the order they are given until either a classical receive operation or an entanglement operation is found. (When the end of the program is reached, exit.)
\item Create one or more new functions:
    \begin{itemize}
        \item If a classical receive operation was encountered: gather all quantum operations found so far, plus all (possibly non-quantum) operations that produce values used by these quantum operations.
        Put all these operations inside a new function and replace the original QoalaMIR code with a call to this new function.
        \item If an entanglement operation was encountered: gather all \emph{non-entanglement} operations found so far, and put them in a new function (F1) (like in the previous point).
        Additionally, create a second new function (F2) containing the entanglement operation itself, including the corresponding allocation operation. Replace the original QoalaMIR code with calls to F1 and F2.
    \end{itemize}
\item Go back to (1) starting at the operation after the previously found receive or entanglement operation. Note that classical receive operations always remain \emph{outside} newly created functions, whereas entanglement operations are always moved \emph{into} their own new functions.
\end{enumerate}

\paragraph{QoalaMIR to QoalaLIR}
Convert operations inside functions to the \texttt{netqasm} dialect.
Convert other operations to the \texttt{qoalahost} dialect.
The format is now already close to a Qoala executable (\texttt{.iqoala}).

\subsection{Python SDK}
We have implemented a new, bare-bones, SDK for the purpose of trying our compiler; in the future we aim to merge this with the NetQASM SDK (\cref{chp:netqasm}) such that programs written in this existing SDK can immediately be compiled using our compiler.
The SDK enables the following program development flow:

\begin{itemize}
\item Programmer writes source code in Python using the Qoala Python SDK.
\item The Python SDK itself provides a \texttt{compile} function that executes the source code
  which produces a \texttt{.mlir} file containing the program code in QoalaHIR format.
\item This Python SDK implements \textit{some} functionality present in the "frontend" of a classical
  compiler, for example, a semantical analysis to check the validity of the classical and
  quantum operations specified in the program 
\item A separate \texttt{opt}-like tool (built using LLVM/MLIR) takes the \texttt{.mlir} as input and produces
  (after several applying passes) a \texttt{.iqoala} file.
\item The \texttt{.iqoala} file can then be executed by a Qoala runtime.
\end{itemize}


\subsection{Example lowering}

Take the below example program written in the high-level Qoala Python SDK.
The program creates first creates an entangled qubit (\texttt{q}) with remote node Bob, after which a Hadamard gate is applied on \texttt{q}.
Then, the program waits to a receive classical real number (a float) as a classical message from Bob, calling it \texttt{t1}.
An x-rotation gate is applied on \texttt{q} with angle \texttt{t1}.
Finally, \texttt{q} is measured, producing bit \texttt{m} which is returned as result of this program.

\begin{pycode}
class MyProgram(QoalaProgram):
    def main(self, ctx: QoalaContext):
        q = ctx.entangle_keep("Bob")
        ctx.hadamard(q)
        t1 = ctx.recv_float("Bob")
        ctx.rot_x(q, t1)
        m = ctx.measure(q)
        ctx.add_return(m)

program = MyProgram()
mlir = program.compile()  # `compile` is defined in `QoalaProgram`
with open("program.mlir", "w") as f:
    f.write(mlir.text())
\end{pycode}

The \texttt{program.compile()} method produces an in-memory representation of this program but in QoalaHIR format.
Finally, it is written to the file \texttt{program.mlir}, which can then be fed to \texttt{qoala-opt}, the main Qoala compiler.
The QoalaHIR format looks as follows:

\begin{pycode}
qnet.func @main() -> i1 {
    %q = qnet.eprs {N = 1, remote = @Bob} : !qnet.qubit
    %q2 = qnet.hadamard %q : !qnet.qubit
    %floats1 = qnet.recv_floats {remote = @Bob, length = 1 : i32} : tensor<1xf32>
    %t1 = tensor.extract %floats1[%zero] : tensor<1xf32>
    %q3 = qnet.rot_x %q2, %t1 : !qnet.qubit
    %m = qnet.measure %q3 : i1
    qnet.return %m : i1
}
\end{pycode}

As can be seen, the variable \texttt{q} from the original Python program is now called \texttt{\%q} (using \texttt{\%} is MLIR syntax), and is the result of the \texttt{eprs} operations defined in the \texttt{qnet} dialect.
This operation produces a variable of type \texttt{!qnet.qubit}, a native \texttt{qnet} type.

The hadamard operation in the \texttt{qnet} dialect \emph{consumes} \texttt{!qnet.qubit} values (in this case, \texttt{\%q}) and \emph{produces a new} \texttt{!qnet.qubit} value (in this case, \texttt{\%q2}).
Using value-semantics (consuming and producing values) allows for already-existing MLIR optimization passes (such as dead code elimination, but not shown in this example) to be applied on our custom \texttt{qnet} dialect as well.

\paragraph{Lowering QoalaHIR to QoalaMIR}

When lowering the above QoalaHIR code to QoalaMIR, the change is that instead of using value-semantics for qubits, now explicit allocations are done for quantum memory.
Quantum operations are applied on quantum pointers, and have side effects.
(In contrast to consuming a quantum \emph{value} and producing a new one.)
As can be seen below, the \texttt{qnet.eprs} operation producing qubit variable \texttt{\%q} is replaced by a \texttt{qalloc} operation (in the \texttt{qmem} dialect), producing a qubit \emph{pointer} \texttt{\%qptr} (not a quantum value), followed by a \texttt{eprs} operation (in the \texttt{qmem} dialect instead of the \texttt{qnet} dialect) which acts on \texttt{\%qptr}.

\begin{pycode}
qmem.func @main() -> i1 {
    %qptr = qmem.qalloc : i32
    qmem.eprs %qptr
    qmem.hadamard %qptr
    %floats1 = qmem.recv_floats {remote = @Bob, length = 1 : i32} : tensor<1xf32>
    %t1 = tensor.extract %floats1[%zero] : tensor<1xf32>
    qmem.rot_x %qptr, %t1
    %m = qmem.measure %qptr : i1
    qmem.return %m : i1
}
\end{pycode}

\paragraph{Functionizing QoalaMIR}
On QoalaMIR code, a \emph{functionizing} pass is applied, which splits quantum code into separate functions that are called from the main function.
The main function itself only keeps classical instructions.
Here we see the first split that eventually becomes the split between CPS code (in the main function) and QPS code (in the separate functions).
The result of applying the \texttt{functionize} pass on the above QoalaMIR code looks like this:

\begin{pycode}
qmem.func @routine1() -> i32 {
    %qptr = qmem.qalloc : i32
    qmem.eprs %qptr
    qmem.return %qptr : i32
}

qmem.func @routine2(%qptr: i32) -> i32 {
    qmem.hadamard %qptr
    qmem.return %qptr : i32
}

qmem.func @routine3(%qptr: i32, %t1: f32) -> i1 {
    qmem.rot_x %qptr, %t1
    %m = qmem.measure %qptr : i1
}

qmem.func @main() -> i1 {
    %qptr = qmem.call @routine1() : () -> i32
    qmem.call @routine2(%qptr) : () -> i32
    %floats1 = qmem.recv_floats {remote = @Bob, length = 1 : i32} : tensor<1xf32>
    %t1 = tensor.extract %floats1[%zero] : tensor<1xf32>
    %m = call @routine3(%qptr1, %t1) : (i32, f32) -> i1
    qmem.return %m : i1
}
\end{pycode}

\paragraph{Lowering functionized QoalaMIR to QoalaLIR}
When lowering to QoalaLIR, the quantum functions are replaced by either \texttt{request\_routine} operations (for functions containing EPR creation operations) or \texttt{local\_routine} operations (for function with only local quantum operations).
Moreover, these functions are now all in the \texttt{netqasm} dialect.
The code in the main function is replaced by appropriate operations in the \texttt{qoalahost} dialect.
As can be seen below, the structure of the resulting QoalaLIR code already looks close to the final Qoala executable (\texttt{.iqoala}) format: \texttt{netqasm.request\_routine} functions can be mapped to Qoala Request Routines, \texttt{netqasm.local\_routine} functions can be mapped to Qoala Local Routines, and the \texttt{main\_func} code can be mapped to Qoala Host code (\cref{qoala:sec:program_structure}).

\begin{pycode}
netqasm.request_routine @req1() -> i32 {
    %vqubit = netqasm.qalloc : i32
    netqasm.eprs %vqubit {remote = @Bob}
    return %vqubit : i32
}

netqasm.local_routine @subrt2(%vqubit: i32) {
    netqasm.hadamard %vqubit
    return
}

netqasm.local_routine @subrt3(%vqubit: i32, %num: i32, %denom: i32) {
    netqasm.rot_x %vqubit, %num, %denom
    %m = netqasm.measure %vqubit : i1
    return %m : i1
}

qoalahost.main_func @main() -> i1{
    %zero = arith.constant 0 : index
    %vqubit = qoalahost.call @req1() : () -> i32
    netqasm.call @subrt2(%vqubit, %num1, %denom1) : (i32, i32, i32) -> ()

    %floats1 = qoalahost.recv_floats {remote = @Bob, length = 1 : i32} : tensor<1xf32>
    %t1 = tensor.extract %floats1[%zero] : tensor<1xf32>
    %num1, %denom1 = func.call @conver_float_to_num_and_denom(%t1) : (f32) -> (i32, i32)

    %m = netqasm.call @subrt3(%vqubit, %num1, %denom1) : (i32, i32, i32) -> i1
    qoalahost.return %m : i1
}
\end{pycode}


