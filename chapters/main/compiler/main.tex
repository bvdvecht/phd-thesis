\section{Introduction}

\todo{make sure here already main goals are defined: translation and optimziation}

\todo{make sure here already relation with scheduler is introduced}

In the previous chapters we presented building blocks towards the goal of enabling programming and execution of quantum network applications.
In \cref{chp:netqasm} the low-level instruction set NetQASM was introduced for representing quantum operations.
We also defined a software development kit (SDK) that allows one to write programs in Python and which compiles quantum code into NetQASM subroutines.
In \cref{chp:qnodeos} we introduced an operating system, QNodeOS, that executes these programs.
In \cref{chp:qoala} we improved on the design of the operating system and presented the Qoala program format.
This format consists of classical instructions in the HostLang language and quantum instructions in NetQASM, grouped into blocks.
Qoala programs are not meant to be written by developers directly.
Just as for NetQASM programs, the intention is for developers to code in a higher-level representation; a compiler then translates this into a Qoala program.

Although programmers could express their program logic directly in the Qoala format, this is not practical for several reasons.
First, since the format is low-level, it is quite verbose.
This is a similar issue as with classical assembly (or other lower-level languages): although possible, it is often very impractical to write complete programs in assembly itself.
Second, the low-level format can be quite far from the high-level program logic.
Someone who wants to implement a certain quantum network program typically only cares about the overall (high-level) behavior of the program.
For example, they might simply want to express that the program should create entangled states repeatedly, and then measure all created qubits.
Having to deal with low-level details about how express looping behavior, which (quantum) memory and how much to allocate, and how to integrate the classical and quantum code
is in most cases not something a programmer wants to deal with. 
Third, the Qoala program format allows hardware-specific details, such as hardware-specific quantum instructions (using NetQASM flavors, see \cref{chp:netqasm}).
Although not required to add these details by the programmer, if one wants to make use of these details to improve execution (e.g. increasing success probability), the programmer should have knowledge about the hardware.
Ideally, the programmer should not have to write different versions of a program, one for each hardware platform that the program is intended to run upon.
Classically this is also the case: programmers do not write assembly directly.

In \cref{chp:netqasm, chp:qnodeos} we described how NetQASM and QNodeOS already provides a way for programmers to express program logic in a high-level language, Python.
However, in \ac{QNodeOS}, compilation would happen on-the-fly (also called \emph{interpretation}):
while executing a program (i.e. at \emph{runtime}), program code is evaluated and quantum instructions are translated into NetQASM subroutines.
This lead to certain problems, also discussed in the evaluation of Qoala (\cref{qoala:sec:evaluation}):
\begin{itemize}
  \item Compilation slows down execution:
    Since compilation needs to happen at runtime, overall execution time increases.
    This can be especially bad if quantum states must stay alive during this compilation time.
    This can be seen clearly in \cref{fig:fig3}.
  \item No cross-compilation possible:
    Since code is interpreted on the fly, optimizations taking into account future code cannot be made. \todo{example figure of optimization that cannot be done in NetQASM/QNodeOS}
\end{itemize}

Qoala, with its new model of programs (\cref{qoala:sec:architecture}), enables addressing of the above problems.
Furthermore, Qoala enables optimization specific to runtime performance, as we will discuss below (e.g. deadlines for better success probability).
Before we discuss how a compiler for Qoala should look like, we first review what compilers are and related work.


\section{Compilers}
Compilation is the translation from a high-level source code representation of a program into a lower-level representation of that program, typically machine code, that a computer's processor can execute.
Compilation is itself done by a computer program, namely the compiler.
The type of machine code that a compiler produces depends on the \emph{target} of the compiler.
The target is typically a combination of processor architecture (such as x86 or ARM for classical computers) and operating system (such as Linux or Windows for classical computers).

Program compilation is a well-studied topic in both classical~\cite{aho_compilers_2006} and quantum computing~\cite{chong_programming_2017} and is a vital tool in everyday practical software development.
Many existing ideas and strategies can be re-used for compiling quantum network applications.
However, quantum network applications present unique challenges that need to be solved by a compiler.

Generally, a compiler has three purposes:

\begin{itemize}

\item \textbf{Translation}.
Allowing a programmer to write application logic in a high-level language improves the accessibility:
it relieves the programmer of the burden of thinking about low-level details, and makes it easier to express complex logic.
However, in the end, hardware must execute low-level code and a translation step is required.
Such translation must maintain the intended behavior of the program (correctness).

\item \textbf{Error detection}.
A compiler checks whether the program source code is valid and throws an error if it is not.

\item \textbf{Optimization}.
A compiler tries to perform optimization with respect to various metrics.
It may try to minimize the size of the final executable.
It may also try to produce an executable such that the expected runtime performance is optimized.
Increasing expected runtime performance can be done in many ways, which are discussed in more detail below.

\end{itemize}



\section{Related work}
\label{compiler:sec:related-work}

\subsection{Compilers for classical computing.}
Compilers for classical computers have been developed and used since the creation of the first digital computers and are therefore a well-studied topic~\cite{aho_compilers_2006}.
A common architecture for compilers is to use one or more \ac{IR}s.
In this model, the high-level program source code is first translated by a \emph{front-end} compiler to the (highest-level) \ac{IR}, then possibly translated to lower-level \ac{IR}s, before it is translated from the (lowest-level) \ac{IR} by a \emph{back-end} compiler to machine code.
Separating the front-end from the back-end enables extensibility of the compiler: for each high-level language for which one wants to implement a compiler, only a front-end must be developed, since further compilation can happen using existing back-ends.
Similarly, for each machine target, only one back-end needs to be created.
In this way, many different programming languages and machine targets may use the same infrastructure, by `going through' the same \ac{IR}(s).
A well-known compiler that uses this model is LLVM~\cite{lattner_llvm_2004} which uses the \emph{LLVM IR}.

Compilers for classical computers perform code optimizations.
Code optimization techniques include
\begin{itemize}
  \item \emph{Target-independent optimization}, such as including removal of dead (unused) code, optimizations of looping constructs and combining common expressions to reduce code, and
  \item \emph{Target-dependent optimization}, such as register allocation, instruction re-ordering, branch prediction and elimination, vectorization and cache optimization.
\end{itemize}
These optimizations typically aim to improve execution speed and memory efficiency~\cite{aho_compilers_2006}.

\subsection{Compilers for classical networking.}
Classical applications that use networking are also compiled by classical compilers.
Typically, compilers do not apply network-specific optimizations.
This is since network operations are often handled by system calls, which compilers do not have control over.
Moreover, compilers also don't have control over the execution and timing of other applications in the network, nor over the network itself.
Network-specific optimization is therefore indirect, namely by optimizing the number of network system calls, reducing memory that would need to be context-switched upon network events, and optimizing local code that affects networking code~\cite{danalis_mpi-aware_2009}.
We note that there exist compilers for network programming languages~\cite{monsanto_compiler_2012, li_modular_2020}.
However, these relate to programming the control plane of networks (a paradigm called software-defined networking (SDN)), including how data is routed through the network.
This hence does not relate to programming applications for networks.

% Typically, the performance of networked applications depend on the protocol that the application implements and the network that it runs on.
% For example, for an application that exchanges information across nodes in a network, its performance depends on the protocol that is used (e.g. TCP vs UDP) and the network (including routing protocols, traffic, etc.) \todo{elaborate and refs}.

% The performance of networked applications is heavily influenced by both the protocol the application employs and the characteristics of the underlying network.
% For instance, in an application that exchanges data across various nodes, its efficiency and responsiveness are directly impacted by whether it uses a connection-oriented protocol like TCP, which ensures reliability through acknowledgment and retransmission mechanisms, or a connectionless protocol like UDP, which prioritizes speed but sacrifices reliability.
% Moreover, the state of the network, including factors such as routing protocols (e.g., OSPF, BGP), network congestion, latency, and packet loss, also plays a crucial role. A congested network or suboptimal routing can lead to delays, packet drops, or throughput bottlenecks, all of which degrade application performance .
% Thus, the interplay between the chosen protocol and network conditions must be carefully considered when designing or optimizing networked applications.

\subsection{Compilers for quantum computing.}
\label{compiler:sec:compilers-qc}
As already described in \cref{chp:intro}, quantum computing programs are typically expressed as quantum circuits.
Circuits consist of qubits, which are memory locations on which operations are applied.
Limit classical control may be added.

There exist many languages for quantum computing~\cite{chong_programming_2017, heim_quantum_2020}.
Many frameworks make use of assembly-like languages like OpenQASM~\cite{cross_open_2017} or cQASM~\cite{khammassi_cqasm_2018}.
Also more high-level languages exist such as Q\# and Scaffold~\cite{svore_q_2018, litteken_updated_2020, heim_quantum_2020}.

\paragraph{Circuit optimizers}
Compilers for quantum computing programs often try to optimize circuit depth (number of gates) and width (number of qubits).
Most compilers focus on \ac{NISQ} computers, dealing with resource constraints (like limited qubit availability, and restricted topology)\cite{chong_programming_2017, murali_full-stack_2019, bandic_full-stack_2022} and qubit mapping\cite{li_tackling_2019, zhang_context-sensitive_2020, bandic_mapping_2023, nishio_extracting_2020}.
Benchmarks exist with which to compare compilers, by looking at the output, like circuit size.

\paragraph{Hybrid classical-quantum compilers}
In the last years, more focus has been brought on hybrid classical-quantum compilers.
This can be seen in the proposal of full-stack architectures, including classical and quantum processing\cite{murali_full-stack_2019, khammassi_openql_2021, mccaskey_xacc_2020}, and the focus on hybrid quantum computing programs, like VQE and QAOA. 

One can distinguish two approaches:
\begin{itemize}
\item integration of classical and quantum code but optimization is separate or limited: \cite{litteken_updated_2020, fux_quingo_2021, khalate_llvm-based_2022, younis_quantum_2022}
\item joint classical-quantum optimization (MLIR-based, LLVM based): \cite{mccaskey_mlir_2021, ittah_enabling_2022, nguyen_retargetable_2022, peduri_qssa_2022}
\end{itemize}

In order to deal with the hybrid code of hybrid programs, often intermediate represenations (IRs) are used \cite{nigam_compiler_2021, nishio_inquir_2023}.
The existing LLVM framework has been re-used and integrated in quantum compilers \cite{murali_noise-adaptive_2019, murali_full-stack_2019, litteken_updated_2020}.
A quantum-specific IR has been created: QIR \cite{haner_software_2018, geller_introducing_2020}.

% Qunity: formal hybrid language, but only compiles to circuit (openqasm).


% \cite{smith_error_2021} Mitigates decoherence by clever instruction ordering.
% Idea of going beyond layered model and ISA (e.g. directly pulse optimization): \cite{shi_resource-efficient_2020}.


% \begin{itemize}
% \item Catalyst (Xanadu Pennylane)
% \item QSSA compiles down to OpenQASM, which itself does not map to physical (virtual) qubits. In OpenQASM, you declare qubit registers, but the mapping to physical qubits only happens at runtime.
% \item Quantum Dialect (McCaskey/Nguyen) compiles to QIR, which also only contains the opaque `allocate`.
% \item QIRO does not explain how to lower it to native quantum instructions
% \end{itemize}

\subsection{Compilers for quantum networking.}
For quantum networking, compilation has not much been studied.
The closest comes distributed quantum computing, for which compilers do exist~\cite{ferrari_compiler_2021, chatterjee_qurzon_2022, cuomo_optimized_2023, ferrari_modular_2023}.
For distribution quantum computing there are compilers: \cite{ferrari_compiler_2021, haner_distributed_2021, cuomo_optimized_2023, ferrari_modular_2023}.
One approach is to take the input circuit and first split it into separate circuits: circuit cutting~\cite{chatterjee_qurzon_2022}

Intermediate representations have also been proposed for network-related quantum programs:
an extension to QIR for network-related programs, NetQIR, has been proposed~\cite{vazquez-perez_netqir_2024}, and InQuIR~\cite{nishio_inquir_2023} for distributed quantum computing.


\paragraph{Session types}

Session types is a formalism used for defining communication protocols between different parties \cite{honda_language_1998}.
They can be used to for example specify the order in which messages need to be sent and received.
By having the protocol in a well-defined format, the parties can check whether they adhere to the agreed upon protocol.
Tools exist that can check at compile-time if a program adheres to a communication protocol~\cite{davidson_model_nodate, ardeshir-larijani_automated_2018}.
Session types may be used for two parties, but multi-party session types also exist \cite{honda_multiparty_2016}.
Multiparty session types have been considered for quantum network programs: \cite{lanese_towards_2024}.
Timed session types are an extension to session types, adding explicit time constraints to operations~\cite{bartoletti_timed_2017}.
Timed session types have not yet been applied to quantum.


\subsection{Challenges unique to quantum network compilation}
\label{compiler:sec:challenges-unique}
Unique challenges are presented by the nature of quantum network programs.

\textit{Hybrid classical-quantum code.} Also seen in quantum computing, but now quantum memory also needs to stay alive much longer. More interactivity.
\todo{make sure is below: addressed by hybrid IR}

\textit{Non-deterministic durations.} Network operations, including entanglement generation take non-deterministic time, and may fail.
Possible optimization: re-order opreations such that quantum memory does not need to wait (as long) during a non-deterministic operation (like waiting for a message or entanglement success).
\todo{make sure is below: addressed by re-using existing optimizations and special focus on networking (classical and quantum) operations}

\textit{Failure possibility.} Entanglement generation may be seen as a "local" operation acting on a local qubit, but may fail. Retry mechanisms may be needed.
(Also remark on certain hardware like NV, where there is cross-qubit noise, e.g. entanglement generation affects memory qubits.)
\todo{make sure is below: addressed by session types?}

\textit{Private program in networked context.} Performance co-depends on other nodes but no control over them. Coordination is required between programs and nodes.
In the Qoala execution framework, *capability negotiation* is required; this leads to the need of some external protocol description.
\todo{Schematic figure of application compilation vs program compilation}
\todo{make sure is below: addressed by session types?}

\textit{Runtime performance depends on scheduling}. Compiler can only assist scheduler in making runtime decisions.
\todo{make sure is below: addressed by adding deadlines}



\section{Design considerations}

We briefly recap our overarching objectives for programming and executing quantum network applications, as also discussed in \cref{chp:intro}:
\begin{itemize}
\item Improve accessibility by enabling programming using high-level concepts and tools
\item Execute quantum internet programs efficiently in terms of application success probability and success rate
\item Provide a framework for coordinating programs in a multi-node application
\end{itemize}

Part of the above objectives are handled by the Qoala runtime: scheduling enables better application success probability, and capability negotiation coordinates with the network scheduler.
The remaining objectives are addressed by a compiler.

\paragraph{General considerations}
We want to re-use existing infrastructure and not re-invent the wheel. This means we can make use of or take inspiration from compilers for classical computing and quantum computing (\cref{compiler:sec:related-work}).
However, we also want to specifically address the unique challenges of quantum network programs (see \todo{compiler:sec:challenges-unique}) and also use features from Qoala to do so.


\subsection{Translation from high-level to Qoala}
\paragraph{High-level format}
The compiler must translate a high-level format into Qoala.
We already had a high-level format with the NetQASM SDK.
We can re-use these ideas.
In general the programmers should be able to just focus on the program logic, and not have to deal with low-level implementation and optimization details.
We can also take the opportunity to add more features to the languages, that can be used by the compiler.
Specifically, we can add constructs to the high-level language for supplying fidelity and timing constraints.
Fidelity constraints needed to get success probability (especially since other programs may run in parallel; it's a way to define implicit priority).
Timing constraints in high-level program code may be needed because protocol demands it.

\paragraph{Conversion to Qoala}
We also want to allow multiple (existing) high-level formats.
As explained in \todo{ref to compiler section}, classical compilers typically use a hierarchy of steps: a front-end for any high-level language to a intermediate representation (IR), and a back-end for IR to machine code.
Using an IR decouples the main compiler design from specific input and output foramts, making it more flexible and scalable.
Furthermore, if an IR would be used that is already part of existing compilation frameworks, it can re-use existing compiler techniques.
The Quantum Intermediate Representation (QIR)~\cite{haner_software_2018, geller_introducing_2020} may be used.
However, QIR uses opaque pointers for quantum types, which prevents certain optimizations~\cite{ittah_enabling_2022, peduri_qssa_2022}.
Multi-Level Intermediate Representation (MLIR) avoids these issues, since it allows for creating domain-specific \emph{dialects}.
Dialects have been created for quantum such that quantum types can be represented natively, allowing optimizations to be applied on operations including quantum ones~\cite{ittah_enabling_2022, peduri_qssa_2022}.
\cite{mccaskey_mlir_2021, nguyen_retargetable_2022} also use MLIR before then compiling to QIR.

\paragraph{Role of Exposed Hardware Info (EHI)}
Target must be explicitly defined, using EHI \todo{elaborate}.


\subsection{Optimization}
We want to optimize programs with respect to various metrics.
Some of these metrics are those from standard compilers: memory usage and execution time (or makespan).
This holds for both classical and quantum code.
For classical code, standard optimization can be used, e.g. from LLVM.
For quantum code, also existing techniques can be used, see \cref{compiler:sec:compilers-qc}.
These include circuit mapping and gate optimization techniques.

Moreover, by using the hybrid classical-quantum format we can re-use existing optimizations such as loop unrolling and other, see \cite{mccaskey_mlir_2021, ittah_enabling_2022, nguyen_retargetable_2022, peduri_qssa_2022}.
This also enables cross-subroutine optimizations, something not possible in NetQASM.

Other metrics we want to optimize for are
\begin{inlinelist}
\item amount of CPS-QPS communication
\item success probability. Note that we do not fully control this. Add hints to scheduler.
\end{inlinelist}

As with classical network or internet applications, the performance of quantum network applications also depends on the network itself, on which the compiler does not have influence.
A large factor in performance is the fidelity (quality) of entangled states produced by the network.
Although the compiler does not control this fidelity directly, it can indirectly help by doing clever capability negotiation (see also below) and adding deadlines.

Furthermore, we want to do noise-aware optimization.
Again, we can re-use existing things. See \cite{smith_error_2021, murali_noise-adaptive_2019}.

We \textit{add} the following kinds of optimizations.
\begin{itemize}
  \item re-order operations to minimize qubit memory time
    AFAIK not done in any other compiler (hybrid classical-quantum reordering yes, but not specifically to reduce qubit `live' time)
  \item add deadlines to code blocks to guide scheduling
\end{itemize}




\subsection{Multi-node coordination}
% \todo{Should this section be called `error detection' to mirror the 3 purposes mentioned in the Compilers section?}
Although typically a compiler only compiles for a local program, we want to discuss the context in which quantum network programs run and what the impact is.

Since applications consist of multiple cooperating programs, some kind of coordination is required.
The order of external operations in a program (message-passing and entanglement generation) must match with external operations in other programs.
An application protocol description is needed such that programmers know in which order they have to put their operations.
Such a description may also include a mechanism for re-trying a certain operations, needed when e.g. entanglement generation failed.

Another reason for having protocol description is demand registration to network controller (see \ref{todo ref to Qoala chapter}). To make an informed demand, a protocol description is needed such that nodes can synchronize their behavior and agree about timings, iterations, and retry mechanisms. Therefore, it makes sense to already have a protocol description at compile-time. This can also e.g. be something that is advertised as a service by some quantum server.

% \todo{double check role of cap negotiation wrt compilation}
% Must be after compilation such that same executable can be re-used in multiple contexts. Uses input from users (that are about to run the application) and uses hints from the compiler (put into the executables). Also uses input from network controller (like current estimates of rate, fidelity).

We can imagine a protocol description to at least contain the following elements:
\begin{itemize}
    \item Must contain: order of interactive steps
    \item May contain: timing constraints, constraints on fidelity of entanglement and of certain states
\end{itemize}

A protocol description can also help the compiler make more informed optimizations.
It could extend correctness checking (see above) by checking if the source adheres to the protocol description. 
Furthermore, the compiler may compute deadlines based on information in the protocol.
For example, if the protocol says that entanglement generation must happen within a certain amount of time, the compiler can insert deadlines such that the node scheduler can try to meet this protocol timing demand.


We distinguish two Modes of Compilation (MoC):
\begin{itemize}
    \item Protocol-informed compilation: a pre-defined protocol exists describing at least the order of interactive steps that the nodes must execute. A compiler may take advantage of such a protocol description.
    \item Standard compilation: there is no pre-defined description of a protocol, and a compiler cannot take advantage of such knowledge.
\end{itemize}



\todo{noise-aware optimization for circuits exists, not for interactive hybrid programs}


\section{Recommendations for further research and evaluation}
Based on the considerations discussed above, we propose the following ways in which to tackle the compilation design problem.


\textbf{Decouple front-end language from compilation framework by using Intermediate Representations (IRs)}
The front-end language is not a primary concern; we want to leave design and implementations open.
Use the existing technique of IRs, gradually lowering code and performing optimizations at each level.
Use \ac{MLIR} since it enables defining intermediate representations specifically for quantum networking, while still having access to standard (classical) LLVM optimizations.

One may consider at least two \ac{IR}s:
\begin{itemize}
  \item A high-level \ac{IR}, consisting of a uniform hybrid classical-quantum representation of operations, where quantum values are native types.
  This allows classical optimization techniques such as loop unrolling or dead code elimination.
  \item A low-level \ac{IR}, where classical code is explicitly separated from quantum code.
  The classical code segments will eventually compile down to classical Qoala blocks (classical local and classical networking blocks, \cref{qoala:sec:program_structure}), while quantum code segments will eventually compile down to quantum Qoala blocks (local routines and request routines, \cref{qoala:sec:program_structure}).
  The explicit separation (1) makes it easier to perform the back-end compilation step (going from low-level IR to Qoala executable) since the formats are already similar and (2) forces the compiler to decide on \emph{where} to make the separations, allowing it to optimize it (see below).
\end{itemize}

\textbf{Use value-based representations}
In this way, existing optimizations acting on SSA can be directly re-used.
In a later pass, map to specific qubits, such that noise-aware optimziation can be done (see next point).
Can also be used to track fidelity estimations.

\textbf{Re-use existing (classical and quantum) compilation techniques for local code}
These include classical techniques (like loop unrolling, see \cref{compiler:sec:related-work}) and quantum techniques (qubit mapping, gate optimization etc).
Existing quantum circuit optimizations can be applied to local quantum code in the quantum network program to compile.
For network-related operations, see below \todo{TODO}.

\textbf{Perform optimizations on joint classical-quantum representation}
Make use of the fact that classical and quantum code can be jointly analyzed and optimized.
Use existing techniques, see \cite{mccaskey_mlir_2021, ittah_enabling_2022, nguyen_retargetable_2022, peduri_qssa_2022}.
Use MLIRs existing infrastructure.

\textbf{Optimize using noise characteristics} use EHI (noise and topology)
Use Qoala's Exposed Hardware Info (EHI) to allow specific optimizations, including
\begin{itemize}
  \item Compiling to specific NetQASM flavor
  \item Mapping to specific qubits with better topology (also to make it valid in the first place \todo{add topology as part of target in translation})
  \item allow different optimization levels (aggressive, minimal, etc)
\end{itemize}

\textbf{Allow explicit targets to be defined}. Including flavor and topo

\textbf{Give hints to scheduler (deadlines)}
Use EHI to compute deadlines based on fidelity restrictions in source code.
\begin{itemize}
  \item Given expected durations for network operations, in combination with decoherence rates, compute deadlines for the scheduler to try and adhere to
\end{itemize}


\textbf{Use session types for protocol adherence checking}
Even without protocol description: do not re-order external operations.



% \subsection{Recommendation for overall design}

% Input:
% \begin{itemize}
%   \item Inputs: program code (may contain fidelity/timing constraints), EHI
%   \item (potentially protocol description)
% \end{itemize}

% Compilation:
% \begin{itemize}
%   \item General correctness checking
%   \item (potentially: adherence to protocol checking)
%   \item Translation to valid Qoala
%   \item Optimization:
%     \begin{itemize}
%       \item General (gate optimization etc.)
%       \item Insert hints to try and meet fidelity/timing constraints from program
%       \item (potentially: insert hints to try and meet fidelity/timing constraints from protocol)
%       \item Cannot re-order external operations
%     \end{itemize}
% \end{itemize}

% Capability negotiation:
% \begin{itemize}
%   \item Potentially refer to protocol description and claim compatibility
%   \item Establish demand, number of instances, inputs, deadlines
% \end{itemize}


% \subsection{Recommendations for evaluation}

% \todo{EVALUATION}


% \subsection{A note on Qoala program scope}
% It's only **live quantum memory** that's time-sensitive.
% The Qoala runtime provides a way to schedule and prioritize program parts such that quantum decoherence can be minimized.
% To take advantage of this, quantum code, possibly interspersed with classical code, should be executed as Qoala programs.
% However, it is not needed to write a whole program, including parts with purely classical code, in Qoala.