\section{Introduction}
As described in the introduction chapter\todo{make sure this is the case}, our overarching goal for this thesis is to enable programming of quantum networks.
The previous chapters have presented building blocks, or stepping stones towards this goal.
In \cref{chp:netqasm} the low-level instruction set NetQASM was introduced for representing quantum operations.
We also defined a software development kit (SDK) that allows one to write programs in Python and which compiles quantum code into NetQASM subroutines.
In \cref{chp:qnodeos} we introduced an operating system, QNodeOS, that executes these programs.
In \cref{chp:qoala} we improved on the design of the operating system and presented the Qoala program format.
This format consists of classical instructions in the HostLang language and quantum instructions in NetQASM, grouped into blocks.
As mentioned in \cref{chp:netqasm}\todo{check this}, NetQASM code was never really meant to be written by programmers directly.
For Qoala programs, the same holds: the classical HostLang langauge and the request routines are not human-friendly.

Although programmers could express their program logic directly in the Qoala format, this is not practical for several reasons.
First, since the format is low-level, it is quite verbose.
This is a similar issue as with classical assembly (or other lower-level languages): although possible, it is often very impractical to write complete programs in assembly itself.
Second, the low-level format can be quite far from the high-level program logic.
Someone who wants to implement a certain quantum network program typically only cares about the overall (high-level) behavior of the program.
For example, they might simply want to express that the program should create entangled states repeatedly, and then measure all created qubits.
Having to deal with low-level details about how express looping behavior, which (quantum) memory and how much to allocate, and how to integerate the classical and quantum code
is in most cases not something a programmer wants to deal with. 
\todo{Figure representing a human writing code and the low-level qoala format and highlighting the `distance' between them?}
Third, the Qoala program format allows hardware-specific details, such as hardware-specific quantum instructions (using NetQASM flavors, see \cref{chp:netqasm}).
Although not required to add these details by the programmer, if one wants to make use of these details to improve execution (e.g. increasing success probability), the programmer should have knowledge about the hardware.
Ideally, the programmer should not have to write different versions of a program, one for each hardware platform that the program is intended to run upon.
Classically this is also the case: programmers do not write assembly directly.

The Qoala program format was indeed not intended to be used by programmers directly.
\reminder{focus on programmers: can we say something about practical feedback, i.e. actual users of our tools?}
Instead, it was envisioned that a programmer would express program logic in a high-level language, such as Python, and that a compiler would transform this into a Qoala program.
Allowing expression in such a higher-level language takes away the aforementioned issues.


In NetQASM and QNodeOS, we already provided a way for programmers to express program logic in a high-level language, Python.
However, compilation would happen on-the-fly, akin to interpretation.
This lead to certain problems, also discussed in the evaluation of QNodeOS and Qoala:
\begin{itemize}
  \item Compilation slows down execution:
    Since compilation needs to happen at runtime, overall execution time increases.
    This can be especially bad if quantum states must stay alive during this compilation time.
    This can be seen clearly in \todo{ref to latency figure in qnodeos paper}
  \item No cross-compilation possible:
    Since code is interpreted on the fly, optimizations taking into account future code cannot be made. \todo{example figure of optimization that cannot be done in NetQASM/QNodeOS}
\end{itemize}

Qoala, with its new model of programs, enables addressing of the above problems.
Furthermore, Qoala enables optimization specific to runtime performance, as we will discuss below (e.g. deadlines for better success probability).


\section{Compilers}
Compilation is the translation from a high-level source code representation of a program into a lower-level representation of that program, typically machine code, that a computer's processor can execute.
Compilation is itself done by a computer program, namely the compiler.

Program compilation is a well-studied topic in both classical and quantum computing and is a vital tool in everyday practical software development.
Many existing ideas and strategies can be re-used for compiling quantum network applications.
However, quantum network applications present unique challenges that need to be solved by a compiler.

Traditionally, a compiler has three purposes:

\textbf{Translation}.
Allowing a programmer to write application logic in a high-level language improves the accessibility:
it relieves the programmer of the burden of thinking about low-level details, and makes it easier to express complex logic.
However, in the end, hardware must execute low-level code and a translation step is required.
Such translation must maintain the intended behavior of the program (correctness).

\textbf{Error detection}.
A compiler checks whether the program source code is valid and throws an error if it is not.

\textbf{Optimization}.
A compiler tries to perform optimization with respect to various metrics.
(1) It might try to minimize the size of the final executable.
(2) It might try to produce an executable such that the expected runtime performance is optimized.



Optimization metrics include offline ones such as instruction count and memory usage, and online ones such as success probability.
Many existing compilation strategies, of both classical and quantum computing, can be re-used.


\subsection{Existing (quantum) compilers}
\todo{schematic figure of compiler: input -> passes -> output}

\textbf{Compilers for classical computing.}
Compilers for classical computers have existed since the beginning of modern computers, in the middle of the 20th century.
A need for translating higher-level languages into the native language of computers - 0s and 1s - has always been needed.
Over time, more and more sophisticated programming languages have been made and used.
These generally became more and more abstract: they were more directly suited for expressing higher-level program logic, and further away from the 0s and 1s.
To this day, compilers are vital in the programming ecosystem.
Large compiler projects such as LLVM use intermediate representations.
There is a distinction between interpreted and compiled languages.\todo{figure showing difference between interpreted and compiled}

Classical compilers have a \textit{target} such as x86 or ARM.
Code optimization techniques include
\begin{itemize}
  \item Target-independent optimization: constant folding, dead code elimination, loop optimizations, common subexpression elimination, inlining, peephole optimization, copy propagation, interprocedural optimization.
  \item Target-dependent optimization: register allocation, instruction re-ordering, branch prediction and elimination, vectorization, cache optimization.
\end{itemize}
These optimizations typically aim to improve execution speed and memory efficiency.

\textbf{Compilers for classical networking.}
Classical applications that use networking are also compiled by classical compilers.
Typically, compilers do apply network-specific optimizations.
This is since network operations are often handled by system calls, which compilers do not have control over.
Moreover, compilers also don't have control over the execution and timing of other applications in the network.
Network-specific optimization is therefore indirect, namely by optimizing the number of network system calls, reducing memory that would need to be context-switched upon network events, and optimizing local code that affects networking code.

Typically, the efficiency of network-related operations depend on the protocol itself, like TCP or HTTP. 

\textbf{Compilers for quantum computing.}
Quantum computing programs are typically expressed as quantum circuits.
Circuits consist of qubits, which are memory locations on which operations are applied.
\todo{Make sure circuits are introduced in the intro chapter and refer to it here}
Limit classical control may be added.

There exist many languages for quantum computing.
Many frameworks make use of assembly-like languages like OpenQASM or cQASM.
Also more high-level languages exist such as Q\# or others\todo{elaborate}.

Optimizations try to optimize circuit depth and width.
Until recently, not much hybrid classical-quantum optimization has been done.
However, hybrid languages and tools are becoming more common.
See QIR, MLIR, and others.

Benchmarks exist with which to compare compilers, by looking at the output, like circuit size.

\textbf{Compilers for quantum networking.}
For quantum networking, compilation has not much been studied.
The closest comes distributed quantum computing, for which compilers do exist~\cite{ferrari_compiler_2021, chatterjee_qurzon_2022, cuomo_optimized_2023, ferrari_modular_2023}.




\subsection{Challenges unique to quantum network compilation}
Unique challenges are presented by the nature of quantum network programs.

\textit{Hybrid classical-quantum code.} Also seen in quantum computing, but now quantum memory also needs to stay alive much longer. More interactivity.

\textit{Non-deterministic durations.} Network operations, including entanglement generation take non-deterministic time, and may fail.
Possible optimization: re-order opreations such that quantum memory does not need to wait (as long) during a non-deterministic operation (like waiting for a message or entanglement success).

\textit{Failure possibility.} Entanglement generation may be seen as a "local" operation acting on a local qubit, but may fail. Retry mechanisms may be needed.
(Also remark on certain hardware like NV, where there is cross-qubit noise, e.g. entanglement generation affects memory qubits.)

\textit{Private program in networked context.} Performance co-depends on other nodes but no control over them. Coordination is required between programs and nodes.
In the Qoala execution framework, *capability negotiation* is required; this leads to the need of some external protocol description.
\todo{Schematic figure of application compilation vs program compilation}

\textit{Runtime performance depends on scheduling}. Compiler can only assist scheduler in making runtime decisions.




\section{Design considerations}

\textbf{Overarching objectives}
\begin{itemize}
\item Execute quantum internet programs efficiently in terms of application success probability and success rate
\item Improve accessibility by enabling programming using high-level concepts and tools
\item Provide a framework for coordinating programs in a multi-node application
\end{itemize}

\todo{Metrics to optimize}

Part of the above objectives are handled by the Qoala runtime: scheduling enables better application success probability, and capability negotiation coordinates with the network scheduler.
The remaining objectives are addressed by a compiler.

\textbf{General considerations}
We want to re-use existing infrastructure and not re-invent the wheel. This means we can make use of or take inspiration from:
\begin{itemize}
  \item classical compilers with traditional translation and optimization strategies
  \item quantum compilers with circuit mapping and gate optimization techniques
  \item \todo{refer to above section explaining existing comilers}
\end{itemize}

We also don't want to tie our work to one specific high-level language.

Further, we want to specifically address the unique challenges of quantum network programs (see \todo{ref to section above}) and also use features from Qoala to do so.


\subsection{Translation from high-level to Qoala}
\textit{High-level format}
The compiler must translate a high-level format into Qoala.
We already had a high-level format with the NetQASM SDK.
We can re-use these ideas.
In general the programmers should be able to just focus on the program logic, and not have to deal with low-level implementation and optimization details.
We can also take the opportunity to add more features to the languages, that can be used by the compiler.
Specifically, we can add constructs to the high-level language for supplying fidelity and timing constraints.
Fidelity constraints needed to get success probability (especially since other programs may run in parallel; it's a way to define implicit priority).
Timing constraints in high-level program code may be needed because protocol demands it

\textit{Conversion to Qoala}
We also want to allow multiple (existing) high-level formats.
As explained in \todo{ref to compiler section}, classical compilers typically use a hierarchy of steps: a front-end for any high-level langauge to a intermediate representation (IR), and a back-end for IR to machine code.
Using an IR decouples the main compiler design from specific input and output foramts, making it more flexible and scalable.
Furthermore, if an IR would be used that is already part of existing compilation frameworks, it can re-use existing compiler techniques.
Target must be explicitly defined, using EHI \todo{elaborate}.


\subsection{Optimization}
We want to optimize programs with respect to various metrics.
Some of these metrics are those from standard compilers: memory usage and execution time (or makespan).
This holds for both classical and quantum code.
For classical code, standard optimziation can be used, e.g. from LLVM.
For quantum code, also existing techniques can be used, see e.g. \todo{REFS}.
These include circuit mapping and gate optimization techniques.

Moreover, by using the hybrid classical-quantum format we can re-use existing optimzations such as loop unrolling and other, see \todo{MLIR quantum papers}.
This also enables cross-subroutine optimizations, something not possible in NetQASM.

Other metrics we want to optimize for:
- amount of CPS-QPS communication
- success probability. Note that we do not fully control this. Add hints to scheduler.

Furthermore, we want to do noise-aware optimization.
Again, we can re-use existing things. See \cite{smith_error_2021, murali_noise-adaptive_2019}.

We \textit{add} the following kinds of optimizations.
\begin{itemize}
  \item re-order operations to minimize qubit memory time
    AFAIK not done in any other compiler (hybrid classical-quantum reordering yes, but not specifically to reduce qubit `live' time)
  \item add deadline to block to guide scheduling
\end{itemize}




\subsection{Multi-node coordination}
\todo{Should this section be called `error detection' to mirror the 3 purposes mentioned in the Compilers section?}
Although typically a compiler only compiles for a local program, we want to discuss the context in which quantum network programs run and what the impact is.

Since applications consist of multiple cooperating programs, some kind of coordination is required.
The order of external operations in a program (message-passing and entanglement generation) must match with external operations in other programs.
An application protocol description is needed such that programmers know in which order they have to put their operations.
Such a description may also include a mechanism for re-trying a certain operations, needed when e.g. entanglement generation failed.

Another reason for having protocol description is demand registration to network controller (see \ref{todo ref to Qoala chapter}). To make an informed demand, a protocol description is needed such that nodes can synchronize their behavior and agree about timings, iterations, and retry mechanisms. Therefore, it makes sense to already have a protocol description at compile-time. This can also e.g. be something that is advertised as a service by some quantum server.

\todo{double check role of cap negotiation wrt compilation}
% Must be after compilation such that same executable can be re-used in multiple contexts. Uses input from users (that are about to run the application) and uses hints from the compiler (put into the executables). Also uses input from network controller (like current estimates of rate, fidelity).

We can imagine a protocol description to at least contain the following elements:
\begin{itemize}
    \item Must contain: order of interactive steps
    \item May contain: timing constraints, constraints on fidelity of entanglement and of certain states
\end{itemize}

A protocol description can also help the compiler make more informed optimizations.
It could extend correctness checking (see above) by checking if the source adheres to the protocol description. 
Furthermore, the compiler may compute deadlines based on information in the protocol.
For example, if the protocol says that entanglement generation must happen within a certain amount of time, the compiler can insert deadlines such that the node scheduler can try to meet this protocol timing demand.


We distinguish two Modes of Compilation (MoC):
\begin{itemize}
    \item Protocol-informed compilation: a pre-defined protocol exists describing at least the order of interactive steps that the nodes must execute. A compiler may take advantage of such a protocol description.
    \item Standard compilation: there is no pre-defined description of a protocol, and a compiler cannot take advantage of such knowledge.
\end{itemize}




\section{Related work}
Many compilers and programming frameworks exist.

Classical frameworks: LLVM, others (needed?).

Overview of low-level compilers (focusing on resources constraints of NISQ, and on circuits): \cite{chong_programming_2017, murali_full-stack_2019, bandic_full-stack_2022}.

Fully quantum circuit optimizers, mostly related to qubit mapping: \cite{li_tackling_2019, zhang_context, bandic_mapping_2023, nishio_extracting_2020}.
Qunity: formal hybrid language, but only compiles to circuit (openqasm).

\cite{murali_noise-adaptive_2019} deals with backend compilation (LLVM IR to optimized circuit/OpenQASM).
\cite{murali_full-stack_2019} Provides broad discussion and proposal of compilation techniques for different platforms.
\cite{smith_error_2021} Mitigates decoherence by clever instruction ordering.
Idea of going beyond layered model and ISA (e.g. directly pulse optimization): \cite{shi_resource-efficient_2020}.

Scaffold -> LLVM IR -> OpenQASM: \cite{litteken_updated_2020}.

(Check Obsidian page on Programming Frameworks)

Split between
- joint classical-quantum optimization (MLIR-based, LLVM based): \cite{mccaskey_mlir_2021, ittah_enabling_2022, nguyen_retargetable_2022, peduri_qssa_2022}
- integration of classical and quantum code but optimization is separate or limited: \cite{litteken_updated_2020, fux_quingo_2021, khalate_llvm-based_2022, younis_quantum_2022}


(Relation to framework: XACC/qcor)



The idea of using IRs for quantum compilers has been used a lot: \cite{nigam_compiler_2021, nishio_inquir_2023}.

First mention of QIR: \cite{haner_software_2018}.
QIR is a upcoming standard as an IR for quantum computing. \cite{geller_introducing_2020}.
Recently there is network-related variant: NetQIR. \cite{vazquez-perez_netqir_2024}.
For DQC: InQuIR.

Compilers for quantum networking have not been studied much.
For distribution quantum computing there are compilers: \cite{ferrari_compiler_2021, haner_distributed_2021, cuomo_optimized_2023, ferrari_modular_2023}.
Circuit cutting: \cite{chatterjee_qurzon_2022}



\begin{itemize}
\item Catalyst (Xanadu Pennylane)
\item QSSA compiles down to OpenQASM, which itself does not map to physical (virtual) qubits. In OpenQASM, you declare qubit registers, but the mapping to physical qubits only happens at runtime.
\item Quantum Dialect (McCaskey/Nguyen) compiles to QIR, which also only contains the opaque `allocate`.
\item QIRO does not explain how to lower it to native quantum instructions
\end{itemize}

\begin{itemize}
    \item Hybrid language: does not yet exist for networking
      \todo{There is NetQIR now}
    \item Protocol description language: (timed) session types
    \item compiler to Qoala does not yet exist
    \item fidelity and timing constraints don't really exist
    \item noise-aware optimization for circuits exists, not for interactive hybrid programs
\end{itemize}

\subsection{Session types}
Model checking for communicating quantum processes: \cite{davidson_model_nodate}.
Follow-up with a language for describing protocols: \cite{ardeshir-larijani_automated_2018}.

Session types is a formalism used for defining communication protocols between different parties \cite{honda_language_1998}.
They can be used to for example specify the order in which messages need to be sent and received.
By having the protocol in a well-defined format, the parties can check whether they adhere to the agreed upon protocol.
Tools exist that can check at compile-time if a program adheres to a communication protocol.

Session types may be used for two parties, but multi-party session types also exist \cite{honda_multiparty_2016}.

First combination of quantum and multiparty session types: \cite{lanese_towards_2024}.

Timed session types add a time element. \cite{bartoletti_timed_2017}.
Timed session types have not yet been applied to quantum.

\section{Recommendations for further research and evaluation}
Based on the considerations discussed above, we propose the following ways in which to tackle the compilation design problem.


\textbf{Decouple front-end language from compilation framework by using Intermediate Representations (IRs)}
The front-end language is not a primary concern; we want to leave design and implementations open.
Use the existing technique of IRs, gradually lowering code and performing optimizations at each level.
Use MLIR since it allows defining custom dialects.

\textbf{Re-use existing (classical and quantum) compilation techniques}
These include classical techniques (loop unrolling etc) and quantum techniques (qubit mapping, gate optimzation etc).

\textbf{Perform optimizations on joint classical-quantum representation}
Make use of the fact that classical and quantum code can be jointly analyzed and optimized.
Use existing techniques, see \todo{refs to hybrid quantum compilers}.
Use MLIRs existing infrastructure.

\textbf{Use value-based representations}
In this way, existing optimizations acting on SSA can be directly re-used.
In a later pass, map to specific qubits, such that noise-aware optimziation can be done (see next point).
Can also be used to track fidelity estimations.

\textbf{Optimize using noise characteristics} use EHI (noise and topology)
Use Qoala's Exposed Hardware Info (EHI) to allow specific optimizations, including
\begin{itemize}
  \item Compiling to specific NetQASM flavor
  \item Mapping to specific qubits with better topology (also to make it valid in the first place \todo{add topology as part of target in translation})
  \item allow different optimization levels (aggressive, minimal, etc)
\end{itemize}

\textbf{Allow explicit targets to be defined}. Including flavor and topo

\textbf{Give hints to scheduler (deadlines)}
Use EHI to compute deadlines based on fidelity restrictions in source code.
\begin{itemize}
  \item Given expected durations for network operations, in combination with decoherence rates, compute deadlines for the scheduler to try and adhere to
\end{itemize}


\textbf{Use session types for protocol adherence checking}
Even without protocol description: do not re-order external operations.



Recommendation for overall design:

Input:
\begin{itemize}
  \item Inputs: program code (may contain fidelity/timing constraints), EHI
  \item (potentially protocol description)
\end{itemize}

Compilation:
\begin{itemize}
  \item General correctness checking
  \item (potentially: adherence to protocol checking)
  \item Translation to valid Qoala
  \item Optimization:
    \begin{itemize}
      \item General (gate optimization etc.)
      \item Insert hints to try and meet fidelity/timing constraints from program
      \item (potentially: insert hints to try and meet fidelity/timing constraints from protocol)
      \item Cannot re-order external operations
    \end{itemize}
\end{itemize}

Capability negotiation:
\begin{itemize}
  \item Potentially refer to protocol description and claim compatibility
  \item Establish demand, number of instances, inputs, deadlines
\end{itemize}


\subsection{Recommendations for evaluation}

\todo{EVALUATION}


\subsection{A note on Qoala program scope}
It's only **live quantum memory** that's time-sensitive.
The Qoala runtime provides a way to schedule and prioritize program parts such that quantum decoherence can be minimized.
To take advantage of this, quantum code, possibly interspersed with classical code, should be executed as Qoala programs.
However, it is not needed to write a whole program, including parts with purely classical code, in Qoala.