\chapter{Introduction}
\label{chp:intro}

\lettrine{A} world without computers and computer networks can hardly be imagined in our modern day in which we rely on them in many tasks.
From basic tasks like communication and information retrieval to more complex functions such as running businesses, managing global logistics, and advancing scientific research, we rely on these technologies to operate efficiently and stay connected.
Computers, with their ability to be programmed, can perform a vast array of tasks by executing instructions, making them highly versatile tools in fields ranging from science to entertainment.
When connected through networks, computers can share data, resources, and applications across the globe, amplifying their power and functionality.
This combination of programmability and networking has given rise to technologies like the internet, cloud computing, and distributed systems, all of which form the foundation of today's digital world.
% The advancements in computing and networking technologies have given rise to a wide range of \emph{applications}, including text processing, internet browsing, emailing, video games, and mobile phone apps, but also more modern one like artificial intelligence (AI), virtual reality, and blockchain technologies.

Quantum mechanics may seem, at first glance, unrelated to computers and networks, as it primarily describes how nature behaves at the sub-atomic level.
However, quantum computers and quantum networks present opportunities for applications that are impossible on non-quantum (or \emph{classical}) computers and networks.
While classical, digital, computers and networks represent data as 0s and 1s (bits), quantum computers use quantum bits (qubits) that can exist in multiple states simultaneously, thanks to the principles of superposition and entanglement.
This allows quantum computers to perform certain calculations much faster than classical computers, such as simulation, fast searching, and machine learning~\cite{montanaro_quantum_2016, dalzell_quantum_2023}\todo{check this}.
Quantum networks use quantum entanglement to realize quantum connections between its \emph{nodes}, which are quantum (computing) devices.
Using such remote entanglement connection, quantum networks enable applications~\cite{wehner_2018_stages} including data consistency in the cloud~\cite{benor_2005_byzantine}, privacy-enhancing proofs of deletion~\cite{poremba_quantum_2022}, exponential savings in communication~\cite{guerin_exponential_2016}, or secure quantum computing in the cloud~\cite{broadbent_2009_ubqc,childs_2005_secure_qc}.

To transform an application or use-case idea for computers and networks into a working system, a set of abstractions is essential.
These abstractions simplify complex hardware operations and allow developers to focus on designing functionality rather than dealing with low-level details.
These software abstractions include programming languages to write the code, compilers to translate that code into machine-readable instructions, and runtime environments (such as operating systems) to execute the application.
These tools, which are widespread for classical computing and networking~\cite{aho_compilers_2006, silberschatz_book_2014, james_computer_2016}, enable the efficient use of computing and networking resources, turning high-level ideas into executable software.
For quantum computers, similar abstractions have been developed, especially in the last decade.
These include QASM-like low-level instruction sets like QASM\todo{REFS} for quantum circuits, higher-level languages for representing hybrid classical-quantum code, and compilers and full-stack runtimes for hybrid classical-quantum execution.
Without such abstractions and tools, it would be nearly impossible to realize and scale innovative applications, whether in classical or quantum computing and networking.

The possibility of programming arbitrary applications in high-level software has led to a lot of impact.
Especially the realization of classical internet applications by has had a transformative impact on our society~\cite{castells_impact_2013}. What's more, the advent of programmable hardware and new application areas sparked novel fields of computer science research and guided further hardware development.


% qubits haven't made up their mind yet
% programs are recipes

% For classical computers and networks, these abstractions are widely developed and in-use \todo{cite standard works}.
% For quantum computers, similar abstractions have emerged and are spreading in the last few years.
% Quantum computations are typically represented as a \emph{quantum circuit}, consisting of qubits on which gates are applied.
% For quantum circuits, languages have been developed, such as OpenQASM, to program these.
% Higher-level programming languages like Q\# or Python-based software development kits exist, as well as compilers.
% Full-stack architectures exist that enable execution of arbitrary quantum applications.

% These abstraction allow one to reason about the logic of an application, and program is using abstract concepts, and they can be automatically optimized for different hardware targets.



\section{Problem statement}
While many ideas for using quantum networks exist, actually realizing them is presently challenging.

For quantum networks, abstractions like languages, compilers and runtimes are at present virtually non-existing.
Although early proposals like CQC~\cite{dahlberg2018simulaqron}, there is no way to program and execute arbitrary quantum network applications.

The first quantum networks linking multiple quantum computing devices have recently been realized as physics experiments in laboratories~\cite{moehring_2007_ion_traps,ritter_2012_elementary,hofmann_2012_heralded,stockill_2017_phasetuned,jing2019entanglement,stephenson_2020_highrate,pompili_2021_multinode,krutyanskiy_entanglement_2023} and fiber networks~\cite{liu2024creation,stolk2024metropolitan,knaut2024entanglement}.
However, these demonstrations so far relied either on ad-hoc software, or chose to establish that hardware parameters were in principle good enough to support a given quantum network application, although the application itself was not realized~\cite{nadlinger_device-independent_2022,liu_2022_photonic_diqkd,zhang_2022_diqkd}.
These experiments are highly technical, requiring manual manipulation of microwave pulses, lasers, and extensive knowledge of quantum physics. \todo{REFS}

It is however currently not possible to program arbitrary quantum network applications on a high-level, that is, without having to deal with low-level hardware-specific characteristics.
Indeed, there aren't yet any programming languages, compilers, or runtime systems for quantum network applications, making it difficult for programmers to implement and execute new applications.

One might think that one can re-use existing abstractions from quantum computing, as well as from classical computing and networking.
However, quantum network applications present unique challenges that need to be addressed.

First, there simply does not exist a representation for quantum network applications, high-level nor low-level, except for the CQC interface~\cite{dahlberg2018simulaqron}.
Existing quantum computing frameworks do not support representing remote entanglement operations, while these are crucial for quantum network applications.
Programming and execution frameworks do exist for distributed quantum computing, where a single computation is spread over multiple quantum computers.
However, distributed quantum computing differs from quantum network applications since in the latter we assume that each node independently chooses what application it executes.

Moreover, quantum network applications consist of a hybrid of classical and quantum code segments.
While such hybrid code is also seen in quantum computing --- such as \textit{variational quantum eigensolvers (VQE)}~\cite{diadamo2021distributed, liu2022layer} or \textit{quantum approximate optimization algorithms (QAOA)}~\cite{farhi2014quantum} ---
these typically alternate between classical code and quantum circuits.
In contrast, quantum network applications are more \textit{interactive}: classical and quantum code segments may run concurrently, communicating and influencing each other in real-time.
For instance, a quantum circuit may ``pause'' halfway, keeping quantum states in memory, and wait for a value from a classical segment (like a classical message from a remote node) before continuing.
Given the limited lifetime of quantum memories (due to decoherence), scheduling and synchronizing these interdependent quantum and classical segments is needed in order to achieve adequate application execution.


Another challenge is that there exist a variety of hardware technologies for quantum network nodes\todo{REFS}, with not a single of them likely to dominate.
Just as with classical and quantum computing, an abstraction is needed to shield developers from low-level hardware details, enabling them to focus on application logic.

Entanglement generation between nodes in a quantum network is particularly complex.
Significant research is underway to develop a quantum network stack, which organizes entanglement generation, timing coordination, routing, and application support.\todo{REFS}
A lot of research is done on how to realize a \emph{quantum network stack}, which organizes entanglement generation in networks, including timing synchronization, routing, and serving application requests.
However, how applications should interact with such a stack remains unclear.
Moreover, this integration requires handling both local operations and network-wide communication.

Finally, we are faced with a mix of time scales: on the one hand, entanglement generation requires a very precise network schedule that is agreed ahead of time between the network nodes~\cite{dahlberg2019link}.
On the other hand, classical messages are exchanged asynchronously between the nodes without guaranteed message delivery times.




\section{Research objective}
In this thesis, we address the gap that exists for the quantum internet: namely that there is no programming and execution framework for quantum internet applications.
The main goal is to \emph{enable programming and execution of arbitrary quantum network applications in a hardware-agnostic way while optmizing runtime performace}.
We work towards this goal by addressing the following research questions:

% Main objective
% - A programmer should be able to write a quantum network application in an abstract representation (i.e. using high-level concepts without having to know details of physical realizations of quantum networks)
% - Programmers should be able to run these abstract application descriptions on real quantum networks of various hardware types, in an optimized* way, without having to do these optimizations them
% - Enable hardware-agnostic optimized execution

\begin{itemize}
  \item[Q1.] \textbf{How should quantum network applications be programmed?}
    We first address the question of how one should represent quantum network applications as programming code.
    The goal is to develop a model similar to that in classical and quantum computing, where applications have both a high-level, human-friendly representation and a lower-level, execution-oriented one.

    One challenge comes from the hybrid nature of quantum network applications, which require the integration of both classical and quantum code.
    Additionally, we aim to support a variety of hardware types.
    For the high-level representation, programmers should be able to focus on application logic without needing to understand specific hardware constraints.
    For the lower-level representation, we aim for flexibility, allowing the integration of emerging hardware platforms as they are developed.
    We do this given the uncertainty around which quantum hardware platforms will ultimately prove viable.

    Finally, the representation should be suitable for execution on quantum network nodes, leading to the next research question.

  \item[Q2.] \textbf{How should a quantum network node execute arbitrary applications?}
    Programming an application is one step; executing it on real quantum network nodes is another.

    We tackle the challenge of executing arbitrary applications --- anything a programmer might write using our representation (Q1) --- on quantum network nodes.
    Again, the hybrid nature of these applications presents a challenge: how can we effectively control the execution of both classical and quantum code?
    Additionally, we must consider how application logic (classical or quantum) should interact with the networking code.
    
    Another difficulty is managing the range of timescales: classical communication typically operates in the millisecond range, whereas entanglement generation requires sub-nanosecond precision.
    Integrating these different timescales presents a significant challenge.

    Finally, in order to make optimal use of hardware and to increase throughput, we investigate how to enable multitasking of applications.

  \item[Q3.] \textbf{How can we improve performance of application execution?}
    A framework for programming and executing applications does not by itself guarantee optimal runtime performance.
    Application performance may be measured using classical metrics like execution time, and quantum metrics like success probability (see \cref{chp:background}).
    In general, the runtime performance of applications depends on ahead-of-time \emph{compilation} and runtime \emph{scheduling}.
    We investigate how we can perform compilation and scheduling in order to increase performance of applications.
    Especially in a multitasking scenario, scheduling has a large effect on performance.
    However, even without multitasking, the question remains of how to schedule both application code and networking tasks.

\end{itemize}


\section{Thesis Outline}
In this thesis, we work towards our goal of enabling programming and execution of quantum network applications.
We do this by presenting new architectures, tools, and paradigms.

In \cref{chp:background}, we first provide more background information about quantum internet applications.
It introduces concepts and terminology that are used in the following chapters.

In \cref{chp:netqasm}, we present NetQASM: a programming representation for quantum network applications, addressing Q1.
This representation includes a new low-level instruction set architecture tailored to quantum network applications,
but it also contains a high-level software development kit, enabling programming to express their application logic.
We purposefully make NetQASM hardware-independent and extendible.
We also introduce a first model for execution of applications programmed using NetQASM (Q2).
We evaluate our design choices in simulation.

In \cref{chp:qnodeos} we fully focus on the question of application execution (Q2).
Building on top of our execution model from \cref{chp:netqasm}, we present a detailed full-stack software architecture --- QNodeOS --- for executing arbitrary applications on quantum network nodes.
We implement this architecture on a setup with two real physical quantum network nodes, and show that our architecture can successfully execute quantum network applications.
We report on the performance of our architecture by looking at application throughput and success probability.


Based on what we learned from our QNodeOS implementation and evaluation, we propose an improved software architecture --- Qoala --- for executing applications on quantum network nodes in \cref{chp:qoala}.
Qoala that addresses the compilation and scheduling challenges found in QNodeOS.
Qoala allows hybrid classical-quantum compilation and scheduling.
% Qoala is an execution environment tailored to programmable quantum internet nodes, accommodating the hybrid, interactive, networked, and asynchronous nature of quantum internet applications.

In \cref{chp:compiler} we discuss how Qoala can be used for advanced compiler design.




% \section{Data and Software Availability}

% \begin{table}[t]
%     \centering
%     \begin{tabularx}{\linewidth}{lX}
%         \toprule
%         \textbf{Object}                   & \textbf{Location}                                                                 \\
%         \midrule
%         Datasets for \cref{chp:netqasm}   & \href{https://doi.org/10.4121/21355329}{\textsc{doi}: \texttt{10.4121/21355329}}  \\
%         NetQASM SDK                       & \url{https://github.com/QuTech-Delft/netqasm}                                     \\
%         NetQASM Simulator                 & \url{https://github.com/QuTech-Delft/squidasm}                                    \\
%         Datasets for \cref{chp:qnodeos}   & \href{https://doi.org/10.4121/6aa42f05-6823-4848-b235-3ea19e39f4ae}{\textsc{doi}: \texttt{10.4121/6aa42f05-6823-4848-b235-3ea19e39f4ae}} \\
%         Datasets for \cref{chp:qoala}     & TODO                                                                              \\
%         Qoala Simulator                   & \url{https://github.com/QuTech-Delft/qoala-sim}                                   \\
%         \bottomrule
%     \end{tabularx}
%     \caption{
%         Location of experimental data and software supporting this thesis.
%     }
%     \label{tab:data-and-soft}
% \end{table}


\begin{xstretch}
\printbibliography[heading=subbibintoc,title={References},notcategory=noprint]
\end{xstretch}
