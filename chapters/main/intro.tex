\chapter{Introduction}
\label{chp:intro}

% \lettrine{I}{nformation} serves as the backbone of human cognition, communication, and societal development.
% In everyday life, it guides our choices, interactions, and learning, while historically, it has been the driver of technological, cultural, and social evolution.

% Information processing can range from calculation and data storage to analysis, and may be referred to as \emph{computation}.
% When, around the middle of the 20th century, such computation began to be automated --- \emph{computers} ---, information processing improved drastically.
% Such digital computers represent information as 0s and 1s (bits), a remarkably effective way.
% Digital computers have since only been more widespread and society has become more dependent on it, with computers in the form of laptops, mobile phones, and smartwatches.
% Not only are computers able to automatically perform information processing with a speed that is humanly impossible, these computers can be \textit{programmed}: one can give it a list of instructions to do --- a recipe --- and in this way let the computer perform any computation that is desired.

% Exchange of information is critical as well: \emph{communication}.
% Computer networks, on the other hand, have improved the ability to communicate information.
% By connecting separate computers together over a network, they could suddenly share information and distribute computations.
% Information that is processed on a computer, such as an email typed by a user, can now be sent to another computer, and processed there, resulting in another computer user receiving a notification.
% Over time, more and more computing devices have been connected to each other --- of various mediums including glass fibre, copper wires, wireless, and others --- resulting in a world-spanning internet.
% This network of networks enables incredibly efficient exchange of information.
% Nowadays, a photograph taken by a mobile device (represented by several millions of bits \todo{check this}) can be sent within microseconds to another device in the world.

% These technologies have enabled a wide variety of use-cases --- \emph{applications}.
% Applications include text processing, internet browsing, emailing, and video games.
% On mobile devices they are often called apps for short.

\todo{begin generated}
\lettrine{I}{nformation} forms the backbone of human cognition, communication, and societal development.
In everyday life, it guides our decisions, interactions, and learning processes, while historically, it has driven technological, cultural, and social evolution.

Information processing can take many forms, from calculations and data storage to analysis, and is often referred to as computation.
In the mid-20th century, the automation of this process through the invention of computers revolutionized information processing.
Digital computers represent information as binary code—0s and 1s, or bits—a highly efficient method.
Since their introduction, computers have become increasingly widespread and integral to society, appearing in forms like laptops, mobile phones, and smartwatches.
These machines not only perform computations at speeds far beyond human capability but are also programmable, meaning they can be instructed to execute a sequence of tasks—or a "recipe"—to perform virtually any desired computation.

The exchange of information, or communication, is equally vital.
Computer networks have vastly enhanced the ability to share and distribute information.
By connecting individual computers over a network, they can exchange data and collaborate on tasks.
For example, information processed on one computer, such as an email typed by a user, can be transmitted to another computer where it is processed, notifying a recipient.
Over time, more computing devices have been connected through a variety of mediums—such as fiber optics, copper wires, and wireless signals—resulting in the creation of the global internet.
This vast network enables incredibly rapid and efficient information exchange.
Today, for instance, a photograph taken on a mobile device (comprising millions of bits) can be transmitted across the world in microseconds.

These advancements have given rise to a wide range of applications, including text processing, internet browsing, emailing, and video games.
On mobile devices, these are commonly referred to as apps.
\todo{end generated}

\todo{throughline: interplay of computation and communication}

% Quantum mechanics may on first sight be unrelated to computers; it describes how nature behaves at a very small (sub-atomic) scale.
% However, it turns out that using quantum features of superposition and entanglement can speed up computation considerably.
% If information is encoded as quantum bits (qubits) instead of the bits of digital computers, certain computations can be much faster compared to the non-quantum (classical) case.
% Qubits can be 0 and 1, but can also be in a \emph{superposition} of the two; it is like they haven't quite made up their mind about whether they want to be a 0 or 1.
% At the quantum scale, non-deterministic behavior is fundamental.
% Certain computations can be sped up considerably when using qubits (in such an indeterminate state) compared to using (classical) bits.
% Applications include simulation, fast searching, and machine learning.
% Technological developments have led to small-scale such quantum computers.
% As with classical \todo{introduce name, maybe also use `digital'} computers, quantum computers can also be connected, enabling the exchange of quantum information.
% A similar model as Neumann arch was developed for quantum computers. (quantum mem)

% Quantum mechanics also introduces communication primitives that are not possible classically.
% Examples of such applications include quantum key distribution (QKD)~\cite{bennett2014quantum, ekert1991quantum} and blind quantum computation (BQC) \cite{broadbent2009universal, arrighi2006blind} from a client to a quantum cloud server.




\todo{begin generated}
At first glance, quantum mechanics may seem unrelated to computing, as it primarily describes how nature behaves at the sub-atomic level.
However, leveraging quantum phenomena like superposition and entanglement can dramatically enhance computational capabilities.
When information is encoded using quantum bits (qubits) rather than the classical bits of digital computers, certain computations can be performed much faster.

Qubits, unlike classical bits that can only represent either a 0 or a 1, can exist in a superposition of both states simultaneously.
It's as if the qubit hasn't yet "decided" whether it wants to be a 0 or a 1.
At the quantum scale, this kind of probabilistic behavior is fundamental, and it can be exploited to speed up specific types of computations.
For example, algorithms that rely on qubits can significantly outperform their classical counterparts in tasks such as simulation, fast searching, and machine learning.

Recent technological advancements have led to the development of small-scale quantum computers.
Just as classical computers are networked to exchange digital information, quantum computers can also be interconnected, enabling the exchange of quantum information.
The Von Neumann architecture model, which laid the foundation for classical digital computing, has inspired similar models for quantum computers, including the concept of quantum memory.

Quantum mechanics also introduces new communication techniques that are impossible with classical systems.
These include applications such as quantum key distribution (QKD) for secure communication, and blind quantum computation (BQC), which allows a client to perform computations on a quantum cloud server without revealing the data being processed.
These quantum communication protocols promise enhanced security and privacy, making them crucial for the future of computing.
\todo{end generated}


Nowadays computation and communicatation applications are very much intertwined.

\todo{begin generated}
There is a significant gap between the high-level use-cases (applications) and the physical implementation of computers.
Applications can be thought of as a list of instructions, like a recipe, with commands such as "if the user input is X, do Y," or "send message M to another computer and wait for a response.
To implement any application, a programmer must write this recipe in code.

However, whether dealing with classical or quantum bits, the underlying information representation is not intuitive or native to humans.
While it is technically possible to write programs at the level of (qu)bits, it is neither practical nor scalable.
For example, a mobile app may consist of billions of bits, while an operating system like Windows might involve trillions.
Moreover, programmers are not required to interact with the low-level hardware elements, such as transistors or fiber optics.

To bridge this gap, several layers of abstraction have been developed, including programming languages, operating systems, and compilers.
These tools, such as Python or Windows, simplify the process of transforming ideas into working programs by managing the complexity of underlying hardware.

In the realm of quantum computing, we aim to develop similar abstractions.
Early tools like Qiskit and Quantum Inspire are emerging to assist programmers in writing code for quantum computers at a higher level of abstraction, making the process more accessible than directly manipulating quantum bits (qubits).
These tools include specialized programming languages, compilers (which translate code into signals that quantum computers can process), and runtimes (which manage the execution of these signals).
As these tools advance, they will play a crucial role in making quantum applications more practical and scalable.
\todo{end generated}

\section{Problem statement}
For quantum networks, no such tools for high-level programming exist as of yet.
So far, the experiments that have been done on small quantum networks have been very technical, involving manual handling of microwave pulses and lasers, and require a lot of physics knowledge.
There aren't yet any programming languages, compilers, or a runtime system for the quantum internet.
This makes it difficult for programmers to implement new ideas for using the quantum internet.

Creating tools for programming the quantum internet is a large challenge.
First, we don't have a high-level programming language for quantum internet applications.
Regular programming languages don't fit well with the special properties of quantum mechanics, like being in two states at once (superposition), quantum connections (entanglement), and quantum teleportation. Furthermore, although programming languages for quantum computers exist, they do not address the networking aspect of quantum internet applications.
Hence, a new kind of language is needed.
Second, we need a special compiler for quantum internet applications.
This compiler has to turn high-level quantum instructions into something the quantum hardware can use and do this efficiently, especially since quantum information has to work across different quantum devices and networks.
The compiler must make sure the instructions run well and can handle errors, considering how quantum information can easily get disrupted.
Lastly, running quantum internet applications has its own challenges.
A robust operating system is needed to manage how these quantum programs run.
This system has to set up, run, and keep the quantum states in sync across different places, while dealing with the unstable nature of quantum systems.
Our current quantum computing setups are mostly for single quantum processors and don't yet support the complex networking needed for a quantum internet.
To make progress in quantum network technology, we need to think carefully about how to design the programming language, how to compile the code, and how to schedule and run programs.
This is a large task that goes beyond just engineering; it's about bringing together different areas like regular computing, networking, and quantum computing.




\reminder{make sure all challenges of whole thesis are mentioned here: low-level representation (NetQASM), operating system (QNodeOS/Qoala), compiler}

Realizing the execution of quantum internet applications presents unique challenges (see Section~\ref{sec:design_considerations}): 
First, a program for a quantum internet application is not merely a hybrid of classical and quantum code segments; these segments are also highly \textit{interactive}: classical and quantum code may run concurrently, communicating and influencing each other.
E.g., a quantum circuit may "pause" halfway, keeping quantum states in memory, and wait for a value from a classical segment (e.g. a classical message from a remote node) before continuing.
Quantum memories have limited lifetimes, meaning qubits are subject to decoherence, degrading their quality over time. This introduces the need 
control the joint schedule of the classical and quantum segments of the program to reach desired levels of application performance.

Second, a compiler should be able to optimize the whole program including both classical and quantum code, as well as to provide information that can be used in our architecture to align and inform scheduling decisions. 

Finally, we are faced with a mix of time scales:
on the one hand, entanglement generation requires a very precise network schedule that is agreed ahead of time between the network nodes~\cite{dahlberg2019link}. On the other hand, classical messages are exchanged asynchronously between the nodes without guaranteed message delivery times. This motivates an architecture in which different segments of the system may operate at different levels of timing precision. 

\section{Research objective}
In this thesis, we address the gap that exists for the quantum internet: namely that there is no programming and execution framework for quantum internet applications.
We do this by addressing the following questions:

\begin{itemize}
  \item[Q1.] \textit{How should quantum network applications be programmed?}
    We address the above-mentioned gap in tools for programming quantum networks. \todo{make sure gap is mentioned}
    We explore challenges and requirements of both high-level (human-friendly) representations and of low-level (hardware-specific) representations.
    We propose both a high-level software development kit (SDK) and a low-level instruction set architecture (ISA) for quantum network applications.
    We want to address:
    \begin{itemize}
      \item How to be compatible with different hardware types
      \item Decide how to split classical and quantum execution
    \end{itemize}
  \item[Q2.] \textit{How can a quantum network node execute arbitrary applications?}
    We propose an architecture for quantum network nodes that allows arbitrary applications, using our SDK and ISA, to be executed.
    \begin{itemize}
      \item A question is how to deal with the hybrid and interactive nature of programs.
      \item How to deal with different timescales
      \item Enable multitasking
    \end{itemize}
  \item[Q3.] \textit{How is the performance of our execution model?}
    We investigate how our architecture works on real quantum hardware, and look at metrics including success probability and execution time.
  \item[Q4.] \textit{How can we optimize programs for execution on arbitrary hardware?}
    In classical and quantum computing, \emph{compilation} is used to optimize programs.
    In the networking case, and especially when dealing with multitasking, \emph{scheduling} also affects runtime performance.
    We investigate how we can enable such optimizations in our architecture.
\end{itemize}

Our solution hence consists of a new software architecture and new paradigms.
We evaluate our designs in simulation as well as on real hardware.

We do this by providing a software framework specifically designed for such applications.
This framework is an important step forward in addressing the unique challenges associated with quantum internet technology.
It comprises three key components:


Problems
- Quantum networks are not programmable using abstract concepts
- Quantum network programs cannot be automatically optimized since none of the existing compilation tools (classical and/or quantum) address the network dimension of programs
- Quantum network nodes do not have a hardware-agnostic way to execute programs

Main objective
- A programmer should be able to write a quantum network program in an abstract representation (i.e. using high-level concepts without having to know details of physical realizations of quantum networks)
- Programmers should be able to run these abstract program descriptions on real quantum networks of various hardware types, in an optimized* way, without having to do these optimizations them
- Enable hardware-agnostic optimized execution

\section{Thesis Outline}
This work shows a history of projects that build upon each other.
The work has been part of a larger ecosystem in which multiple projects worked towards the goal of executing quantum network applications.
Many software packages have been written.

The original goal of this PhD project was to research compilation of quantum network programs.
It turned out that first many other things needed to be fleshed out.
This thesis can be seen as following the road towards fleshing this out, culminating in a chapter with ideas on compilation.

In \cref{chp:background}, we provide more background information about quantum internet applications.
It introduces concepts and terminology such that the next chapters, which are very technical, make more sense.

In \cref{chp:netqasm} we introduce a model for quantum network nodes where classical and quantum execution is split.
Moreover, we present a way to represent quantum instructions, including remote entanglement generation, usuing a new instruction set architecture called NetQASM.
Furthermore, we introduce a software development kit (SDK) that allows a programmer to write quantum internet applications in a high-level human-readable language (Python).

We hence address the questions of
- representation, and a first answer to execution including multitasking

In \cref{chp:qnodeos} we propose a full-stack architecture, QNodeOS, for quantum network nodes which implements our NetQASM model.
We validate our architecture on real quantum hardware.

We hence verify our answers (\cref{chp:netqasm}) about representation and execution.
We get actual numbers on these and real experience.
We show that Q4 (optimization) depends on both compilation and scheduling,
and we show that QNodeOS and NetQASM do not fully enable this.


Based on what we learned from our QNodeOS implementation and evaluation, we propose an improved architecture --- Qoala --- for quantum network nodes in \cref{chp:qoala}.
Qoala that addresses the compilation and scheduling challenges found in QNodeOS.
Qoala allows hybrid classical-quantum compilation and scheduling.
% Qoala is an execution environment tailored to programmable quantum internet nodes, accommodating the hybrid, interactive, networked, and asynchronous nature of quantum internet applications.

In \cref{chp:compiler} we discuss how Qoala can be used for advanced compiler design.

% By 2020, the state of the art in quantum networks had reached significant milestones.
% Projects like CQC (Cambridge Quantum Computing) and tools like Simulaqron provided researchers with environments to simulate and experiment with quantum networks, further advancing the practical possibilities of quantum technology.



% Hardware by itself is insufficient to fully realize practical applications, especially in complex and scalable systems.
% To achieve true scalability and functionality, software and higher-level abstractions are essential.
% These abstractions create the necessary frameworks that allow hardware to be used effectively across different scenarios and at larger scales.

% This thesis addresses the need for such abstractions, offering structure to the challenges associated with realizing applications.
% It introduces new concepts, paradigms, and considerations designed to guide the development of scalable solutions, providing a structured approach to solving the problems that arise in application realization.



% This thesis presents a lot of design.
% All chapters follow the order design-considerations, architecture, evaluation.


\section{Data and Software Availability}

\begin{table}[t]
    \centering
    \begin{tabularx}{\linewidth}{lX}
        \toprule
        \textbf{Object}                   & \textbf{Location}                                                                 \\
        \midrule
        Datasets for \cref{chp:netqasm}   & \href{https://doi.org/10.4121/21355329}{\textsc{doi}: \texttt{10.4121/21355329}}  \\
        NetQASM SDK                       & \url{https://github.com/QuTech-Delft/netqasm}                                     \\
        NetQASM Simulator                 & \url{https://github.com/QuTech-Delft/squidasm}                                    \\
        Datasets for \cref{chp:qnodeos}   & \href{https://doi.org/10.4121/6aa42f05-6823-4848-b235-3ea19e39f4ae}{\textsc{doi}: \texttt{10.4121/6aa42f05-6823-4848-b235-3ea19e39f4ae}} \\
        Datasets for \cref{chp:qoala}     & TODO                                                                              \\
        Qoala Simulator                   & \url{https://github.com/QuTech-Delft/qoala-sim}                                   \\
        \bottomrule
    \end{tabularx}
    \caption{
        Location of experimental data and software supporting this thesis.
    }
    \label{tab:data-and-soft}
\end{table}


\begin{xstretch}
\printbibliography[heading=subbibintoc,title={References},notcategory=noprint]
\end{xstretch}
