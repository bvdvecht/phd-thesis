\chapter{Introduction}
\label{chp:intro}


\section{Research Goals}
Problems:
Problems
- Quantum networks are not programmable using abstract concepts
- Quantum network programs cannot be automatically optimized since none of the existing compilation tools (classical and/or quantum) address the network dimension of programs
- Quantum network nodes do not have a hardware-agnostic way to execute programs

Main objective
- A programmer should be able to write a quantum network program in an abstract representation (i.e. using high-level concepts without having to know details of physical realizations of quantum networks)
- Programmers should be able to run these abstract program descriptions on real quantum networks of various hardware types, in an optimized* way, without having to do these optimizations them
- Enable hardware-agnostic optimized execution


\section{IDK}
This work shows a history of projects that build upon each other.
The work has been part of a larger ecosystem in which multiple projects worked towards the goal of executing quantum network applications.
Many software packages have been written.

The original goal of this PhD project was to research compilation of quantum network programs.
It turned out that first many other things needed to be fleshed out.
This thesis can be seen as following the road towards fleshing this out, culminating in a chapter with ideas on compilation.

\section{A brief history of (quantum) computers}

\todo{Update below generated text}
Computers, in the early days, were not the machines we know today but rather human beings.
People, referred to as "computers," manually performed complex calculations.
As time progressed, mechanical devices took over these tasks, and with the advent of modern technology, machines capable of manipulating binary code—0s and 1s—became the norm.

The field of computing underwent another revolution with the introduction of quantum mechanics, which brought a new kind of fundamental value to the process.
Quantum computing, unlike classical computing, relies on principles such as superposition and entanglement, allowing it to handle complex problems far more efficiently.

The rise of quantum computing opened up a wealth of potential applications and use cases.
At the same time, the Internet, which initially began as a small network for information exchange among scientists, expanded into a global communications infrastructure.
This expansion also paved the way for the emergence of quantum communication, an area rooted in secure information exchange via quantum principles.

As the field of quantum computing advanced, tools were developed to support its growth.
New programming languages, compilers, simulators, and even online platforms—such as IBM's quantum computing access—enabled researchers and developers to explore quantum algorithms and systems.

By 2020, the state of the art in quantum networks had reached significant milestones.
Projects like CQC (Cambridge Quantum Computing) and tools like Simulaqron provided researchers with environments to simulate and experiment with quantum networks, further advancing the practical possibilities of quantum technology.



Hardware by itself is insufficient to fully realize practical applications, especially in complex and scalable systems.
To achieve true scalability and functionality, software and higher-level abstractions are essential.
These abstractions create the necessary frameworks that allow hardware to be used effectively across different scenarios and at larger scales.

This thesis addresses the need for such abstractions, offering structure to the challenges associated with realizing applications.
It introduces new concepts, paradigms, and considerations designed to guide the development of scalable solutions, providing a structured approach to solving the problems that arise in application realization.

\todo{end generated text}


This thesis presents a lot of design.
All chapters follow the order design-considerations, architecture, evaluation.


\section{Terminology}
\begin{itemize}
  \item Application
  \item Program
  \item EPR pair
  \item Quantum circuit or circuit
  \item Qubit
  \item Entanglement
\end{itemize}




\section{Intro from NetQASM paper}

\dropcap{Q}uantum mechanics shows that if one is able to communicate quantum information between nodes in a network, one is able to achieve certain tasks which are impossible using only classical communication.
There are many applications~\cite{Wehner2018stages} where a \emph{quantum network} has advantage over a \emph{classical (non-quantum) network}, either by
    (1) enabling something that is theoretically impossible in a classical network, such as the establishment of an unconditionally secure key~\cite{bb84} and secure blind quantum computing~\cite{childs2005assisted} or
    (2) allowing something to be done faster or more efficiently such as exponential savings in communication~\cite{Buhrman2010} and extending the baseline of telescopes~\cite{gottesman2012longer}.
In recent years, many experiments have been conducted to show that a quantum network is not only a theoretical concept, and indeed advancements have been made to implement such a quantum network on various hardware platforms.
\cite{Hensen2015, Humphreys2018, moehring2007entanglement, hofmann2012heralded, Kalb2017, Inlek2017, sangouard2011quantum}.
However, these experiments alone do not yet make a quantum network \textit{programmable}, since the program logic was hard-coded into the experimental hardware ahead of time.
\footnote{There have been examples of experiments with some simple logic but only with a very limited number of pre-loaded decision-branches.}

Before considering how to program quantum network applications, let us first briefly sketch the system our applications are run on.
Abstractly, quantum networks consist of \textit{nodes} that are connected by \textit{channels} (\cref{fig:network_model}).
Classical channels enable classical communication between nodes, while quantum channels are used for \textit{entanglement} generation between nodes.
So-called \textit{end-nodes} may contain \textit{quantum processors} that can run arbitrary (quantum) programs.
They have access to a quantum memory consisting of qubits, on which they can perform operations, including quantum computations.
Some of these qubits may be used for establishing an entangled quantum state with a remote node.
An end-node also possesses a classical processor and a classical memory.
Furthermore, an end-node can send and receive classical messages to and from other end-nodes in the network.
A network of quantum networks may be a called a \textit{quantum internet}.

Quantum (network) processors differ from classical processors in a number of ways.
Firstly, quantum memory has limited lifetime, meaning that its quality degrades over time.
For example, quantum memories based on nitrogen-vacancy (NV) centers in diamond have impressively been optimized to achieve lifetimes in the order of seconds~\cite{Abobeih2018};
however, this is still very short compared to classical memories, which generally do not have a limited lifetime at all.
Therefore, the quality of program execution is time-sensitive.
Secondly, physical devices are prone to inaccuracies which lead to decreased quality of (quantum) computation.
For example, applying an operation (like a gate) on a qubit affects that qubit's quality.
We note that the two challenges mentioned so far are also inherent to non-network quantum processors.
Quantum \textit{network} processors have additional challenges:
    (1) the processor may have to act as a local computation unit and a network interface at the same time;
    for example, in NV centers, an electron spin qubit is used for generating entanglement with a remote node but is also needed to do local two-qubit gates,
    (2) remote-entanglement operations may not have a fixed time in which they complete, which makes scheduling and optimization more difficult.

Quantum network \textit{applications}, also called \textit{protocols}, are multi-partite programs that involve entanglement generation and classical communication between different end-nodes, as well as local computation.
Examples include Quantum Key Distribution (QKD)~\cite{bb84, ekert1991quantum}, leader election protocols~\cite{kobayashi2014simpler, ganz2009quantum}, and Blind Quantum Computation (BQC)~\cite{Wehner2018stages}.
Such applications are split into distinct \textit{programs} each of which runs on a separate end-node.
The programs consist of both local operations (classical and quantum) and network operations (classical and quantum), see \cref{fig:app_programs}.
That is, the programs communicate either by passing classical messages, or by establishing quantum entanglement.
For example, BQC involves a \textit{client} node and a \textit{server} node, both of which run their own program.
Their joint execution looks roughly as follows:
    (1) The client and server engage in remote entanglement generation such that the server's quantum memory ends up being in a certain state,
    (2) the client sends instructions to the server in the form of a classical message,
    (3) the server performs a measurement-based computation on its own quantum memory based on the client's instructions,
    (4) the server sends measurement results back to the client,
    (5) the client sends new instructions based on the measurement results,
    (6) repeat steps 3 to 5 until the client obtains its desired result.

The example above illustrates that quantum network programs consist of different
types of operations.
Indeed, program code consists of \textit{classical code}, containing local classical operations and classical communication with other nodes, and \textit{quantum code}, which are operations on quantum memory (such as \textit{gates}) and remote entanglement generation.
Blocks of these types of code may depend on each other in multiple ways, as depicted in~\cref{fig:program_decomp}.
Programs with mixed classical and quantum operations have also been called \textit{dynamic quantum circuits}~\cite{cross2021openqasm, burgholzer2021towards}, but these do not cover the networking dimension found in programs we consider here, such as the dependency on remote information and entanglement generation operations.

Due to the nature of quantum network programs, execution may have to \textit{wait} for some time. For example, the program needs to wait until another node sends a classical message, or until remote entanglement has been established.
Therefore, it makes sense to run multiple (independent) quantum network programs on a node at the same time (interleaved), so that processor idle times can be filled by execution of other programs. This is something that typically does not happen on local quantum computers, and therefore introduces new challenges.

Quantum network applications may be programmed by a single actor.
For example, a developer may program a QKD application in the form of a two programs, and distribute these two programs to two end-nodes in the network.
Alternatively, a single-node quantum network program may be developed separately from other programs, possibly not knowing how these other programs are implemented.
For example, a BQC service provider could have already implemented the server-side program of a specific BQC protocol.
A client may then write the client-side of this protocol, without having control over the server-side implementation.




\section{Intro from qnodeos paper}
The first quantum networks linking multiple quantum processors as end nodes have recently been realized as physics experiments in laboratories~\cite{moehring_2007_ion_traps,ritter_2012_elementary,hofmann_2012_heralded,stockill_2017_phasetuned,jing2019entanglement,stephenson_2020_highrate,pompili_2021_multinode,krutyanskiy_entanglement_2023} and fiber networks~\cite{liu2024creation,stolk2024metropolitan,knaut2024entanglement}, opening the tantalizing possibility of realizing advanced quantum network applications~\cite{wehner_2018_stages} such as data consistency in the cloud~\cite{benor_2005_byzantine}, privacy-enhancing proofs of deletion~\cite{poremba_quantum_2022}, exponential savings in communication~\cite{guerin_exponential_2016}, or secure quantum computing in the cloud~\cite{broadbent_2009_ubqc,childs_2005_secure_qc}. Demonstrations relied either on ad-hoc software, or chose to establish that hardware parameters were in principle good enough to support a given quantum network application, although the application itself was not realized~\cite{nadlinger_device-independent_2022,liu_2022_photonic_diqkd,zhang_2022_diqkd}.

It is a major challenge to design and implement an architecture that can enable the execution of arbitrary quantum network applications on quantum processors (\cref{fig:fig1}), while enabling programming in high-level software that neither depends on the underlying quantum hardware, nor requires the programmer to understand the physics of the underlying devices.  In the domain of the conventional internet, the possibility of programming arbitrary internet applications in high-level software has led to the realization of radically new communication applications by diverse communities, which had a transformative impact on our society~\cite{castells_impact_2013}. What's more, the advent of programmable hardware and new application areas sparked novel fields of computer science research and guided further hardware development.  A similar development is underway in quantum computing, where the availability of high-level programming tools allows a broad participation in developing applications~\cite{noauthor_quantum_2024}.


\section{Intro from qoala paper}
Advances in quantum computing and quantum communication technologies are paving the way for a \textit{quantum internet}~\cite{wehner2018quantum, kimble2008quantum}, where quantum applications are executed across multiple network nodes.
Examples of such applications include quantum key distribution (QKD)~\cite{bennett2014quantum, ekert1991quantum} and blind quantum computation (BQC) \cite{broadbent2009universal, arrighi2006blind} from a client to a quantum cloud server.
A multi-node quantum internet application is partitioned into separate single-node \textit{programs} (e.g. a client program and a server program in BQC) that run concurrently on different network nodes. To support security sensitive applications, each program performs local classical and quantum computations on its own private node, and programs interact with each other only via classical message passing and entanglement generation. This is in sharp contrast to distributed quantum computing (see e.g.~\cite{cacciapuoti2019quantum}), where all nodes can be accessed and controlled by a single program. 

The single-node programs that constitute a quantum internet application are hybrid in nature (see Fig~\ref{fig:program_illustration}):
First, they contain quantum operations, such as local quantum gates and measurements (e.g. to perform a server computation in BQC), and entanglement generation (e.g. to produce key in QKD). Entanglement is a special property of two quantum bits (qubits) that forms a key resource for quantum internet applications. 
All quantum operations are executed on quantum processors that can store, manipulate and measure quantum information, where small networks including such processors have been realized using different quantum hardware platforms including, for example,  Nitrogen-Vacancy (NV) centers in diamond~\cite{pompili2021realization}, and Ion Traps~\cite{krutyanskiy2023entanglement}.
Second, programs need to perform classical operations, such as message passing (e.g., a BQC client program sending desired measurement bases to the BQC server), and local classical processing (e.g., post-processing measurement outcomes in QKD).

Realizing the execution of quantum internet applications presents unique challenges (see Section~\ref{sec:design_considerations}): 
First, a program for a quantum internet application is not merely a hybrid of classical and quantum code segments; these segments are also highly \textit{interactive}: classical and quantum code may run concurrently, communicating and influencing each other.
E.g., a quantum circuit may "pause" halfway, keeping quantum states in memory, and wait for a value from a classical segment (e.g. a classical message from a remote node) before continuing.
Quantum memories have limited lifetimes, meaning qubits are subject to decoherence, degrading their quality over time. This introduces the need 
control the joint schedule of the classical and quantum segments of the program to reach desired levels of application performance.

Second, a compiler should be able to optimize the whole program including both classical and quantum code, as well as to provide information that can be used in our architecture to align and inform scheduling decisions. 

Finally, we are faced with a mix of time scales:
on the one hand, entanglement generation requires a very precise network schedule that is agreed ahead of time between the network nodes~\cite{dahlberg2019link}. On the other hand, classical messages are exchanged asynchronously between the nodes without guaranteed message delivery times. This motivates an architecture in which different segments of the system may operate at different levels of timing precision. 


\section{Overview of chapters}
Quantum internet application frameworks have been evolving for some time.
Around 2020, when this PhD project started, CQC existed and SimulaQron.
No hardware implementation.


\section{Data and Software Availability}
\lipsum[51]


\section{Thesis Outline}
\lipsum[52]


\begin{xstretch}
\printbibliography[heading=subbibintoc,title={References},notcategory=noprint]
\end{xstretch}
