\chapter{Introduction}
\label{chp:intro}

% \lettrine{I}{nformation} serves as the backbone of human cognition, communication, and societal development.
% In everyday life, it guides our choices, interactions, and learning, while historically, it has been the driver of technological, cultural, and social evolution.

% Information processing can range from calculation and data storage to analysis, and may be referred to as \emph{computation}.
% When, around the middle of the 20th century, such computation began to be automated --- \emph{computers} ---, information processing improved drastically.
% Such digital computers represent information as 0s and 1s (bits), a remarkably effective way.
% Digital computers have since only been more widespread and society has become more dependent on it, with computers in the form of laptops, mobile phones, and smartwatches.
% Not only are computers able to automatically perform information processing with a speed that is humanly impossible, these computers can be \textit{programmed}: one can give it a list of instructions to do --- a recipe --- and in this way let the computer perform any computation that is desired.

% Exchange of information is critical as well: \emph{communication}.
% Computer networks, on the other hand, have improved the ability to communicate information.
% By connecting separate computers together over a network, they could suddenly share information and distribute computations.
% Information that is processed on a computer, such as an email typed by a user, can now be sent to another computer, and processed there, resulting in another computer user receiving a notification.
% Over time, more and more computing devices have been connected to each other --- of various mediums including glass fibre, copper wires, wireless, and others --- resulting in a world-spanning internet.
% This network of networks enables incredibly efficient exchange of information.
% Nowadays, a photograph taken by a mobile device (represented by several millions of bits \todo{check this}) can be sent within microseconds to another device in the world.

% These technologies have enabled a wide variety of use-cases --- \emph{applications}.
% Applications include text processing, internet browsing, emailing, and video games.
% On mobile devices they are often called apps for short.

\lettrine{I}{nformation} forms the backbone of human cognition, communication, and societal development.
In everyday life, it guides our decisions, interactions, and learning processes, while historically, it has driven technological, cultural, and social evolution.
Information must be processed --- \emph{computation} and exchanged --- \emph{communication}.

Computation can take many forms, from calculations and data storage to analysis.
In the mid-20th century, the automation of this process through the invention of computers revolutionized information processing.
Digital computers represent information as binary code—0s and 1s, or bits—a highly efficient method.
Since their introduction, computers have become increasingly widespread and integral to society, appearing in forms like laptops, mobile phones, and smartwatches.
These machines not only perform computations at speeds far beyond human capability but are also programmable, meaning they can be instructed to execute a sequence of tasks --- or a ``recipe'' --- to perform virtually any desired computation.

Communication involves sending and receiving messages, synchronization, and more.
Computer networks have vastly enhanced the ability to share and distribute information.
By connecting individual computers over a network, they can exchange data and collaborate on tasks.
For example, information processed on one computer, such as an email typed by a user, can be transmitted to another computer where it is processed, notifying a recipient.
Over time, more computing devices have been connected through a variety of mediums—such as fiber optics, copper wires, and wireless signals—resulting in the creation of the global internet.
This vast network enables incredibly rapid and efficient information exchange.
Today, for instance, a photograph taken on a mobile device (comprising millions of bits) can be transmitted across the world in microseconds.

These advancements have given rise to a wide range of applications, including text processing, internet browsing, emailing, and video games.
On mobile devices, these are commonly referred to as apps.
\todo{throughline: interplay of computation and communication}

% Quantum mechanics may on first sight be unrelated to computers; it describes how nature behaves at a very small (sub-atomic) scale.
% However, it turns out that using quantum features of superposition and entanglement can speed up computation considerably.
% If information is encoded as quantum bits (qubits) instead of the bits of digital computers, certain computations can be much faster compared to the non-quantum (classical) case.
% Qubits can be 0 and 1, but can also be in a \emph{superposition} of the two; it is like they haven't quite made up their mind about whether they want to be a 0 or 1.
% At the quantum scale, non-deterministic behavior is fundamental.
% Certain computations can be sped up considerably when using qubits (in such an indeterminate state) compared to using (classical) bits.
% Applications include simulation, fast searching, and machine learning.
% Technological developments have led to small-scale such quantum computers.
% As with classical \todo{introduce name, maybe also use `digital'} computers, quantum computers can also be connected, enabling the exchange of quantum information.
% A similar model as Neumann arch was developed for quantum computers. (quantum mem)

% Quantum mechanics also introduces communication primitives that are not possible classically.
% Examples of such applications include quantum key distribution (QKD)~\cite{bennett2014quantum, ekert1991quantum} and blind quantum computation (BQC) \cite{broadbent2009universal, arrighi2006blind} from a client to a quantum cloud server.



Quantum mechanics, at first glance, may seem unrelated to computers and networks, as it primarily describes how nature behaves at the sub-atomic level.
However, it turns out that quantum phenomena like superposition and entanglement can dramatically improve computational capabilities compared to digital, non-quantum (\textit{classical}) computers.
Qubits, unlike classical bits that can only represent either a 0 or a 1, can exist in a superposition of both states simultaneously.
Qubits can be forced to choose between 0 or 1, according to well-defined probabilities;
however, certain computations can be performed much faster by deliberately delaying these `decisions'.
Applications that can be sped up in this way include simulation, fast searching, and machine learning.\todo{citations}
Recent technological advancements have led to the development of small-scale quantum computers.
Just as classical computers are networked to exchange digital information, quantum computers can also be interconnected, enabling the exchange of quantum information.
The Von Neumann architecture model, which laid the foundation for classical digital computing, has inspired similar models for quantum computers, including the concept of quantum memory.

Quantum mechanics also introduces new communication techniques that are impossible with classical systems.
These include applications such as quantum key distribution (QKD) for secure communication, and blind quantum computation (BQC), which allows a client to perform computations on a quantum cloud server without revealing the data being processed.
These quantum communication protocols promise enhanced security and privacy, making them crucial for the future of computing.
ENTANGLEMENT


programmable and executable, abstractions (multitasking, OS)

\todo{begin generated}
There is a significant gap between the high-level use-cases (applications) and the physical implementation of computers.
Applications can be thought of as a list of instructions, like a recipe, with commands such as "if the user input is X, do Y," or "send message M to another computer and wait for a response.
To implement any application, a programmer must write this recipe in code.

However, whether dealing with classical or quantum bits, the underlying information representation is not intuitive or native to humans.
While it is technically possible to write programs at the level of (qu)bits, it is neither practical nor scalable.
For example, a mobile app may consist of billions of bits, while an operating system like Windows might involve trillions.
Moreover, programmers are not required to interact with the low-level hardware elements, such as transistors or fiber optics.

To bridge this gap, several layers of abstraction have been developed, including programming languages, operating systems, and compilers.
These tools, such as Python or Windows, simplify the process of transforming ideas into working programs by managing the complexity of underlying hardware.

In the realm of quantum computing, we aim to develop similar abstractions.
Early tools like Qiskit and Quantum Inspire are emerging to assist programmers in writing code for quantum computers at a higher level of abstraction, making the process more accessible than directly manipulating quantum bits (qubits).
These tools include specialized programming languages, compilers (which translate code into signals that quantum computers can process), and runtimes (which manage the execution of these signals).
As these tools advance, they will play a crucial role in making quantum applications more practical and scalable.
\todo{end generated}

% By 2020, the state of the art in quantum networks had reached significant milestones.
% Projects like CQC (Cambridge Quantum Computing) and tools like Simulaqron provided researchers with environments to simulate and experiment with quantum networks, further advancing the practical possibilities of quantum technology.

\section{Problem statement}
For quantum networks, no such tools for high-level programming exist as of yet.
So far, the experiments that have been done on small quantum networks have been very technical, involving manual handling of microwave pulses and lasers, and require a lot of physics knowledge.
There aren't yet any programming languages, compilers, or a runtime system for the quantum internet.
This makes it difficult for programmers to implement new ideas for using the quantum internet.

Creating tools for programming the quantum internet is a large challenge.
First, we don't have a high-level programming language for quantum internet applications.
Regular programming languages don't fit well with the special properties of quantum mechanics, like being in two states at once (superposition), quantum connections (entanglement), and quantum teleportation. Furthermore, although programming languages for quantum computers exist, they do not address the networking aspect of quantum internet applications.
Hence, a new kind of language is needed.
Second, we need a special compiler for quantum internet applications.
This compiler has to turn high-level quantum instructions into something the quantum hardware can use and do this efficiently, especially since quantum information has to work across different quantum devices and networks.
The compiler must make sure the instructions run well and can handle errors, considering how quantum information can easily get disrupted.
Lastly, running quantum internet applications has its own challenges.
A robust operating system is needed to manage how these quantum programs run.
This system has to set up, run, and keep the quantum states in sync across different places, while dealing with the unstable nature of quantum systems.
Our current quantum computing setups are mostly for single quantum processors and don't yet support the complex networking needed for a quantum internet.
To make progress in quantum network technology, we need to think carefully about how to design the programming language, how to compile the code, and how to schedule and run programs.
This is a large task that goes beyond just engineering; it's about bringing together different areas like regular computing, networking, and quantum computing.




\reminder{make sure all challenges of whole thesis are mentioned here: low-level representation (NetQASM), operating system (QNodeOS/Qoala), compiler}

Realizing the execution of quantum internet applications presents unique challenges (see Section~\ref{sec:design_considerations}): 
First, a program for a quantum internet application is not merely a hybrid of classical and quantum code segments; these segments are also highly \textit{interactive}: classical and quantum code may run concurrently, communicating and influencing each other.
E.g., a quantum circuit may "pause" halfway, keeping quantum states in memory, and wait for a value from a classical segment (e.g. a classical message from a remote node) before continuing.
Quantum memories have limited lifetimes, meaning qubits are subject to decoherence, degrading their quality over time. This introduces the need 
control the joint schedule of the classical and quantum segments of the program to reach desired levels of application performance.

Second, a compiler should be able to optimize the whole program including both classical and quantum code, as well as to provide information that can be used in our architecture to align and inform scheduling decisions. 

Finally, we are faced with a mix of time scales:
on the one hand, entanglement generation requires a very precise network schedule that is agreed ahead of time between the network nodes~\cite{dahlberg2019link}. On the other hand, classical messages are exchanged asynchronously between the nodes without guaranteed message delivery times. This motivates an architecture in which different segments of the system may operate at different levels of timing precision. 

\section{Research objective}
In this thesis, we address the gap that exists for the quantum internet: namely that there is no programming and execution framework for quantum internet applications.
We do this by addressing the following questions:

Main question: \textbf{How can one program and execute quantum network applications in a hardware-agnostic way while optimizing runtime performance?}

Problems
- Quantum networks are not programmable using abstract concepts
- Quantum network programs cannot be automatically optimized since none of the existing compilation tools (classical and/or quantum) address the network dimension of programs
- Quantum network nodes do not have a hardware-agnostic way to execute programs

Main objective
- A programmer should be able to write a quantum network program in an abstract representation (i.e. using high-level concepts without having to know details of physical realizations of quantum networks)
- Programmers should be able to run these abstract program descriptions on real quantum networks of various hardware types, in an optimized* way, without having to do these optimizations them
- Enable hardware-agnostic optimized execution

\todo{check that we only use the term `application', not `program'}

\begin{itemize}
  \item[Q1.] \textbf{How should quantum network applications be programmed?}
    We first address the question of how one should represent quantum network applications as programming code.
    The goal is to develop a model similar to that in classical and quantum computing, where applications have both a high-level, human-friendly representation and a lower-level, execution-oriented one.

    One challenge comes from the hybrid nature of quantum network applications, which require the integration of both classical and quantum code.
    Additionally, we aim to support a variety of hardware types.
    For the high-level representation, programmers should be able to focus on application logic without needing to understand specific hardware constraints.
    For the lower-level representation, we aim for flexibility, allowing the integration of emerging hardware platforms as they are developed.
    We do this given the uncertainty around which quantum hardware platforms will ultimately prove viable.

    Finally, the representation should be suitable for execution on quantum network nodes, leading to the next research question.

  \item[Q2.] \textbf{How should a quantum network node execute arbitrary applications?}
    Programming an application is one step; executing it on a real quantum network node is another.

    We tackle the challenge of executing arbitrary applications --- anything a programmer might write using our representation (Q1) --- on quantum network nodes.
    Again, managing the hybrid nature of these applications is a challenge: how can we effectively control the execution of both classical and quantum code?
    Additionally, we must consider how application logic (classical or quantum) should interact with the networking code.
    
    Another difficulty is managing the range of timescales: classical communication typically operates in the millisecond range, whereas entanglement generation requires sub-nanosecond precision.
    Integrating these different timescales presents a significant challenge.

    Finally, in order to make optimal use of hardware and to increase throughput, we investigate how to enable multitasking of applications.

  \item[Q3.] \textbf{How can we improve performance of application execution?}
    A framework for programming and executing applications does not by itself guarantee optimal runtime performance.
    Application performance may be measured using classical metrics like execution time, and quantum metrics like success probability (see \cref{chp:background}).
    In general, the runtime performance of applications depends on ahead-of-time \emph{compilation} and runtime \emph{scheduling}.
    We investigate how we can perform compilation and scheduling in order to increase performance of applications.
    Especially in a multitasking scenario, scheduling has a large effect on performance.
    However, even without multitasking, the question remains of how to schedule both application code and networking tasks.

\end{itemize}


\section{Thesis Outline}
In this thesis, we work towards our goal of enabling programming and execution of quantum network applications.
We do this by presenting new architectures, tools, and paradigms.

In \cref{chp:background}, we first provide more background information about quantum internet applications.
It introduces concepts and terminology that are used in the following chapters.

In \cref{chp:netqasm}, we present NetQASM: a programming representation for quantum network applications, addressing Q1.
This representation includes a new low-level instruction set architecture tailored to quantum network applications,
but it also contains a high-level software development kit, enabling programming to express their application logic.
We purposefully make NetQASM hardware-independent and extendible.
We also introduce a first model for execution of applications programmed using NetQASM (Q2).
We evaluate our design choices in simulation.

In \cref{chp:qnodeos} we fully focus on the question of application execution (Q2).
Building on top of our execution model from \cref{chp:netqasm}, we present a detailed full-stack software architecture --- QNodeOS --- for executing arbitrary applications on quantum network nodes.
We implement this architecture on a setup with two real physical quantum network nodes, and show that our architecture can successfully execute quantum network applications.
We report on the performance of our architecture by looking at application throughput and success probability.


Based on what we learned from our QNodeOS implementation and evaluation, we propose an improved software architecture --- Qoala --- for executing applications on quantum network nodes in \cref{chp:qoala}.
Qoala that addresses the compilation and scheduling challenges found in QNodeOS.
Qoala allows hybrid classical-quantum compilation and scheduling.
% Qoala is an execution environment tailored to programmable quantum internet nodes, accommodating the hybrid, interactive, networked, and asynchronous nature of quantum internet applications.

In \cref{chp:compiler} we discuss how Qoala can be used for advanced compiler design.




% \section{Data and Software Availability}

% \begin{table}[t]
%     \centering
%     \begin{tabularx}{\linewidth}{lX}
%         \toprule
%         \textbf{Object}                   & \textbf{Location}                                                                 \\
%         \midrule
%         Datasets for \cref{chp:netqasm}   & \href{https://doi.org/10.4121/21355329}{\textsc{doi}: \texttt{10.4121/21355329}}  \\
%         NetQASM SDK                       & \url{https://github.com/QuTech-Delft/netqasm}                                     \\
%         NetQASM Simulator                 & \url{https://github.com/QuTech-Delft/squidasm}                                    \\
%         Datasets for \cref{chp:qnodeos}   & \href{https://doi.org/10.4121/6aa42f05-6823-4848-b235-3ea19e39f4ae}{\textsc{doi}: \texttt{10.4121/6aa42f05-6823-4848-b235-3ea19e39f4ae}} \\
%         Datasets for \cref{chp:qoala}     & TODO                                                                              \\
%         Qoala Simulator                   & \url{https://github.com/QuTech-Delft/qoala-sim}                                   \\
%         \bottomrule
%     \end{tabularx}
%     \caption{
%         Location of experimental data and software supporting this thesis.
%     }
%     \label{tab:data-and-soft}
% \end{table}


\begin{xstretch}
\printbibliography[heading=subbibintoc,title={References},notcategory=noprint]
\end{xstretch}
