\chapter{Introduction}
\label{chp:intro}

\lettrine{O}{ur} human experience can for a large part be captured in the form of \emph{information}.
Information must be processed (\emph{computation}) and exchanged (\emph{communication}).
Computational power improved drastically when digital computers were created in the middle of the 20th century.
Such computers represent both information and calculations (operations) by 0s and 1s (bits), these computations could be automated by machines (von Neumann architecture) --- computers as we know them today, including laptops, mobile phones, and smartwatches.
Not only are computers able to automatically perform calculations with a speed that is humanly impossible, these computers can be \textit{programmed}: one can give it a list of instructions to do --- a recipe --- and in this way let the computer perform any computation that is desired.

\todo{not only calculations: also processing such as image creation, data management etc}

Communication technologies have seen considerable improvement as well.
Computer networks, on the other hand, have improved the ability to communicate information.
By connecting separate computers together over a network, they could suddenly share information and distribute computations.
Information that is processed on a computer, such as an email typed by a user, can now be sent to another computer, and processed there, resulting in another computer user receiving a notification.
Over time, more and more computing devices have been connected to each other --- of various mediums including glass fibre, copper wires, wireless, and others --- resulting in a world-spanning internet.
This network of networks enables incredibly efficient exchange of information.
Nowadays, a photograph taken by a mobile device (represented by several millions of bits \todo{check this}) can be sent within microseconds to another device in the world.

These technologies have enabled a wide variety of use-cases --- \emph{applications}.
Applications include text processing, internet browsing, emailing, and video games.
On mobile devices they are often called apps for short.


Quantum mechanics may on first sight be unrelated to computers.
In the 1980s, the idea arose of combining quantum mechanics with computers.
Quantum mechanics describes how nature behaves at a very small (sub-atomic) scale.
At this scale, non-deterministic behavior is fundamental.
One can harness this behavior by creating quantum bits (qubits) that can be 0 and 1, but can also be in a state in which they haven't quite made up their mind about whether they want to be a 0 or 1.
Certain computations can be sped up considerably when using qubits (in such an indeterminate state) compared to using (classical) bits.
Applications include simulation, fast searching, and machine learning.
Technological developments have led to small-scale such quantum computers.
As with classical \todo{introduce name, maybe also use `digital'} computers, quantum computers can also be connected, enabling the exchange of quantum information.
In 1984, a protocol was proposed to use quantum commnuication for establishing a secure encryption key.

A similar model as Neumann arch was developed for quantum computers. (quantum mem)

Advances in quantum computing and quantum communication technologies are paving the way for a \textit{quantum internet}~\cite{wehner2018quantum, kimble2008quantum}, where quantum applications are executed across multiple network nodes.
Examples of such applications include quantum key distribution (QKD)~\cite{bennett2014quantum, ekert1991quantum} and blind quantum computation (BQC) \cite{broadbent2009universal, arrighi2006blind} from a client to a quantum cloud server.
A multi-node quantum internet application is partitioned into separate single-node \textit{programs} (e.g. a client program and a server program in BQC) that run concurrently on different network nodes. To support security sensitive applications, each program performs local classical and quantum computations on its own private node, and programs interact with each other only via classical message passing and entanglement generation. This is in sharp contrast to distributed quantum computing (see e.g.~\cite{cacciapuoti2019quantum}), where all nodes can be accessed and controlled by a single program. 

Nowadays computation and communicatation applications are very much intertwined.


There is a gap between use-cases (applications) and the physical implementation of computers.
Applications may be thought of as a list of steps for a computer to do; a recipe if you will, with things like `if user input is X, do Y' and `first send a message M to the other computer, and then wait for a response'.
To realize any application, a programmer needs to write down this recipe.
However, whether it be classical or quantum bits, the information representation is not native to humans.
Although possible, it is not practical and scalable to directly write programs as (qu)bits.
An app on a mobile phone may be several billions of bits, and an operating system such as Windows may be trillions of bits.
Furthermore, programmers do not need to deal with low-level hardware layouts like transistors or glass fibers.
Instead, abstractions have been made, including programming languages, operating systems, and compilers.
They used more advanced tools including programming languages (like Python) and operating systems (like Windows) that help run the code.
These advanced tools make it much easier to turn new ideas into real computer or internet programs.
In the quantum world, we hope to have similar tools for making quantum applications.
For quantum computers, we're starting to see some early tools like Qiskit and Quantum Inspire.
These help programmers write code for quantum computers on a level that's a bit easier than dealing directly with the quantum bits (qubits).
These tools include special programming languages, compilers (which turn the code into signals the quantum computer can understand), and runtimes (which handle running these signals).

\section{Problem statement}
For quantum networks, no such tools for high-level programming exist as of yet.
So far, the experiments that have been done on small quantum networks have been very technical, involving manual handling of microwave pulses and lasers, and require a lot of physics knowledge.
There aren't yet any programming languages, compilers, or a runtime system for the quantum internet.
This makes it difficult for programmers to implement new ideas for using the quantum internet.

Creating tools for programming the quantum internet is a large challenge.
First, we don't have a high-level programming language for quantum internet applications.
Regular programming languages don't fit well with the special properties of quantum mechanics, like being in two states at once (superposition), quantum connections (entanglement), and quantum teleportation. Furthermore, although programming languages for quantum computers exist, they do not address the networking aspect of quantum internet applications.
Hence, a new kind of language is needed.
Second, we need a special compiler for quantum internet applications.
This compiler has to turn high-level quantum instructions into something the quantum hardware can use and do this efficiently, especially since quantum information has to work across different quantum devices and networks.
The compiler must make sure the instructions run well and can handle errors, considering how quantum information can easily get disrupted.
Lastly, running quantum internet applications has its own challenges.
A robust operating system is needed to manage how these quantum programs run.
This system has to set up, run, and keep the quantum states in sync across different places, while dealing with the unstable nature of quantum systems.
Our current quantum computing setups are mostly for single quantum processors and don't yet support the complex networking needed for a quantum internet.
To make progress in quantum network technology, we need to think carefully about how to design the programming language, how to compile the code, and how to schedule and run programs.
This is a large task that goes beyond just engineering; it's about bringing together different areas like regular computing, networking, and quantum computing.




The single-node programs that constitute a quantum internet application are hybrid in nature (see Fig~\ref{fig:program_illustration}):
First, they contain quantum operations, such as local quantum gates and measurements (e.g. to perform a server computation in BQC), and entanglement generation (e.g. to produce key in QKD). Entanglement is a special property of two quantum bits (qubits) that forms a key resource for quantum internet applications. 
All quantum operations are executed on quantum processors that can store, manipulate and measure quantum information, where small networks including such processors have been realized using different quantum hardware platforms including, for example,  Nitrogen-Vacancy (NV) centers in diamond~\cite{pompili2021realization}, and Ion Traps~\cite{krutyanskiy2023entanglement}.
Second, programs need to perform classical operations, such as message passing (e.g., a BQC client program sending desired measurement bases to the BQC server), and local classical processing (e.g., post-processing measurement outcomes in QKD).

\reminder{make sure all challenges of whole thesis are mentioned here: low-level representation (NetQASM), operating system (QNodeOS/Qoala), compiler}

Realizing the execution of quantum internet applications presents unique challenges (see Section~\ref{sec:design_considerations}): 
First, a program for a quantum internet application is not merely a hybrid of classical and quantum code segments; these segments are also highly \textit{interactive}: classical and quantum code may run concurrently, communicating and influencing each other.
E.g., a quantum circuit may "pause" halfway, keeping quantum states in memory, and wait for a value from a classical segment (e.g. a classical message from a remote node) before continuing.
Quantum memories have limited lifetimes, meaning qubits are subject to decoherence, degrading their quality over time. This introduces the need 
control the joint schedule of the classical and quantum segments of the program to reach desired levels of application performance.

Second, a compiler should be able to optimize the whole program including both classical and quantum code, as well as to provide information that can be used in our architecture to align and inform scheduling decisions. 

Finally, we are faced with a mix of time scales:
on the one hand, entanglement generation requires a very precise network schedule that is agreed ahead of time between the network nodes~\cite{dahlberg2019link}. On the other hand, classical messages are exchanged asynchronously between the nodes without guaranteed message delivery times. This motivates an architecture in which different segments of the system may operate at different levels of timing precision. 

\section{Research objective}
In this thesis, we address the gap that exists for the quantum internet: namely that there is no programming and execution framework for quantum internet applications.
We do this by addressing the following questions:

\begin{itemize}
  \item[Q1.] \textit{How should quantum network applications be programmed?}
    We address the above-mentioned gap in tools for programming quantum networks. \todo{make sure gap is mentioned}
    We explore challenges and requirements of both high-level (human-friendly) representations and of low-level (hardware-specific) representations.
    We propose both a high-level software development kit (SDK) and a low-level instruction set architecture (ISA) for quantum network applications.
  \item[Q2.] \textit{How can a quantum network node execute arbitrary applications?}
    We propose an architecture for quantum network nodes that allows arbitrary applications, using our SDK and ISA, to be executed.
  \item[Q3.] \textit{How is the performance of our execution model?}
    We propose an architecture for quantum network nodes that allows arbitrary applications, using our SDK and ISA, to be executed.
  \item[Q4.] \textit{What is needed to increase performance of application execution?}
\end{itemize}

Our solution hence consists of a new software architecture and new paradigms.
We evaluate our designs in simulation as well as on real hardware.

We do this by providing a software framework specifically designed for such applications.
This framework is an important step forward in addressing the unique challenges associated with quantum internet technology.
It comprises three key components:


Problems
- Quantum networks are not programmable using abstract concepts
- Quantum network programs cannot be automatically optimized since none of the existing compilation tools (classical and/or quantum) address the network dimension of programs
- Quantum network nodes do not have a hardware-agnostic way to execute programs

Main objective
- A programmer should be able to write a quantum network program in an abstract representation (i.e. using high-level concepts without having to know details of physical realizations of quantum networks)
- Programmers should be able to run these abstract program descriptions on real quantum networks of various hardware types, in an optimized* way, without having to do these optimizations them
- Enable hardware-agnostic optimized execution

\section{Thesis Outline}
This work shows a history of projects that build upon each other.
The work has been part of a larger ecosystem in which multiple projects worked towards the goal of executing quantum network applications.
Many software packages have been written.

The original goal of this PhD project was to research compilation of quantum network programs.
It turned out that first many other things needed to be fleshed out.
This thesis can be seen as following the road towards fleshing this out, culminating in a chapter with ideas on compilation.

In \cref{chp:background}, we provide more background information about quantum internet applications.
It introduces concepts and terminology such that the next chapters, which are very technical, make more sense.

In \cref{chp:netqasm} we introduce a model for quantum network nodes where quantum instructions, including remote entanglement generation, are represented in a new instruction set architecture called NetQASM.
Furthermore, we introduce a software development kit (SDK) that allows a programmer to write quantum internet applications in a high-level human-readable language (Python).
% The SDK translates this code into NetQASM.
% We implement NetQASM on a quantum network simulator and verify its effectiveness.
% Furthermore, we integrate NetQASM with real quantum hardware based on NV-centers in diamond.
% We note that NetQASM still leaves open possibilities for improvement regarding both compilation and efficient execution.
In \cref{chp:qnodeos} we propose a full-stack architecture, QNodeOS, for quantum network nodes and demonstrate its effectiveness on real quantum hardware.
QNodeOS uses NetQASM.
In \cref{chp:qoala}, we propose an improvement over QNodeOS first runtime environment, Qoala, that addresses the compilation and execution challenges found in QNodeOS.
Qoala allows hybrid classical-quantum compilation and scheduling.
% Qoala is an execution environment tailored to programmable quantum internet nodes, accommodating the hybrid, interactive, networked, and asynchronous nature of quantum internet applications.

In \cref{chp:compiler} we discuss how Qoala can be used for advanced compiler design.

% By 2020, the state of the art in quantum networks had reached significant milestones.
% Projects like CQC (Cambridge Quantum Computing) and tools like Simulaqron provided researchers with environments to simulate and experiment with quantum networks, further advancing the practical possibilities of quantum technology.



% Hardware by itself is insufficient to fully realize practical applications, especially in complex and scalable systems.
% To achieve true scalability and functionality, software and higher-level abstractions are essential.
% These abstractions create the necessary frameworks that allow hardware to be used effectively across different scenarios and at larger scales.

% This thesis addresses the need for such abstractions, offering structure to the challenges associated with realizing applications.
% It introduces new concepts, paradigms, and considerations designed to guide the development of scalable solutions, providing a structured approach to solving the problems that arise in application realization.



% This thesis presents a lot of design.
% All chapters follow the order design-considerations, architecture, evaluation.


\section{Intro from NetQASM paper}

\dropcap{Q}uantum mechanics shows that if one is able to communicate quantum information between nodes in a network, one is able to achieve certain tasks which are impossible using only classical communication.
There are many applications~\cite{Wehner2018stages} where a \emph{quantum network} has advantage over a \emph{classical (non-quantum) network}, either by
    (1) enabling something that is theoretically impossible in a classical network, such as the establishment of an unconditionally secure key~\cite{bb84} and secure blind quantum computing~\cite{childs2005assisted} or
    (2) allowing something to be done faster or more efficiently such as exponential savings in communication~\cite{Buhrman2010} and extending the baseline of telescopes~\cite{gottesman2012longer}.
In recent years, many experiments have been conducted to show that a quantum network is not only a theoretical concept, and indeed advancements have been made to implement such a quantum network on various hardware platforms.
\cite{Hensen2015, Humphreys2018, moehring2007entanglement, hofmann2012heralded, Kalb2017, Inlek2017, sangouard2011quantum}.
However, these experiments alone do not yet make a quantum network \textit{programmable}, since the program logic was hard-coded into the experimental hardware ahead of time.
\footnote{There have been examples of experiments with some simple logic but only with a very limited number of pre-loaded decision-branches.}

Before considering how to program quantum network applications, let us first briefly sketch the system our applications are run on.
Abstractly, quantum networks consist of \textit{nodes} that are connected by \textit{channels} (\cref{fig:network_model}).
Classical channels enable classical communication between nodes, while quantum channels are used for \textit{entanglement} generation between nodes.
So-called \textit{end-nodes} may contain \textit{quantum processors} that can run arbitrary (quantum) programs.
They have access to a quantum memory consisting of qubits, on which they can perform operations, including quantum computations.
Some of these qubits may be used for establishing an entangled quantum state with a remote node.
An end-node also possesses a classical processor and a classical memory.
Furthermore, an end-node can send and receive classical messages to and from other end-nodes in the network.
A network of quantum networks may be a called a \textit{quantum internet}.

Quantum (network) processors differ from classical processors in a number of ways.
Firstly, quantum memory has limited lifetime, meaning that its quality degrades over time.
For example, quantum memories based on nitrogen-vacancy (NV) centers in diamond have impressively been optimized to achieve lifetimes in the order of seconds~\cite{Abobeih2018};
however, this is still very short compared to classical memories, which generally do not have a limited lifetime at all.
Therefore, the quality of program execution is time-sensitive.
Secondly, physical devices are prone to inaccuracies which lead to decreased quality of (quantum) computation.
For example, applying an operation (like a gate) on a qubit affects that qubit's quality.
We note that the two challenges mentioned so far are also inherent to non-network quantum processors.
Quantum \textit{network} processors have additional challenges:
    (1) the processor may have to act as a local computation unit and a network interface at the same time;
    for example, in NV centers, an electron spin qubit is used for generating entanglement with a remote node but is also needed to do local two-qubit gates,
    (2) remote-entanglement operations may not have a fixed time in which they complete, which makes scheduling and optimization more difficult.

Quantum network \textit{applications}, also called \textit{protocols}, are multi-partite programs that involve entanglement generation and classical communication between different end-nodes, as well as local computation.
Examples include Quantum Key Distribution (QKD)~\cite{bb84, ekert1991quantum}, leader election protocols~\cite{kobayashi2014simpler, ganz2009quantum}, and Blind Quantum Computation (BQC)~\cite{Wehner2018stages}.
Such applications are split into distinct \textit{programs} each of which runs on a separate end-node.
The programs consist of both local operations (classical and quantum) and network operations (classical and quantum), see \cref{fig:app_programs}.
That is, the programs communicate either by passing classical messages, or by establishing quantum entanglement.
For example, BQC involves a \textit{client} node and a \textit{server} node, both of which run their own program.
Their joint execution looks roughly as follows:
    (1) The client and server engage in remote entanglement generation such that the server's quantum memory ends up being in a certain state,
    (2) the client sends instructions to the server in the form of a classical message,
    (3) the server performs a measurement-based computation on its own quantum memory based on the client's instructions,
    (4) the server sends measurement results back to the client,
    (5) the client sends new instructions based on the measurement results,
    (6) repeat steps 3 to 5 until the client obtains its desired result.

The example above illustrates that quantum network programs consist of different
types of operations.
Indeed, program code consists of \textit{classical code}, containing local classical operations and classical communication with other nodes, and \textit{quantum code}, which are operations on quantum memory (such as \textit{gates}) and remote entanglement generation.
Blocks of these types of code may depend on each other in multiple ways, as depicted in~\cref{fig:program_decomp}.
Programs with mixed classical and quantum operations have also been called \textit{dynamic quantum circuits}~\cite{cross2021openqasm, burgholzer2021towards}, but these do not cover the networking dimension found in programs we consider here, such as the dependency on remote information and entanglement generation operations.

Due to the nature of quantum network programs, execution may have to \textit{wait} for some time. For example, the program needs to wait until another node sends a classical message, or until remote entanglement has been established.
Therefore, it makes sense to run multiple (independent) quantum network programs on a node at the same time (interleaved), so that processor idle times can be filled by execution of other programs. This is something that typically does not happen on local quantum computers, and therefore introduces new challenges.

Quantum network applications may be programmed by a single actor.
For example, a developer may program a QKD application in the form of a two programs, and distribute these two programs to two end-nodes in the network.
Alternatively, a single-node quantum network program may be developed separately from other programs, possibly not knowing how these other programs are implemented.
For example, a BQC service provider could have already implemented the server-side program of a specific BQC protocol.
A client may then write the client-side of this protocol, without having control over the server-side implementation.




\section{Intro from qnodeos paper}
The first quantum networks linking multiple quantum processors as end nodes have recently been realized as physics experiments in laboratories~\cite{moehring_2007_ion_traps,ritter_2012_elementary,hofmann_2012_heralded,stockill_2017_phasetuned,jing2019entanglement,stephenson_2020_highrate,pompili_2021_multinode,krutyanskiy_entanglement_2023} and fiber networks~\cite{liu2024creation,stolk2024metropolitan,knaut2024entanglement}, opening the tantalizing possibility of realizing advanced quantum network applications~\cite{wehner_2018_stages} such as data consistency in the cloud~\cite{benor_2005_byzantine}, privacy-enhancing proofs of deletion~\cite{poremba_quantum_2022}, exponential savings in communication~\cite{guerin_exponential_2016}, or secure quantum computing in the cloud~\cite{broadbent_2009_ubqc,childs_2005_secure_qc}. Demonstrations relied either on ad-hoc software, or chose to establish that hardware parameters were in principle good enough to support a given quantum network application, although the application itself was not realized~\cite{nadlinger_device-independent_2022,liu_2022_photonic_diqkd,zhang_2022_diqkd}.

It is a major challenge to design and implement an architecture that can enable the execution of arbitrary quantum network applications on quantum processors (\cref{fig:fig1}), while enabling programming in high-level software that neither depends on the underlying quantum hardware, nor requires the programmer to understand the physics of the underlying devices.  In the domain of the conventional internet, the possibility of programming arbitrary internet applications in high-level software has led to the realization of radically new communication applications by diverse communities, which had a transformative impact on our society~\cite{castells_impact_2013}. What's more, the advent of programmable hardware and new application areas sparked novel fields of computer science research and guided further hardware development.  A similar development is underway in quantum computing, where the availability of high-level programming tools allows a broad participation in developing applications~\cite{noauthor_quantum_2024}.



\section{Overview of chapters}
Quantum internet application frameworks have been evolving for some time.
Around 2020, when this PhD project started, CQC existed and SimulaQron.
No hardware implementation.


\section{Data and Software Availability}
\lipsum[51]


\section{Thesis Outline}
\lipsum[52]


\begin{xstretch}
\printbibliography[heading=subbibintoc,title={References},notcategory=noprint]
\end{xstretch}
