\chapter{Introduction}
\label{chp:intro}

\lettrine{I}{nformation} forms the backbone of human cognition, communication, and societal development.
In everyday life, it guides our decisions, interactions, and learning processes, while historically, it has driven technological, cultural, and social evolution.
Information must be processed --- \emph{computation} and exchanged --- \emph{communication}.

Computation can take many forms, from calculations and data storage to analysis.
In the mid-20th century, the automation of this process through the invention of computers revolutionized information processing.
Digital computers represent information as binary code—0s and 1s, or bits—a highly efficient method.
Since their introduction, computers have become increasingly widespread and integral to society, appearing in forms like laptops, mobile phones, and smartwatches.
These machines not only perform computations at speeds far beyond human capability but are also programmable, meaning they can be instructed to execute a sequence of tasks --- or a ``recipe'' --- to perform virtually any desired computation.

Communication involves sending and receiving messages, synchronization, and more.
Computer networks have vastly enhanced the ability to share and distribute information.
By connecting individual computers over a network, they can exchange data and collaborate on tasks.
For example, information processed on one computer, such as an email typed by a user, can be transmitted to another computer where it is processed, notifying a recipient.
Over time, more computing devices have been connected through a variety of mediums—such as fiber optics, copper wires, and wireless signals—resulting in the creation of the global internet.
This vast network enables incredibly rapid and efficient information exchange.
Today, for instance, a photograph taken on a mobile device (comprising millions of bits) can be transmitted across the world in microseconds.

These advancements have given rise to a wide range of applications, including text processing, internet browsing, emailing, and video games.
On mobile devices, these are commonly referred to as apps.


Quantum mechanics may seem, at first glance, unrelated to computers and networks, as it primarily describes how nature behaves at the sub-atomic level.
However, it turns out that quantum phenomena like superposition and entanglement can dramatically improve computational capabilities compared to digital, non-quantum (\textit{classical}) computers.
Qubits, unlike classical bits that can only represent either a 0 or a 1, can exist in a superposition of both states simultaneously.
Qubits can be forced to choose between 0 or 1, according to well-defined probabilities;
however, certain computations can be performed much faster by deliberately delaying these `decisions'.
Applications that can be sped up in this way include simulation, fast searching, and machine learning.\todo{citations}
Recent technological advancements have led to the development of small-scale quantum computers.
Just as classical computers are networked to exchange digital information, quantum computers can also be interconnected, enabling the exchange of quantum information.
The Von Neumann architecture model, which laid the foundation for classical digital computing, has inspired similar models for quantum computers, including the concept of quantum memory.

Quantum may also be applied to networks.
Quantum mechanics introduces new communication techniques that are impossible with classical systems.
These include applications such as quantum key distribution (QKD) for secure communication, and blind quantum computation (BQC), which allows a client to perform computations on a quantum cloud server without revealing the data being processed.
These quantum communication protocols promise enhanced security and privacy, making them crucial for the future of computing.
Quantum networks --- quantum computers connected to each other --- use remote entanglement in order to communicate or share information across nodes of the network.

The success of both classical and quantum computing and communication partly stems from the use of abstractions.
A significant gap exists between the high-level language of applications and the physical implementation of computers.
Applications can be seen as sets of instructions, much like a recipe, with commands such as ``if the user input is X, do Y'' or ``send message M to another computer and await a response''.
However, whether working with classical or quantum bits, the underlying representation of information is neither intuitive nor natural for humans.
Encoding these ``recipes" directly in bits or qubits would make it practically impossible to develop complex applications.
For instance, a mobile app may require billions of bits, while an operating system like Windows might involve trillions.
To create any application, programmers write these instructions in code, without needing to interact with low-level hardware elements like transistors or fiber optics.


Software abstractions solve these problems by providing tools:
higher-level programming languages allow one to express application logic in a (relatively) human-friendly representation,
lower-level languages and instruction sets allow application representations that are more tailored to the computing devices themselves,
compilers automatically translate higher-level code into the respective lower-level machine code,'
operating systems manage execution of applications,
and a network stack abstracts communication operations at different levels.
These tools simplify the process of transforming ideas into working applications by managing the complexity of underlying hardware.

For classical computers and networks, these abstractions are widely developed and in-use \todo{cite standard works}.
For quantum computers, similar abstractions have emerged and are spreading in the last few years.
Lower-level instruction sets such as OpenQASM are widely used;
higher-level programming languages like Q\# or Python-based software development kits exist, as well as compilers.
Full-stack architectures exist that enable execution of arbitrary quantum applications.


\section{Problem statement}
For quantum networks, there is at present a lack of such abstractions.
So far, the experiments that have been done on small quantum networks have been very technical, involving manual handling of microwave pulses and lasers, and require a lot of physics knowledge.
There aren't yet any programming languages, compilers, or a runtime system for quantum network applications.
This makes it difficult for programmers to implement new ideas for using quantum networks.

Problems
- Quantum networks are not programmable using abstract concepts
- Quantum network applications cannot be automatically optimized since none of the existing compilation tools (classical and/or quantum) address the network dimension of programs
- Quantum network nodes do not have a hardware-agnostic way to execute applications

One might think that one re-use existing abstractions from quantum computing, as well as from classical computing and networking.
However, certain unique properties of quantum network applications make this non-trivial.

First, application code for a quantum internet application is not merely a hybrid of classical and quantum code segments; these segments are also highly \textit{interactive}: classical and quantum code may run concurrently, communicating and influencing each other.
E.g., a quantum circuit may "pause" halfway, keeping quantum states in memory, and wait for a value from a classical segment (e.g. a classical message from a remote node) before continuing.
Quantum memories have limited lifetimes, meaning qubits are subject to decoherence, degrading their quality over time. This introduces the need 
control the joint schedule of the classical and quantum segments of the application to reach desired levels of application performance.

Second, a compiler should be able to optimize the whole application including both classical and quantum code, as well as to provide information that can be used in our architecture to align and inform scheduling decisions. 

Finally, we are faced with a mix of time scales:
on the one hand, entanglement generation requires a very precise network schedule that is agreed ahead of time between the network nodes~\cite{dahlberg2019link}. On the other hand, classical messages are exchanged asynchronously between the nodes without guaranteed message delivery times. This motivates an architecture in which different segments of the system may operate at different levels of timing precision. 

% By 2020, the state of the art in quantum networks had reached significant milestones.
% Projects like CQC (Cambridge Quantum Computing) and tools like Simulaqron provided researchers with environments to simulate and experiment with quantum networks, further advancing the practical possibilities of quantum technology.

\section{Research objective}
In this thesis, we address the gap that exists for the quantum internet: namely that there is no programming and execution framework for quantum internet applications.
The main goal is to \emph{enable programming and execution of arbitrary quantum network applications in a hardware-agnostic way while optmizing runtime performace}.

% Main objective
% - A programmer should be able to write a quantum network application in an abstract representation (i.e. using high-level concepts without having to know details of physical realizations of quantum networks)
% - Programmers should be able to run these abstract application descriptions on real quantum networks of various hardware types, in an optimized* way, without having to do these optimizations them
% - Enable hardware-agnostic optimized execution

\begin{itemize}
  \item[Q1.] \textbf{How should quantum network applications be programmed?}
    We first address the question of how one should represent quantum network applications as programming code.
    The goal is to develop a model similar to that in classical and quantum computing, where applications have both a high-level, human-friendly representation and a lower-level, execution-oriented one.

    One challenge comes from the hybrid nature of quantum network applications, which require the integration of both classical and quantum code.
    Additionally, we aim to support a variety of hardware types.
    For the high-level representation, programmers should be able to focus on application logic without needing to understand specific hardware constraints.
    For the lower-level representation, we aim for flexibility, allowing the integration of emerging hardware platforms as they are developed.
    We do this given the uncertainty around which quantum hardware platforms will ultimately prove viable.

    Finally, the representation should be suitable for execution on quantum network nodes, leading to the next research question.

  \item[Q2.] \textbf{How should a quantum network node execute arbitrary applications?}
    Programming an application is one step; executing it on a real quantum network node is another.

    We tackle the challenge of executing arbitrary applications --- anything a programmer might write using our representation (Q1) --- on quantum network nodes.
    Again, managing the hybrid nature of these applications is a challenge: how can we effectively control the execution of both classical and quantum code?
    Additionally, we must consider how application logic (classical or quantum) should interact with the networking code.
    
    Another difficulty is managing the range of timescales: classical communication typically operates in the millisecond range, whereas entanglement generation requires sub-nanosecond precision.
    Integrating these different timescales presents a significant challenge.

    Finally, in order to make optimal use of hardware and to increase throughput, we investigate how to enable multitasking of applications.

  \item[Q3.] \textbf{How can we improve performance of application execution?}
    A framework for programming and executing applications does not by itself guarantee optimal runtime performance.
    Application performance may be measured using classical metrics like execution time, and quantum metrics like success probability (see \cref{chp:background}).
    In general, the runtime performance of applications depends on ahead-of-time \emph{compilation} and runtime \emph{scheduling}.
    We investigate how we can perform compilation and scheduling in order to increase performance of applications.
    Especially in a multitasking scenario, scheduling has a large effect on performance.
    However, even without multitasking, the question remains of how to schedule both application code and networking tasks.

\end{itemize}


\section{Thesis Outline}
In this thesis, we work towards our goal of enabling programming and execution of quantum network applications.
We do this by presenting new architectures, tools, and paradigms.

In \cref{chp:background}, we first provide more background information about quantum internet applications.
It introduces concepts and terminology that are used in the following chapters.

In \cref{chp:netqasm}, we present NetQASM: a programming representation for quantum network applications, addressing Q1.
This representation includes a new low-level instruction set architecture tailored to quantum network applications,
but it also contains a high-level software development kit, enabling programming to express their application logic.
We purposefully make NetQASM hardware-independent and extendible.
We also introduce a first model for execution of applications programmed using NetQASM (Q2).
We evaluate our design choices in simulation.

In \cref{chp:qnodeos} we fully focus on the question of application execution (Q2).
Building on top of our execution model from \cref{chp:netqasm}, we present a detailed full-stack software architecture --- QNodeOS --- for executing arbitrary applications on quantum network nodes.
We implement this architecture on a setup with two real physical quantum network nodes, and show that our architecture can successfully execute quantum network applications.
We report on the performance of our architecture by looking at application throughput and success probability.


Based on what we learned from our QNodeOS implementation and evaluation, we propose an improved software architecture --- Qoala --- for executing applications on quantum network nodes in \cref{chp:qoala}.
Qoala that addresses the compilation and scheduling challenges found in QNodeOS.
Qoala allows hybrid classical-quantum compilation and scheduling.
% Qoala is an execution environment tailored to programmable quantum internet nodes, accommodating the hybrid, interactive, networked, and asynchronous nature of quantum internet applications.

In \cref{chp:compiler} we discuss how Qoala can be used for advanced compiler design.




% \section{Data and Software Availability}

% \begin{table}[t]
%     \centering
%     \begin{tabularx}{\linewidth}{lX}
%         \toprule
%         \textbf{Object}                   & \textbf{Location}                                                                 \\
%         \midrule
%         Datasets for \cref{chp:netqasm}   & \href{https://doi.org/10.4121/21355329}{\textsc{doi}: \texttt{10.4121/21355329}}  \\
%         NetQASM SDK                       & \url{https://github.com/QuTech-Delft/netqasm}                                     \\
%         NetQASM Simulator                 & \url{https://github.com/QuTech-Delft/squidasm}                                    \\
%         Datasets for \cref{chp:qnodeos}   & \href{https://doi.org/10.4121/6aa42f05-6823-4848-b235-3ea19e39f4ae}{\textsc{doi}: \texttt{10.4121/6aa42f05-6823-4848-b235-3ea19e39f4ae}} \\
%         Datasets for \cref{chp:qoala}     & TODO                                                                              \\
%         Qoala Simulator                   & \url{https://github.com/QuTech-Delft/qoala-sim}                                   \\
%         \bottomrule
%     \end{tabularx}
%     \caption{
%         Location of experimental data and software supporting this thesis.
%     }
%     \label{tab:data-and-soft}
% \end{table}


\begin{xstretch}
\printbibliography[heading=subbibintoc,title={References},notcategory=noprint]
\end{xstretch}
