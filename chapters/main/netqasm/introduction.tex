\section{Introduction}
\label{sec:introduction}

The aim of this work is to propose a way to program quantum network programs
and execute them on the end-nodes of a quantum network.



\begin{figure}[t]
    \centering
    \includegraphics[width=0.6\linewidth]{figures/netqasm/multi_program_app_2.pdf}
    \caption{A quantum network application consists of a program for each of the nodes involved in the application.
        Each program is locally executed by the node.
        Program execution on each node is split into execution in an application layer, which can send and receive classical messages, and a quantum processor, which can create entanglement with another node.
        The communication between nodes can hence be both classical and quantum.
        Communication instructions need to be matched by corresponding instructions in the other program.
        There is no global actor overseeing execution of each of the programs, and the nodes may be physically far apart.}
    \label{fig:app_programs}
\end{figure}

\begin{figure}[t]
    \centering
    \includegraphics[width=0.6\linewidth]{figures/netqasm/program_decomp.pdf}
    \caption{A program on a single node consists of different blocks of code, which can be quantum (pure quantum instructions with classical control in between), or classical (no quantum operations at all).
        These blocks may depend on each other in various ways.
        For example, the outcome of a measurement happening in one of the quantum blocks may be used in a calculation performed in one of the classical blocks.
        Blocks may also depend on other nodes.
        For instance, the value of a message coming from another node can influence the branch taken in one of the classical blocks.}
    \label{fig:program_decomp}
\end{figure}


In this work we introduce an abstract model---including a \ac{QNPU}--- for end-nodes in a quantum network, which we define in~\cref{sec:preliminaries}.
We then propose \ac{NetQASM}, an instruction set architecture that can be used to run arbitrary programs (of the form described in \cref{fig:program_decomp}) on end-nodes, as long as the end-nodes realize the model including the QNPU.

\ac{NetQASM} consists of a specification of a low-level assembly-like language to express the quantum parts of quantum network program code.
It also specifies how the application layer should interact with the \ac{QNPU} and how the assembly language can be used to execute (network) quantum code.
This is not possible using other QASM languages.

The \ac{NetQASM} language is extendible using the concept of \textit{flavors}.
The core language definition consists of a common set of instructions that are shared by all flavors.
This common set contains classical instructions for control-flow and classical memory operations.
This allows the realization of low-level control logic close to the quantum hardware;
for example, to perform branching based on a measurement outcome.
Quantum-specific instructions are bundled in flavors.
We introduce a \textit{vanilla} flavor containing universal platform-independent quantum gates.
Using this flavor of the \ac{NetQASM} language enables the platform-independent description of quantum network programs.
Platform-\textit{specific} flavors may be created to have quantum operations that are native and optimized for a specific hardware platform.
As an example, we show a flavor tailored to the Nitrogen-Vacancy (NV) hardware, a promising platform for quantum network end-nodes~\cite{Taminiau2014, hanson2021realization}.

In our model, application-specific classical communication only happens at the application layer (\cref{fig:app_programs}).
In particular, this means that \ac{NetQASM} contains no provision for classical communication with the remote node.
We remark that of course, classical control communication may be used by the \ac{QNPU} to realize the services of the quantum network stack accessed through \ac{NetQASM}.

We note that \ac{NetQASM} is used for representing and running code that runs on a single node in a quantum network.
Synchronization between the (\ac{NetQASM}) programs of multiple nodes is the responsibility of the programmer.
For example, in a client-server application, if the client code contains a `receive classical message' operation, it is the responsibility of the server node that its program code contains a `send classical message' operation at the right moment.
The same holds for instructions for creating remote entanglement.
In terms of precise timing, which is needed for entanglement generation, it is the \ac{QNPU} that is responsible to communicate and synchronize with the \ac{QNPU} of the other node to make sure entanglement attempts are synchronized.

With \ac{NetQASM}, we solve various problems that are unique to quantum internet programming:
    (1) for remote entanglement generation, we introduce new instruction types for making use of an underlying quantum network stack~\cite{dahlberg2019linklayer, kozlowski2020networklayer},
    (2) for the close interaction between classical and quantum operations, we use a shared-memory model for sharing classical data between the application layer and the \ac{QNPU},
    (3) in order to run multiple applications on the same quantum node---which may be beneficial for overall resource usage (see~\cref{sec:design_considerations})---we make use of virtualized quantum memory, similar to virtual memory in classical computing~\cite{arpaci2018operating},
    (4) since on some platforms, not all qubits may be used to generate remote entanglement, we introduce the concept of unit-modules describing qubit topologies with additional information per (virtual) qubit about which operations are possible.

Since \ac{NetQASM} is meant to be low-level, similar in nature to classical assembly languages, we have also developed a higher-level software development kit (SDK), in Python, to make it easier to write applications.
This SDK and related tools are open-source and freely available at~\cite{git_netqasm}, as part of our Quantum Network Explorer~\cite{qne_website}.
Through the SDK we have also enabled the quantum network simulators NetSquid~\cite{coopmans2021netsquid} and SimulaQron~\cite{dahlberg2018simulaqron} to run any application programmed in \ac{NetQASM}.

We have evaluated \ac{NetQASM} by simulating the execution of a teleportation application and a blind quantum computation using \ac{NetQASM}.
Hereby we have shown that interesting quantum internet applications can indeed be programmed using \ac{NetQASM}.
Furthermore, the evaluations argue certain design choices of \ac{NetQASM}, namely the use of so-called \textit{unit modules}, as well as platform-specific
\textit{flavors}.

We remark that \ac{NetQASM} has already been used on a real hardware setup in the lab, in a highly simplified test case that only produces entanglement~\cite{pompili2021experimental}.
\todo{refer to next chapter in which full stack has been implemented}


\subsection{Related Work}
\label{sec:related}
In the field of quantum computing, a substantial amount of progress has been made related to developing
architectures (e.g.~\cite{fu2017microarchitecture,bourassa2020photonicblueprint, murali2019fullstack, wecker2014liqui, khammassi2020openql, amy2019staq, green2013quipper, Steiger2016}),
instruction sets (e.g.~\cite{cross2017openqasm,khammassi2018cqasm,fu2019eqasm,liu2017fqasm,smith2016quil,qiskit,cirq,qsharp,jones2019quest}) and
compilers~\cite{zulehner2019compiling, haner2018software, gokhale2020quantum, liu2020new, gokhale2020optimized, ding2020square, smith2020opensource, Sivarajah_2020, hietala2019verified, zhang2020contextmapping, niu2020hardware, dury2020qubo, pozzi2020using, Nishio_2020}.
One example is QASM, an instruction set framework, borrowing ideas from classical assembly languages, which has gained a lot of popularity over the years and has been successfully integrated in software stacks for quantum computers.
There are in fact many variants of QASM such as OpenQASM~\cite{cross2017openqasm}, \texttt{cQASM}~\cite{khammassi2018cqasm}, \texttt{eQASM}~\cite{fu2019eqasm}, \texttt{f-QASM}~\cite{liu2017fqasm}.
Some of these variants are at a level closer to the physical implementation, such as \texttt{eQASM}, allowing for specifying low-level timing of quantum operations, while others, such as \texttt{f-QASM}, are at a higher level.
Together with the definition of these QASM-variants, progress has also been made in compilation of applications programmed in QASM to hardware implementations.
More abstract languages and programming frameworks for quantum programs include \texttt{Quil}~\cite{smith2016quil}, \texttt{Qiskit}~\cite{qiskit}, \texttt{Cirq}~\cite{cirq}, \texttt{Q\#}~\cite{qsharp}, \texttt{QuEST}~\cite{jones2019quest}.

None of these instruction sets or languages contain elements for remote entanglement generation (i.e. between different nodes), which \ac{NetQASM} does provide.
A \ac{NetQASM} program that uses the vanilla flavor and only contains local operations would look similar to an OpenQASM program.
However, the instruction set is not quite the same, since \ac{NetQASM} uses a different memory model than OpenQASM.
This is due to the hybrid nature of quantum network programs, which has more interaction between classical data and quantum data than non-networking programs (for which OpenQASM might be used).
So, \ac{NetQASM} is not just a superset of the OpenQASM instruction set (in the sense of adding entanglement instructions).

In~\cite{dahlberg2018simulaqron}, we introduced the \ac{CQC} interface, which was a first step towards a universal instruction set.
However, \ac{CQC} had a number of drawbacks, in particular:
    (1) \ac{CQC} does not have a notion of virtualized memory (see \cref{sec:design_considerations}), which meant that applications needed to use qubit IDs that were explicitly provided by the underlying hardware.
        This introduced more communication overhead and fewer optimization opportunities for the compiler.
    (2) \ac{CQC} does not provide as much information about hardware details.
        Therefore, platform-specific compilation and optimization is not possible.
    (3) Furthermore, \ac{CQC} does not match entirely with the later definition of our quantum network stack~\cite{dahlberg2019linklayer, kozlowski2020networklayer}.
        For example, it was not clearly defined how \ac{CQC} relates to the definition of a network layer.

Many of the ideas from e.g. QASM for how to handle and compile local gates can be reused also for quantum network applications.
For example, version 3 of OpenQASM~\cite{cross2021openqasm} which is under development, proposes close integration between \emph{local} classical logic and quantum operations, which is something we also propose in this work.
However, there are two key differences that we need to address:
\begin{enumerate}
      \item Instructions for generating entanglement between remote nodes in the network need to be handled and integrated with the rest of the application, see \cref{sec:abstract_model} below.
      \item The local operations performed by a node might depend on information communicated by another node and only known at runtime.
            Note that this is different from the conditionals on \emph{local} classical information, proposed in for example OpenQASM version 3, which does not require communication between remote nodes in a network.
            This brings new constraints in how to handle memory allocation, scheduling and addressing.
            We discuss this point in further detail in the coming sections.
\end{enumerate}
\ac{NetQASM} solves the above two points and improves upon \ac{CQC}.


\subsection{Outline}
In \cref{sec:preliminaries} we define relevant concepts and introduce the model of end-nodes that we use, including the \ac{QNPU}.
In \cref{sec:use_cases} we discuss use-cases of a quantum network which \ac{NetQASM} should support.
In \cref{sec:design_considerations} we consider requirements and considerations any instruction set architecture for quantum networks should fulfill which then lay the basis for the decisions that went into developing \ac{NetQASM}, see \cref{sec:design_decisions}.
In \cref{sec:implementation} and \cref{sec:python-sdk} we describe details about the \ac{NetQASM} language and associated SDK.
In \cref{sec:evaluation} we quantitatively evaluate some of the design decision of \ac{NetQASM} by benchmarking quality of execution using the quantum network simulator NetSquid~\cite{netsquid,coopmans2021netsquid}.
We conclude in \cref{sec:conclusion}.