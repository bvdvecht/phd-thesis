\section{Flow of messages}
\label{sec:app-messages}
Here we define the content of each of the messages being sent between the \ac{CNPU} and the \ac{QNPU}.
Each message has an ID chosen by the \ac{CNPU} which is used to associate replies from the \ac{QNPU} to the \ac{CNPU}.
\begin{itemize}
  \item \nq{RegisterApp}:
        Sent once from the \ac{CNPU} to the \ac{QNPU} whenever a new application starts.
        Contains information on what resources are required by the application, in particular:
        \begin{itemize}
            \item \nq{unit_module_spec}: Specification of unit-module needed, e.g. number of qubits.
            \item \nq{epr_socket_spec}: Specification of EPR sockets needed, see~\cite{kozlowski2020networklayer}, containing
                (1) EPR socket ID,
                (2) remote node ID,
                (3) remote EPR socket ID and
                (4) minimum required fidelity.
        \end{itemize}
  \item \nq{RegisterAppOK}:
            Returned from the \ac{QNPU} when application is registered, containing an application ID to be used for future messages.
            \begin{itemize}
                \item \nq{app_id}: Application ID.
            \end{itemize}
  \item \nq{RegisterAppErr}:
        Returned from the \ac{QNPU} when registration of application failed.
        For example if required resources could not be met.
        \begin{itemize}
            \item \nq{error_code}: Error code specifying what went wrong.
        \end{itemize}
  \item \nq{Subroutine}:
        Message from the \ac{CNPU} to the \ac{QNPU}, containing a subroutine to be executed.
        Details on the content are presented in later sections.
        \begin{itemize}
            \item \nq{app_id}: Application ID.
            \item \nq{subroutine}: The subroutine to be executed.
        \end{itemize}
  \item \nq{Done}:
        Message from the \ac{QNPU} to the \ac{CNPU}, indicating that a subroutine has finished.
        Which subroutine is indicated by the message ID.
        \begin{itemize}
            \item \nq{message_id} Message ID used for the \nq{Subroutine}-message.
        \end{itemize}
  \item \textbf{Update memory}:
        The \ac{CNPU} will have access to a copy of the memory allocated by the \ac{QNPU} for certain registers and arrays, see \cref{sec:language}.
        This memory is read-only by the \ac{CNPU}.
        Updates to the copy of the memory are performed by the end of a subroutine or if the subroutine is waiting.
        Furthermore, updates need to be explicitly specified in the subroutine by using one of the return-commands.
        How the actual update is implemented depends on the platform and can either be done by message-passing or with an actual shared memory.
        However, the subroutine is independent from this implementation.
        The \ac{CNPU} will be notified by an explicit message whenever the memory is updated.
  \item \nq{StopApp}:
        Sent from the \ac{CNPU} to the \ac{QNPU} indicating that an application is finished.
\end{itemize}


\section{Operands}
\label{sec:operands}
In this section we give the exact definition of the types of operands used in the \ac{NetQASM} language.
Each instruction of \ac{NetQASM} takes one or more operands.
There are five types of operands, which are listed and described below.
Each instruction has a fixed types of operands at each position.
The exact operands for each instruction is listed in \cref{app:instructions}.
We note also that in the human-readable text-form of \ac{NetQASM}, there are also \textit{branch variables}.
However, these are always replaced by \IMMEDIATE{}s (constants), corresponding to the instruction number of the subroutine, before serializing, see \cref{sec:branch_variables}.

The operand types of \ac{NetQASM} are:
\begin{itemize}
  \item \IMMEDIATE (constant): An integer seen as it's value.
        The following instruction, \nq{beq} \emph{branch-if-equal}, branches to instruction index \nq{12} since the number \nq{0} equals the number \nq{0}.
        \begin{nqcode}
beq 0 0 12\end{nqcode}
        In the binary encoding used at~\cite{git_netqasm}, \IMMEDIATE{}s are \nq{int32}.
  \item \REGISTER: A register specifying a register name and a index.
        The following instruction sets index \nq{0} of the register name \nq{R} to be \nq{0}.
        \begin{nqcode}
set R0 0\end{nqcode}
        In the current version of \ac{NetQASM} there are four register names and the indices are relative to the names.
        They are all functionally the same but are meant to be used for different purposes and increase readability:
        \begin{itemize}
          \item \nq{C}: Constants, meant to only be \nq{set} once throughout a subroutine.
          \item \nq{R}: Normal register, used for looping etc.
          \item \nq{Q}: Stores virtual qubit IDs.
          \item \nq{M}: Stores measurement outcomes.
        \end{itemize}
        In the binary encoding used at~\cite{git_netqasm}, \REGISTER{}s are specified by one byte and hold one \nq{int32}.
  \item \ADDRESS: Specifies an address to an array.
        Starts with \nq{@}.
        The following instruction declares an array of length \nq{10} at address \nq{0}.
        \begin{nqcode}
array 10 @0\end{nqcode}
        For more information about arrays, see below.
        The address here is just an identifier of the array and does not refer to a actual memory address.
        For this reason \nq{@1} above does not mean the second entry of the declared array but simply a different array.
        Addresses are relative to the application ID and are valid across subroutines.
  \item \textbf{ARRAY\_ENTRY}: Specifies an entry in an array.
        Takes the form \nq{@a[i]}, where \nq{a} specifies the address and \nq{i} the index.
        The following instruction stores the value of \nq{R0} to the second entry of the array with address \nq{0}.
        \begin{nqcode}
store R0 @0[1]\end{nqcode}
        In the text-form \nq{i} can either be an \IMMEDIATE\ or a \REGISTER, however in the binary encoding used at~\cite{git_netqasm}, \nq{i} is always a \REGISTER.
        This is handled by the compiler by using a \nq{set}-command before.
  \item \textbf{ARRAY\_SLICE}: Specifies a slice of an array.
        Takes the form \nq{@a[s:e]}, where \nq{a} specifies the address, \nq{s} the start-index (inclusive) and \nq{e} the end-index (exclusive).
        The following instruction waits for the second to the fourth entry of array with address \nq{0} to become not \nq{null}, see \cref{app:waiting}.
        \begin{nqcode}
wait_all @0[1:4]\end{nqcode}
        In the text-form \nq{s} and \nq{e} can either be an \IMMEDIATE{}s or a \REGISTER{}s, however in the binary encoding defined used at~\cite{git_netqasm}, \nq{s} and \nq{e} are always a \REGISTER{}s.
        This is handled by the compiler by using a \nq{set}-commands before.
\end{itemize}

\section{Branch variables}
\label{sec:branch_variables}
The human-readable text-form of \ac{NetQASM} supports the use of \emph{branch variables}.
Branch labels are declared as \nq{VAR}: before the instruction to branch to.
Before serializing a \ac{NetQASM}-subroutine, all branch variables are replaced with \IMMEDIATE{}s corresponding to the correct \emph{instruction index}.
Delaying this replacement to the end is useful if the compiler wants to move around instructions.
For example if a subroutine is as follows:
\begin{nqcode}
# NETQASM 1.0
# APPID 0
set R0 0

// Loop entry
LOOP:
beq R0 10 LOOP_EXIT

// Loop body
// If statement
bge R0 5 ELSE
// true block
add R0 R0 1
jmp IF_EXIT
// false block
ELSE:
add R0 R0 2
IF_EXIT:

// Loop exit
jmp LOOP
LOOP_EXIT:\end{nqcode}
Which effectively does the same as the following program written in Python (where the variable \py{i} corresponds to the register \nq{R0} above).
\begin{pycode}
i = 0
while i != 10:
  if i < 5:
    i += 1
  else:
    i += 2
\end{pycode}
After replacing the branch labels the body of the subroutine will instead look:
\begin{nqcode}
store R0 0
beq R0 10 7
bge R0 5 5
add R0 R0 1
jmp 6
add R0 R0 2
jmp 1\end{nqcode}

\section{Arrays}
Classical data produced during the execution of a subroutine are stored in either fixed registers or allocated arrays.
Arrays in \ac{NetQASM} have fixed-length, which is specified when declared using the \nq{array}-instruction.
Each entry of an array is an \emph{optional} \IMMEDIATE, meaning that the entry is an integer (e.g. \nq{int32}) or not defined (\nq{null}).
The arrays can be used to collect measurement outcomes to be returned to the \ac{CNPU} but also other data such as information about the generated remote entanglement~\cite{dahlberg2019linklayer,kozlowski2020networklayer}.
All wait-instructions of \ac{NetQASM} wait for one or more entries in an array to become defined (i.e. not \nq{null}).
The main use-case is for the execution of the subroutine to wait until the quantum network stack of the \ac{QNPU} has finished generated an entangled pair with a remote node.
The subroutine will be waiting for information about the entangled pair to be stored in a given array.
Once this is done, the execution can proceed.

The following subroutine for example creates and array with three elements, stores the values \nq{1} and \nq{2} to the array and reads them and adds them up, storing the value in the third entry.
\begin{nqcode}
// Create two constant registers
set C1 1
set C2 2
// Make an array of three entries
array 3 @0
// Load the constants to the array
store C1 @0[0]
store C2 @0[1]
// Load the array entries to two other registers
load R0 @0[0]
load R1 @0[1]
// Add the registers and store the result in the first
add R0 R1 R0
// Store the sum in the third entry of the array
store R0 @0[2]\end{nqcode}

\section{Qubit address operands}
Commands that perform actions on qubits have \REGISTER-operands which specify the virtual address of the qubit to act on.
It is good practice to use register name \nq{Q} for these registers.
The following subroutine performs a Hadamard gates on qubits with virtual addresses \nq{0}, \nq{1} and \nq{2}.
\begin{nqcode}
set Q0 0
set Q1 1
h Q0
h Q1
set Q0 2
h Q0\end{nqcode}
Note that \nq{Q0} is used twice but the value of the register is different.

\section{Instructions}
\label{app:instructions}
\setlist[itemize]{leftmargin=*}
Here we list the current instructions part of the \textbf{vanilla flavor} of \ac{NetQASM}.
For the most up to date version of the language, refer to~\cite{git_netqasm}.
Commands are specified as follows:
\begin{itemize}
  \item \nq{name}: Description of instruction.
        % Operands:
        \begin{enumerate}
          \item \IMMEDIATE : Description of op1
          \item \REGISTER : Description of op2
        \end{enumerate}
\end{itemize}

where \nq{name} is the name of the instruction, followed by the list of operands, specified by their type and description.
We note that in the human-readable text-form of \ac{NetQASM}, it is allowed to provide an \IMMEDIATE\ for operands that are specified as \REGISTER.
The compiler will then replace these, using the \nq{set}-command.

\subsection{Allocation}

\begin{itemize}
  \item \nq{qalloc}: Start using a qubit in the unit module.
        % Operands:
        \begin{enumerate}
          \item \REGISTER: The virtual address of the qubit.
        \end{enumerate}
  \item \nq{array}: Creates an array of a certain length (width is fixed)
        % Operands:
        \begin{enumerate}
          \item \IMMEDIATE: Number of entries in the array.
          \item \ADDRESS: Address of array
        \end{enumerate}
\end{itemize}


\subsection{Initialization}

\begin{itemize}
  \item \nq{init}: Initializes a qubit to $|0\rangle$
        % Operands:
        \begin{enumerate}
          \item \REGISTER: The virtual address of the qubit.
        \end{enumerate}
  \item \nq{set}: Set a register to a certain value.
        % Operands:
        \begin{enumerate}
          \item \REGISTER: The register to assign a value to.
          \item \IMMEDIATE: The value to assign.
        \end{enumerate}
\end{itemize}

\subsection{Memory operations}
\begin{itemize}
  \item \nq{store}: Stores the value in a register to an index of an array.
        % Operands:
        \begin{enumerate}
          \item \REGISTER: The register holding the value to store.
          \item \textbf{ARRAY\_ENTRY}: The array-entry to store the value to.
        \end{enumerate}
  \item \nq{load}: Loads the value from an index of an array to a register.
        % Operands:
        \begin{enumerate}
          \item \REGISTER: The register to store the value to.
          \item \textbf{ARRAY\_ENTRY}: The array-entry holding the value.
        \end{enumerate}
  \item \nq{undef}: Sets an entry of an array to \nq{null}, see \cref{app:waiting}.
        % Operands:
        \begin{enumerate}
          \item \textbf{ARRAY\_ENTRY} Array-entry to make \nq{null}.
        \end{enumerate}
  \item \nq{lea}: Loads a given address of an array to a register.
        % Operands:
        \begin{enumerate}
          \item \REGISTER: The register to store the address to.
          \item \ADDRESS: The address to the array.
        \end{enumerate}
\end{itemize}

\subsection{Classical logic}

There are three groups of branch instructions: nullary, unary and binary.

\textbf{Nullary branching}
\begin{itemize}
  \item \nq{jmp}: Jump to a given line (unconditionally).
        % Operands:
        \begin{enumerate}
          % \item \IMMEDIATE: Line to branch to.
          \item \IMMEDIATE: Line to branch to.
        \end{enumerate}
\end{itemize}

\textbf{Unary branching}
There are two unary branching instructions: \nq{beq} and \nq{bnz}, which both have the following structure:
\begin{itemize}
  \item \nq{b\{ez,nz\}}: Branch to a given line if condition fulfilled, see below.
        % Operands:
        \begin{enumerate}
          \item \REGISTER: Value $v$ in condition expression.
          \item \IMMEDIATE: Line to branch to.
        \end{enumerate}
\end{itemize}

Branching occurs if:
\begin{itemize}
  \item \nq{bez}: $v = 0$ (branch-if-zero)
  \item \nq{bnz}: $v \neq 0$ (branch-if-not-zero)
\end{itemize}

\textbf{Binary branching}
There are four binary branch instructions: \nq{beq}, \nq{bne}, \nq{blt} and \nq{bge}, which all have the following structure:
\begin{itemize}
  \item \nq{b\{eq,ne,lt,ge\}}: Branch if condition fulfilled, see below.
        % Operands:
        \begin{enumerate}
          \item \REGISTER: Value 1 $v_1$ in conditional expression.
          \item \REGISTER: Value 1 $v_1$ in conditional expression.
          \item \IMMEDIATE: Line to branch to.
        \end{enumerate}
\end{itemize}

Branching occurs if:
\begin{itemize}
  \item \nq{beq}: $v_0 = v_1$ (branch-if-equal)
  \item \nq{bne}: $v_0 \neq v_1$ (branch-if-not-equal)
  \item \nq{blt}: $v_0 < v_1$ (branch-if-less-than)
  \item \nq{bge}: $v_0 \geq v_1$ (branch-if-greater-or-equal)
\end{itemize}


\subsection{Classical operations}
There are currently four binary classical operations: addition (\nq{add}), subtraction (\nq{sub}) and addition (\nq{addm}), subtraction (\nq{subm}) modulo a number.
The first two have the following structure:
\begin{itemize}
  \item \nq{\{add,sub\}}: Perform a binary operation and store the result.
        % Operands:
        \begin{enumerate}
          \item \REGISTER Register to write result ($r$) to.
          \item \REGISTER First operand in binary operation ($v_0$).
          \item \REGISTER Second operand in binary operation ($v_1$).
        \end{enumerate}
\end{itemize}

The second two have an additional operand to specify what module should be taken for the result:
\begin{itemize}
  \item \nq{\{add,sub\}m}: Perform a binary operation modulo \nq{mod} and store the result.
        % Operands:
        \begin{enumerate}
          \item \REGISTER Register to write result ($r$) to.
          \item \REGISTER First operand in binary operation ($v_0$).
          \item \REGISTER Second operand in binary operation ($v_1$).
          \item \REGISTER Modulo in binary operation ($m$).
        \end{enumerate}
\end{itemize}

Binary operations are the following:
\begin{itemize}
  \item \nq{add}, $r = (v_0 + v_1)$
  \item \nq{sub}, $r = (v_0 - v_1)$
  \item \nq{addm}, $r = (v_0 + v_1) \pmod{m} $
  \item \nq{subm}, $r = (v_0 - v_1) \pmod{m} $
\end{itemize}

\subsection{Quantum gates}
\textbf{Single-qubit gates}
There is a number of single-qubit gates which all have the following structure
\begin{itemize}
  \item \nq{instr}: Perform a single-qubit gate.
        % Operands:
        \begin{enumerate}
          \item \REGISTER: The virtual address of the qubit.
        \end{enumerate}
\end{itemize}

Single-qubit gates without additional arguments are the following.
\begin{itemize}
  \item \nq{x}: X-gate.
        \begin{equation}\label{eq:pauli_x}
          X = \begin{pmatrix} 0 & 1 \\ 1 & 0 \end{pmatrix}
        \end{equation}
  \item \nq{y}: Y-gate.
        \begin{equation}\label{eq:pauli_y}
          Y = \begin{pmatrix} 0 & -i \\ i & 0 \end{pmatrix}
        \end{equation}
  \item \nq{z}: Z-gate.
        \begin{equation}\label{eq:pauli_z}
          Z = \begin{pmatrix} 1 & 0 \\ 0 & -1 \end{pmatrix}
        \end{equation}
  \item \nq{h}: Hadamard gate.
        \begin{equation}
          H = \frac{1}{\sqrt{2}} \begin{pmatrix} 1 & 1 \\ 1 & -1 \end{pmatrix}
        \end{equation}
  \item \nq{s}: S-gate (phase)
        \begin{equation}
          S = \begin{pmatrix} 1 & 0 \\ 0 & i \end{pmatrix}
        \end{equation}
  \item \nq{k}: K-gate.
        \begin{equation}
          K = \frac{1}{\sqrt{2}} \begin{pmatrix} 1 & -i \\ i & -1 \end{pmatrix}
        \end{equation}
  \item \nq{t}: T-gate.
        \begin{equation}
          T = \begin{pmatrix} 1 & 0 \\ 0 & e^{i\pi/4} \end{pmatrix}
        \end{equation}
\end{itemize}

\textbf{Single-qubit rotations}
Additionally one can perform single-qubit rotations with a given angle.
The angles \nq{a} are specified by two integers \nq{n} and \nq{d} as:
\begin{equation}
  a = \frac{n\pi}{2^d}
\end{equation}
These instructions have the following structure
\begin{itemize}
  \item \nq{rot_\{x,y,z\}}: Perform a single-qubit rotation.
        % Operands:
        \begin{enumerate}
          \item \REGISTER: The virtual address of the qubit.
          \item \IMMEDIATE: \nq{n}, for angle, see above.
          \item \IMMEDIATE: \nq{d}, for angle, see above.
        \end{enumerate}
\end{itemize}

Single-qubit rotations are the following.
\begin{itemize}
  \item \nq{rot_x}: Rotation around X-axis.
  \item \nq{rot_y}: Rotation around Y-axis.
  \item \nq{rot_z}: Rotation around Z-axis.
\end{itemize}

\textbf{Two-qubit gates}
There are two two-qubit gates which have the following structure
\begin{itemize}
  \item \nq{\{cnot,cphase\}}: Perform a two-qubit operation.
        % Operands:
        \begin{enumerate}
          \item \REGISTER: The virtual address of the control qubit.
          \item \REGISTER: The virtual address of the target qubit.
        \end{enumerate}
\end{itemize}

Two-qubit gates are the following.
\begin{itemize}
  \item \nq{cnot}: Controlled $X$ gate.
  \item \nq{cphase}: Controlled $Z$ gate.
\end{itemize}

\textbf{Measurement}
\begin{itemize}
  \item \nq{meas}: Measure a qubit in the standard basis.
        % Operands:
        \begin{enumerate}
          \item \REGISTER: The virtual address of the qubit.
          \item \REGISTER: The register to write outcome address to.
        \end{enumerate}
\end{itemize}

\textbf{Pre-measurement rotations}
To measure in other bases one can perform gates/rotations before the measurement.
If the same measurement basis is used a lot, one can also make use of pre-measurement rotations which can reduce the amount of communication needed internally in the \ac{QNPU}.
A pre-measurement rotations is specified by either the \nq{pmr_xyx}, \nq{pmr_zxz} or \nq{pmr_yzy} which have the following structure.
With any two of the bases X, Y and Z, one can do any rotation.
\begin{itemize}
  \item \nq{pmr_\{xyx,zxz,yzy\}}: Specify a pre-measurement rotation.
        % Operands:
        \begin{enumerate}
          \item \IMMEDIATE: \nq{n0}, for angle of first rotation, see below.
          \item \IMMEDIATE: \nq{d0}, for angle of first rotation, see below.
          \item \IMMEDIATE: \nq{n1}, for angle of second rotation, see below.
          \item \IMMEDIATE: \nq{d1}, for angle of second rotation, see below.
          \item \IMMEDIATE: \nq{n2}, for angle of third rotation, see below.
          \item \IMMEDIATE: \nq{d2}, for angle of third rotation, see below.
        \end{enumerate}
\end{itemize}
If a pre-measurement rotation is specified, then three rotations are performed before measuring using a \nq{meas_rot}-command, see below.
The axes of these rotations as given in the instruction name.

The angles of the rotations are specified by the integers \nq{n\{0,1,2\}} and \nq{d\{0,1,2\}} in the same way as for single-qubit rotations.
That is, rotation \nq{i} is done by angle $\frac{\pi n_i}{2^{d_i}}$.

\textbf{Entanglement generation}

There are two commands related to entanglement generation.
A node can initiate entanglement generation with another node by using the \nq{create_epr}-command.
This command is \emph{not} blocking until entanglement has been generated but a wait-instruction (see below) can be used to block until certain a certain array has been written to, indicating that entanglement has been generated.
The remote node should also provide a \nq{recv_epr}-command.
This command does not initiate the entanglement generation but is used to provide the virtual qubit IDs that should be used for the entangled qubits.

\begin{itemize}
  \item \nq{create_epr}: Create an EPR pair with a remote node.
        % Operands:
        \begin{enumerate}
          \item \REGISTER: Remote node ID.
          \item \REGISTER: EPR socket ID.
          \item \REGISTER: Provides the address to the array containing the virtual qubit IDs for the entangled pairs in this request.
                The value of the register should contain the address to an array with as many virtual qubit IDs stored as pair requested.
          \item \REGISTER: Provides the address to the array which holds the rest of the arguments of the entanglement generation to the network stack~\cite{dahlberg2019linklayer,kozlowski2020networklayer}.
                The value of the register should contain the address to an array with as entries as arguments in the entanglement generation request to the network stack~\cite{dahlberg2019linklayer,kozlowski2020networklayer} (except remote node ID and EPR socket ID).
          \item \REGISTER: Provides the address to the array to which information about the entanglement should be written.
                The value of the register should contain the address to an array with as many entries as $n_\mathrm{pairs} \times n_\mathrm{args}$, where $num_\mathrm{args}$ is the number of arguments in the entanglement information provided by the network stack~\cite{dahlberg2019linklayer,kozlowski2020networklayer}.
        \end{enumerate}
  \item \nq{recv_epr}: Receive an EPR pair from a remote node.
        % Operands:
        \begin{enumerate}
          \item \REGISTER: Remote node ID.
          \item \REGISTER: EPR socket ID.
          \item \REGISTER: Provides the address to the array containing the virtual qubit IDs for the entangled pairs in this request.
                The value of the register should contain the address to an array with as many virtual qubit IDs stored as pair requested.
          \item \REGISTER: Provides the address to the array to which information about the entanglement should be written.
                The value of the register should contain the address to an array with as many entries as $n_\mathrm{pairs} \times n_\mathrm{args}$, where $n_\mathrm{args}$ is the number of arguments in the entanglement information provided by the network stack~\cite{dahlberg2019linklayer,kozlowski2020networklayer}.
        \end{enumerate}
\end{itemize}

\subsection{Waiting}
\label{app:waiting}

There are three wait-commands that can wait for entries in arrays to become \emph{defined}, i.e. not \nq{null}.
Entries in a new array is by default \nq{null} (\emph{undefined}).
\begin{itemize}
  \item \nq{wait_all}: Wait for all entries in a given array slice to become not \nq{null}.
        % Operands:
        \begin{enumerate}
          \item \textbf{ARRAY\_SLICE}: Array slice to wait for.
        \end{enumerate}
  \item \nq{wait_any}: Wait for any entry in a given array slice to become not \nq{null}.
        % Operands:
        \begin{enumerate}
          \item \textbf{ARRAY\_SLICE}: Array slice to wait for.
        \end{enumerate}
  \item \nq{wait_single}: Wait for a single entry in an array to become not \nq{null}.
        % Operands:
        \begin{enumerate}
          \item \textbf{ARRAY\_ENTRY}: Array entry to wait for.
        \end{enumerate}
\end{itemize}

\subsection{Deallocation}
\begin{itemize}
  \item \nq{qfree}: Stop using a qubit in the unit module.
        % Operands:
        \begin{enumerate}
          \item \REGISTER: The virtual address of the qubit.
        \end{enumerate}
\end{itemize}


\subsection{Return}

There are two commands for returning data to the application layer.
These commands indicate that the copy of the memory on the application layer side should be updated, see above.
\begin{itemize}
  \item \nq{ret_reg}: Return a register.
        % Operands:
        \begin{enumerate}
          \item \REGISTER: The register to return.
        \end{enumerate}
  \item \nq{ret_arr}: Return an array,
        % Operands:
        \begin{enumerate}
          \item \ADDRESS: The address of the array to return.
        \end{enumerate}
\end{itemize}

\section{Preprocessing}
A subroutine written in text form will first be preprocessed, which does the following:
\begin{itemize}
  \item Parses preprocessing commands and handles these.
        Any preprocessing command starts with \nq{#} and should be before any command in the body of the subroutine.
        Allowed preprocessing commands are:
        \begin{itemize}
          \item \ac{NetQASM} (required): Sets the \ac{NetQASM} version in the metadata.
                % Example:
                \begin{nqcode}
# NETQASM 1.0\end{nqcode}
          \item \nq{APPID} (required): Sets the application ID in the metadata.
                % Example:
                \begin{nqcode}
# APPID 0\end{nqcode}
          \item \nq{DEFINE} (optional): Defines a macro with a key and a value.
                Any occurrence of the key prepended by \nq{\$} will be replaced with the value in the subroutine.
                Values containing spaces should be enclosed with \nq{\{\}}.

                % Example:
                \begin{nqcode}
# DEFINE q 0
# DEFINE add {add @0 @0 @1}\end{nqcode}
                First command replaces any occurrence of \nq{$q} with \nq{0} and second \nq{$add} with \nq{add @0 @0 @1}.
        \end{itemize}
\end{itemize}


\section{Examples}
Here we list some examples of programs written in \ac{NetQASM}.
In \cref{sec:examples_netqasm}, we show some examples written directly in the \ac{NetQASM}-language.
In \cref{app:examples_sdk}, we show the corresponding examples, instead written in the Python SDK.

\subsection{NetQASM}
\label{sec:examples_netqasm}

\subsubsection{Classical logic (if-statement)}
\label{sec:example_nq_if}
A subroutine which creates a qubit, puts in the $|+\rangle$ state, measures it and depending on the outcome performs an X-gates such that by the end of the subroutine the qubit is always in the state $|0\rangle$.
\begin{nqcode}
# NETQASM 1.0
# APPID 0
// Set the virtual qubit ID to use
set Q0 0

// Allocate and initialize a qubit
qalloc Q0
init Q0

// Perform a Hadamard gate
h Q0

// Measure the qubit
meas Q0 M0

// Branch to end if m = 0
bez M0 EXIT

// Perform X gate
x Q0

EXIT:\end{nqcode}

\subsubsection{Classical logic (for-loop)}
\label{sec:example_nq_for}
A subroutine which performs a for-loop which body creates a qubit, puts in the $|+\rangle$ state and measures it. The outcomes are stored in an array.
In a higher-level language (using python syntax) the below subroutine might be written as follows:
\begin{pycode}
ms = [None] * 10

for i in range(10):
  q = Qubit()
  q.H()
  m = q.measure()
  ms[i] = m
\end{pycode}
The equivalent \ac{NetQASM} subroutine is:
\begin{nqcode}
# NETQASM 1.0
# APPID 0
# DEFINE ms @0
# DEFINE i R0
# DEFINE q Q0
# DEFINE m M0
// Create an array with 10 entries (all null)
array 10 $ms

// Initialize loop counter
store $i 0

// Set the virtual qubit ID to use
set $q 0

// Loop entry
LOOP:
beq $i 10 EXIT

// Loop body
qalloc $q
init $q
h $q
meas $q $m
store $m $ms[$i]
qfree $q
add $i $i 1

// Loop exit
jmp LOOP
EXIT:\end{nqcode}

In the above subroutine \nq{DEFINE} statements have been used to clarify what registers/arrays correspond to the variables in the higher-level language example above.

\subsubsection{Create and recv EPR}
\label{sec:example_nq_epr}
This code is for the side initializing the entanglement request.
\begin{nqcode}
# NETQASM 1.0
# APPID 0
# DEFINE qubits @0
# DEFINE args $1
# DEFINE entinfo @2
// Initilizer side

// Setup array with virtual qubit IDs to be used
// for the EPR pairs
array 1 $qubits
store 0 $qubits[0]

// Setup array to store other arguments to entanglement
// generation request
array 20 $args

// Setup array to store entanglement information
array 10 $entinfo

// Create entanglement
// Remote node ID 0 and EPR socket ID 0
// NOTE that these IMMEDIATEs will be replaced by
// REGISTERs when pre-processing.
create_epr 1 0 $qubits $args $entinfo

// Wait for the entanglement to succeed
// i.e. that all entries in the entinfo array becomes
// valid.
wait_all $entinfo[0:10]

// Measure the entanglement qubit
load Q0 $qubits[0]
meas Q0 M0

// Return the outcome
ret_req M0\end{nqcode}

This code is for the receiving side.
\begin{nqcode}
# NETQASM 1.0
# APPID 0
# DEFINE qubits @0
# DEFINE entinfo @1
// Receiver side (very similar to the initializer side)

// Setup array with virtual qubit IDs to be used
// for the EPR pairs
array 1 $qubits
store 0 $qubits[0]

# Setup array to store entanglement information
array 10 $entinfo

// Receive entanglement
// Remote node ID 1 and EPR socket ID 0
// NOTE that these IMMEDIATEs will be replaced by
// REGISTERs when pre-processing.
recv_epr 1 0 $qubits $entinfo

// Wait for the entanglement to succeed
wait_all $entinfo[0:10]

// Measure the entanglement qubit
load Q0 $qubits[0]
meas Q0 M0

// Return the outcome
ret_req M0\end{nqcode}

\subsection{SDK}
\label{app:examples_sdk}
Each of the examples in this section are functionally the same as the examples in \cref{sec:examples_netqasm}.
A compiler will produce a similar subroutine as the examples in the previous section but might vary depending on the exact implementation of the compiler.


\subsubsection{Classical logic (if-statement)}
Functionally the same as the \ac{NetQASM}-subroutine (\cref{sec:example_nq_if}).
\begin{pycode}
# Setup connection to backend
# as the node Alice
with NetQASMConnection("Alice") as alice:
  # Create a qubit
  q = Qubit(alice)
  # Perform a Hadamard on the qubit
  q.H()
  # Measure the qubit
  m = q.measure()
  # Conditionally apply a X-gate
  with m.if_eq(1):
    q.X()
\end{pycode}

\subsubsection{Classical logic (for-loop)}
Functionally the same as the \ac{NetQASM}-subroutine (\cref{sec:example_nq_for}).
\begin{pycode}
# Setup connection to backend
# as the node Alice
with NetQASMConnection("Alice") as alice:
  # Create an array for the outcomes
  outcomes = alice.new_array(10)
  # For-loop
  with alice.loop(10) as i:
    # Create a qubit
    q = Qubit(alice)
    # Perform a Hadamard on the qubit
    q.H()
    # Measure the qubit
    m = q.measure()
    # Add the outcome to the array
    outcomes[i] = m
\end{pycode}

\subsubsection{Create and recv EPR}
Functionally the same as the \ac{NetQASM}-subroutine (\cref{sec:example_nq_epr}).

This code is for the side initializing the entanglement request.
\begin{pycode}
# Setup an EPR socket with the node Bob
epr_socket = EPRSocket("Bob")
# Setup connection to backend
# as the node Alice
with NetSquidConnection(
"Alice",
epr_sockets=[epr_socket],
):
  # Create entanglement
  epr = epr_socket.create()[0]
  # Measure the entangled qubit
  m = epr.measure()
\end{pycode}

This code is for the receiving side.
\begin{pycode}
# Setup an EPR socket with the node Alice
epr_socket = EPRSocket("Bob")
# Setup connection to backend
# as the node Bob
with NetSquidConnection(
"Alice",
epr_sockets=[epr_socket]
):
  # Create entanglement
  epr = epr_socket.recv()[0]
  # Measure the entangled qubit
  m = epr.measure()
\end{pycode}

\section{Simulation details}
\label{app:simulation}

In this section we detail how simulations in \cref{sec:evaluation} were
performed and what models and parameters were used. All simulations used the
\ac{NetQASM} SDK~\cite{git_netqasm}, using
NetSquid~\cite{netsquid,coopmans2021netsquid} as the underlying simulator. All
code used in these simulations can also be found at~\cite{git_squidasm}.


\subsection{Noise model}
In both the teleportation and the blind quantum computing scenario we used the
same model for nitrogen-vacancy centres in diamonds as was used
in~\cite{dahlberg2019linklayer} and~\cite{coopmans2021netsquid}. All gates
specified by the application in the SDK were translated to NV-specific gates,
see \cref{tab:gates}, using a simple compiler without any optimization. The
parameters used in the model from~\cite{dahlberg2019linklayer} are listed in
\cref{tab:gates,tab:noise}, together with an explanation and a reference.
\nq{ec_controlled_dir_xy} are the native two-qubit gates of the NV-platform,
ideally performing one of the unitary operations
\begin{align}
  U_\mathrm{ec_x}(\alpha) & = \begin{pmatrix}R_x(\alpha) & 0 \\ 0 & R_x(-\alpha) \end{pmatrix} \label{eq:crot_x} \\
  U_\mathrm{ec_y}(\alpha) & = \begin{pmatrix}R_y(\alpha) & 0 \\ 0 & R_y(-\alpha) \end{pmatrix} \label{eq:crot_y} \\
\end{align}
where $R_x(\alpha)$ and $R_y(\alpha)$ are the rotation matrices around $X$ and
$Y$, respectively. When sweeping the duration and noise of this two-qubit gate
the same value is also used for the \nq{carbon_xy_rot} ($X$- and $Y$-rotations
on the carbon) on the storage qubits, since these are also effectively done with
a similar operation also involving the communication qubit (electron). All noise
indicated by a fidelity in \cref{tab:noise} are applied as depolarising noise by
applying the perfect operation, producing the state $\rho_\mathrm{ideal}$, and
mapping this to
\begin{equation}\label{eq:depolarising}
  \rho_\mathrm{noisy}=(1-p)\rho_\mathrm{ideal} + \frac{p}{3}X\rho_\mathrm{ideal}X + \frac{p}{3}Y\rho_\mathrm{ideal}Y + \frac{p}{3}Z\rho_\mathrm{ideal}Z
\end{equation}
where $X$, $Y$ and $Z$ are the Pauli operators in
\cref{eq:pauli_x,eq:pauli_y,eq:pauli_z}, $p=\frac{4}{3}(1 - F)$, with $F$ being
the value specific in \cref{tab:noise}. Decoherence noise is specific as $T_1$
(energy/thermal relaxation time) and $T_2$ (dephasing time)~\cite{Nielsen2010}.

\begin{table}
  \centering
  \begin{tabular}{|c|c|c|}
    \hline
    Gate                      & Durations (ns) & Explanation                                                \\
    \hline\hline
    \texttt{electron\_init}        & 2e3            & Initialize a communication qubit (electron) to $|0\rangle$ \\
    \texttt{electron\_rot}         & 5              & single-qubit rotation on communication qubit (electron)    \\
    \texttt{measure}              & 3.7e3          & Measure communication qubit (electron)                     \\
    \texttt{carbon\_init}          & 3.1e5          & Initialize a storage qubit (carbon) to $|0\rangle$         \\
    \texttt{carbon\_xy\_rot}        & $t$            & $X$/$Y$-rotation on storage qubit (carbon)                 \\
    \texttt{carbon\_z\_rot}         & 5              & $Z$-rotation on storage qubit (carbon)                     \\
    \texttt{ec\_controlled\_dir\_xy} & $t$            & Native two-qubit gates, see \cref{eq:crot_x,eq:crot_y}     \\
    \hline
  \end{tabular}
  \caption{
    Gate durations for scenario \textbf{B} of \cref{sec:evaluation}.
    $t$ is the value being swept in \cref{fig:sweep_gate_time}.
    All values are from~\cite{dahlberg2019linklayer}.}
  \label{tab:gates}
\end{table}

\begin{table}
  \centering
  \begin{tabular}{||c|c|c|c||}
    \hline
    Parameter                 & Value        & Explanation                                                 \\
    \hline\hline
    \texttt{electron\_T1}          & 1 hour       & $T_1$ of communication qubit (electron)                     \\
    \texttt{electron\_T2}          & 1.46 seconds & $T_2$ of communication qubit (electron)                     \\
    \texttt{electron\_init}        & 0.99)        & Fidelity to initialize communication qubit (electron)       \\
    \texttt{electron\_rot}         & 1.0          & Fidelity for $Z$-rotation on communication qubit (electron) \\
    \texttt{carbon\_T1}            & 10 hours     & $T_1$ of storage qubit (carbon)                             \\
    \texttt{carbon\_T2}            & 1 second     & $T_2$ of storage qubit (carbon)                             \\
    \texttt{carbon\_init}          & 0.997        & Fidelity to initialize storage qubit (carbon)               \\
    \texttt{carbon\_z\_rot}         & 0.999        & Fidelity for $Z$-rotation on storage qubit (carbon)         \\
    \texttt{carbon\_xy\_rot}        & $f$          & Fidelity for $X$/$Y$-rotation on storage qubit (carbon)     \\
    \texttt{ec\_controlled\_dir\_xy} & $f$          & Fidelity for native two-qubit gate                          \\
    \texttt{prob\_error\_meas\_0}    & 0.05         & Probability of flipped measurement outcome for $|0\rangle$  \\
    \texttt{prob\_error\_meas\_1}    & 0.005        & Probability of flipped measurement outcome for $|1\rangle$  \\
    \texttt{link\_fidelity}        & 0.9          & Fidelity of generated entangled pair.                       \\
    \hline
  \end{tabular}
  \caption{
    Noise parameters for used in the simulations of \cref{sec:evaluation}.
    $f$ is the value being swept in \cref{fig:sweep_gate_noise} and \cref{fig:plot_bqc}.
    All fidelities are realized by a applying depolarising noise as in \cref{eq:depolarising}.
    All values are from~\cite{coopmans2021netsquid}, except \nq{link_fidelity} which is set to relatively high value to avoid this being the major noise-contribution and preventing any conclusions to be made.
  }
  \label{tab:noise}
\end{table}

\subsection{BQC application and flavors}
In \cref{sec:evaluation-flavours} we simulated the blind quantum computation
(BQC) application from \cref{fig:bqc_app}. The code for this is available at
\cite{git_squidasm}.

In the scenario when the application code was compiled to subroutines with the
vanilla lavour, the \ac{QNPU} had to map the vanilla instructions to NV-native
operations on the fly. We used the gate mappings listed below. For
convenience we use \nq{PI} and \nq{PI_OVER_2} for $\pi$ and $\frac{\pi}{2}$
respectively.

A \nq{h} (Hadamard) vanilla instruction was mapped to the following NV instruction sequence:
\begin{nqcode}
  rot_y PI_OVER_2
  rot_x PI\end{nqcode}

A \nq{cnot C S} vanilla instruction between a communication qubit (C) and a storage
qubit (S) (as specified in the unit module) was mapped to the following NV
instruction sequence:
\begin{nqcode}
  cx_dir C S PI_OVER_2
  rot_z C -PI_OVER_2
  rot_x S -PI_OVER_2\end{nqcode}

A \nq{cnot S C} vanilla instruction between a store qubit (S) and a communication
qubit (C) (as specified in the unit module) was mapped to the following NV
instruction sequence:
\begin{nqcode}
  rot_y C PI_OVER_2
  rot_x C PI
  rot_y S PI_OVER_2
  cx_dir C S PI_OVER_2
  rot_z C -PI_OVER_2
  rot_x S -PI_OVER_2
  rot_y S PI_OVER_2
  rot_y C PI_OVER_2
  rot_x C PI\end{nqcode}

A \nq{cphase C S} vanilla instruction between a communication qubit (C) and a storage
qubit (S) (as specified in the unit module) was mapped to the following NV
instruction sequence:
\begin{nqcode}
  rot_y S PI_OVER_2
  cx_dir C S PI_OVER_2
  rot_z C -PI_OVER_2
  rot_x S -PI_OVER_2
  rot_y S -PI_OVER_2\end{nqcode}

