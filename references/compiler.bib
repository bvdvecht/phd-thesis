@article{ferrari_compiler_2021,
	title = {Compiler Design for Distributed Quantum Computing},
	volume = {2},
	issn = {2689-1808},
	url = {https://ieeexplore.ieee.org/abstract/document/9334411},
	doi = {10.1109/TQE.2021.3053921},
	abstract = {In distributed quantum computing architectures, with the network and communications functionalities provided by the Quantum Internet, remote quantum processing units can communicate and cooperate for executing computational tasks that single, noisy, intermediate-scale quantum devices cannot handle by themselves. To this aim, distributed quantum computing requires a new generation of quantum compilers, for mapping any quantum algorithm to any distributed quantum computing architecture. With this perspective, in this article, we first discuss the main challenges arising with compiler design for distributed quantum computing. Then, we analytically derive an upper bound of the overhead induced by quantum compilation for distributed quantum computing. The derived bound accounts for the overhead induced by the underlying computing architecture as well as the additional overhead induced by the suboptimal quantum compiler—expressly designed in this article to achieve three key features, namely, general-purpose, efficient, and effective. Finally, we validate the analytical results, and we confirm the validity of the compiler design through an extensive performance analysis.},
	pages = {1--20},
	journaltitle = {{IEEE} Transactions on Quantum Engineering},
	author = {Ferrari, Davide and Cacciapuoti, Angela Sara and Amoretti, Michele and Caleffi, Marcello},
	urldate = {2024-08-08},
	date = {2021},
	note = {Conference Name: {IEEE} Transactions on Quantum Engineering},
	keywords = {Computer architecture, Distributed quantum computing, distributed quantum systems, Integrated circuit modeling, Logic gates, Quantum circuit, quantum compiling, Quantum computing, quantum Internet, quantum networks, Qubit, Task analysis},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\bvvandervecht\\Zotero\\storage\\5DFYF4SI\\9334411.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\ULARMCDC\\Ferrari et al. - 2021 - Compiler Design for Distributed Quantum Computing.pdf:application/pdf},
}

@article{litteken_updated_2020,
	title = {An updated {LLVM}-based quantum research compiler with further {OpenQASM} support},
	volume = {5},
	issn = {2058-9565},
	url = {https://dx.doi.org/10.1088/2058-9565/ab8c2c},
	doi = {10.1088/2058-9565/ab8c2c},
	abstract = {Quantum computing is a rapidly growing field with the potential to change how we solve previously intractable problems. Emerging hardware is approaching a complexity that requires increasingly sophisticated programming and control. Scaffold is an older quantum programming language that was originally designed for resource estimation for far-future, large quantum machines, and {ScaffCC} is the corresponding {LLVM}-based compiler. For the first time, we provide a full and complete overview of the language itself, the compiler as well as its pass structure. While previous works Abhari et al (2015 Parallel Comput. 45 2–17), Abhari et al (2012 Scaffold: quantum programming language https://cs.princeton.edu/research/techreps/{TR}-934-12), have piecemeal descriptions of different portions of this toolchain, we provide a more full and complete description in this paper. We also introduce updates to {ScaffCC} including conditional measurement and multidimensional qubit arrays designed to keep in step with modern quantum assembly languages, as well as an alternate toolchain targeted at maintaining correctness and low resource count for noisy-intermediate scale quantum ({NISQ}) machines, and compatibility with current versions of {LLVM} and Clang. Our goal is to provide the research community with a functional {LLVM} framework for quantum program analysis, optimization, and generation of executable code.},
	pages = {034013},
	number = {3},
	journaltitle = {Quantum Science and Technology},
	shortjournal = {Quantum Sci. Technol.},
	author = {Litteken, Andrew and Fan, Yung-Ching and Singh, Devina and Martonosi, Margaret and Chong, Frederic T.},
	urldate = {2024-08-08},
	date = {2020-05},
	langid = {english},
	note = {Publisher: {IOP} Publishing},
	file = {IOP Full Text PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\83NE9G7S\\Litteken et al. - 2020 - An updated LLVM-based quantum research compiler wi.pdf:application/pdf},
}

@inproceedings{mccaskey_mlir_2021,
	title = {A {MLIR} Dialect for Quantum Assembly Languages},
	url = {https://ieeexplore.ieee.org/abstract/document/9605269},
	doi = {10.1109/QCE52317.2021.00043},
	abstract = {We demonstrate the utility of the Multi-Level Intermediate Representation ({MLIR}) for quantum computing. Specifically, we extend {MLIR} with a new quantum dialect that enables the expression and compilation of common quantum assembly languages. The true utility of this dialect is in its ability to be lowered to the {LLVM} intermediate representation ({IR}) in a manner that is adherent to the quantum intermediate representation ({QIR}) specification recently proposed by Microsoft. We leverage a qcor-enabled implementation of the {QIR} quantum runtime {API} to enable a retargetable (quantum hardware agnostic) compiler workflow mapping quantum languages to hybrid quantum-classical binary executables and object code. We evaluate and demonstrate this novel compiler workflow with quantum programs written in {OpenQASM} 2.0. We provide concrete examples detailing the generation of {MLIR} from {OpenQASM} source files, the lowering process from {MLIR} to {LLVM} {IR}, and ultimately the generation of executable binaries targeting available quantum processors.},
	eventtitle = {2021 {IEEE} International Conference on Quantum Computing and Engineering ({QCE})},
	pages = {255--264},
	booktitle = {2021 {IEEE} International Conference on Quantum Computing and Engineering ({QCE})},
	author = {{McCaskey}, Alexander and Nguyen, Thien},
	urldate = {2024-08-08},
	date = {2021-10},
	keywords = {Quantum computing, Qubit, Codes, Memory management, Program processors, programming languages, quantum computing, quantum programming, quantum simulation, Runtime, Runtime library},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\bvvandervecht\\Zotero\\storage\\7KE4XILY\\9605269.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\L4FKGZL9\\McCaskey and Nguyen - 2021 - A MLIR Dialect for Quantum Assembly Languages.pdf:application/pdf},
}

@inproceedings{nigam_compiler_2021,
	location = {New York, {NY}, {USA}},
	title = {A compiler infrastructure for accelerator generators},
	isbn = {978-1-4503-8317-2},
	url = {https://dl.acm.org/doi/10.1145/3445814.3446712},
	doi = {10.1145/3445814.3446712},
	series = {{ASPLOS} '21},
	abstract = {We present Calyx, a new intermediate language ({IL}) for compiling high-level programs into hardware designs. Calyx combines a hardware-like structural language with a software-like control flow representation with loops and conditionals. This split representation enables a new class of hardware-focused optimizations that require both structural and control flow information which are crucial for high-level programming models for hardware design. The Calyx compiler lowers control flow constructs using finite-state machines and generates synthesizable hardware descriptions. We have implemented Calyx in an optimizing compiler that translates high-level programs to hardware. We demonstrate Calyx using two {DSL}-to-{RTL} compilers, a systolic array generator and one for a recent imperative accelerator language, and compare them to equivalent designs generated using high-level synthesis ({HLS}). The systolic arrays are 4.6× faster and 1.11× larger on average than {HLS} implementations, and the {HLS}-like imperative language compiler is within a few factors of a highly optimized commercial {HLS} toolchain. We also describe three optimizations implemented in the Calyx compiler.},
	pages = {804--817},
	booktitle = {Proceedings of the 26th {ACM} International Conference on Architectural Support for Programming Languages and Operating Systems},
	publisher = {Association for Computing Machinery},
	author = {Nigam, Rachit and Thomas, Samuel and Li, Zhijing and Sampson, Adrian},
	urldate = {2024-08-08},
	date = {2021-04-17},
	file = {Full Text PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\9HC5Q3ET\\Nigam et al. - 2021 - A compiler infrastructure for accelerator generato.pdf:application/pdf},
}

@misc{nishio_inquir_2023,
	title = {{InQuIR}: Intermediate Representation for Interconnected Quantum Computers},
	url = {http://arxiv.org/abs/2302.00267},
	doi = {10.48550/arXiv.2302.00267},
	shorttitle = {{InQuIR}},
	abstract = {Various physical constraints limit the number of qubits that can be implemented in a single quantum processor, and thus it is necessary to connect multiple quantum processors via quantum interconnects. While several compiler implementations for interconnected quantum computers have been proposed, there is no suitable representation as their compilation target. The lack of such representation impairs the reusability of compiled programs and makes it difficult to reason formally about the complicated behavior of distributed quantum programs. We propose {InQuIR}, an intermediate representation that can express communication and computation on distributed quantum systems. {InQuIR} has formal semantics that allows us to describe precisely the behaviors of distributed quantum programs. We give examples written in {InQuIR} to illustrate the problems arising in distributed programs, such as deadlock. We present a roadmap for static verification using type systems to deal with such a problem. We also provide software tools for {InQuIR} and evaluate the computational costs of quantum circuits under various conditions. Our tools are available at https://github.com/team-{InQuIR}/{InQuIR}.},
	number = {{arXiv}:2302.00267},
	publisher = {{arXiv}},
	author = {Nishio, Shin and Wakizaka, Ryo},
	urldate = {2024-08-08},
	date = {2023-02-01},
	eprinttype = {arxiv},
	eprint = {2302.00267 [quant-ph]},
	keywords = {Computer Science - Programming Languages, Quantum Physics},
	file = {arXiv Fulltext PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\3NIMVKG2\\Nishio and Wakizaka - 2023 - InQuIR Intermediate Representation for Interconne.pdf:application/pdf;arXiv.org Snapshot:C\:\\Users\\bvvandervecht\\Zotero\\storage\\6Q9CQF9S\\2302.html:text/html},
}

@inproceedings{murali_full-stack_2019,
	location = {New York, {NY}, {USA}},
	title = {Full-stack, real-system quantum computer studies: architectural comparisons and design insights},
	isbn = {978-1-4503-6669-4},
	url = {https://dl.acm.org/doi/10.1145/3307650.3322273},
	doi = {10.1145/3307650.3322273},
	series = {{ISCA} '19},
	shorttitle = {Full-stack, real-system quantum computer studies},
	abstract = {In recent years, Quantum Computing ({QC}) has progressed to the point where small working prototypes are available for use. Termed Noisy Intermediate-Scale Quantum ({NISQ}) computers, these prototypes are too small for large benchmarks or even for Quantum Error Correction ({QEC}), but they do have sufficient resources to run small benchmarks, particularly if compiled with optimizations to make use of scarce qubits and limited operation counts and coherence times. {QC} has not yet, however, settled on a particular preferred device implementation technology, and indeed different {NISQ} prototypes implement qubits with very different physical approaches and therefore widely-varying device and machine characteristics.Our work performs a full-stack, benchmark-driven hardware-software analysis of {QC} systems. We evaluate {QC} architectural possibilities, software-visible gates, and software optimizations to tackle fundamental design questions about gate set choices, communication topology, the factors affecting benchmark performance and compiler optimizations. In order to answer key cross-technology and cross-platform design questions, our work has built the first top-to-bottom toolflow to target different qubit device technologies, including superconducting and trapped ion qubits which are the current {QC} front-runners. We use our toolflow, {TriQ}, to conduct real-system measurements on seven running {QC} prototypes from three different groups, {IBM}, Rigetti, and University of Maryland. Overall, we demonstrate that leveraging microarchitecture details in the compiler improves program success rate up to 28x on {IBM} (geomean 3x), 2.3x on Rigetti (geomean 1.45x), and 1.47x on {UMDTI} (geomean 1.17x), compared to vendor toolflows. In addition, from these real-system experiences at {QC}'s hardware-software interface, we make observations and recommendations about native and software-visible gates for different {QC} technologies, as well as communication topologies, and the value of noise-aware compilation even on lower-noise platforms. This is the largest cross-platform real-system {QC} study performed thus far; its results have the potential to inform both {QC} device and compiler design going forward.},
	pages = {527--540},
	booktitle = {Proceedings of the 46th International Symposium on Computer Architecture},
	publisher = {Association for Computing Machinery},
	author = {Murali, Prakash and Linke, Norbert Matthias and Martonosi, Margaret and Abhari, Ali Javadi and Nguyen, Nhung Hong and Alderete, Cinthia Huerta},
	urldate = {2024-08-08},
	date = {2019-06-22},
	file = {Full Text PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\QZXHJ5K9\\Murali et al. - 2019 - Full-stack, real-system quantum computer studies .pdf:application/pdf},
}

@inproceedings{bandic_full-stack_2022,
	title = {Full-stack quantum computing systems in the {NISQ} era: algorithm-driven and hardware-aware compilation techniques},
	url = {https://ieeexplore.ieee.org/abstract/document/9774643},
	doi = {10.23919/DATE54114.2022.9774643},
	shorttitle = {Full-stack quantum computing systems in the {NISQ} era},
	abstract = {The progress in developing quantum hardware with functional quantum processors integrating tens of noisy qubits, together with the availability of near-term quantum algorithms has led to the release of the first quantum computers. These quantum computing systems already integrate different software and hardware components of the so-called “full-stack”, bridging quantum applications to quantum devices. In this paper, we will provide an overview on current full-stack quantum computing systems. We will emphasize the need for tight co-design among adjacent layers as well as vertical cross-layer design to extract the most from noisy intermediate-scale quantum ({NISQ}) processors which are both error-prone and severely constrained in resources. As an example of co-design, we will focus on the development of hardware-aware and algorithm-driven compilation techniques.},
	eventtitle = {2022 Design, Automation \& Test in Europe Conference \& Exhibition ({DATE})},
	pages = {1--6},
	booktitle = {2022 Design, Automation \& Test in Europe Conference \& Exhibition ({DATE})},
	author = {Bandic, Medina and Feld, Sebastian and Almudever, Carmen G.},
	urldate = {2024-08-08},
	date = {2022-03},
	note = {{ISSN}: 1558-1101},
	keywords = {Quantum computing, Qubit, Program processors, Computers, Hardware, Quantum algorithm, Software algorithms},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\bvvandervecht\\Zotero\\storage\\5LGUNJPI\\9774643.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\8BCMIZHH\\Bandic et al. - 2022 - Full-stack quantum computing systems in the NISQ e.pdf:application/pdf},
}

@misc{nane_sdc-based_2022,
	title = {{SDC}-based Resource Constrained Scheduling for Quantum Control Architectures},
	url = {http://arxiv.org/abs/2210.00794},
	doi = {10.48550/arXiv.2210.00794},
	abstract = {Instruction scheduling is a key transformation in backend compilers that take an untimed description of an algorithm and assigns time slots to the algorithm's instructions so that they can be executed as efficiently as possible while taking into account the target processor limitations, such as the amount of computational units available. For example, for a superconducting quantum processor these restrictions include the amount of analogue instruments available to play the waveforms to drive the qubit rotations or on-chip connectivity between qubits. Current small-scale quantum processors contain only a few qubits; therefore, it is feasible to drive qubits individually albeit not scalable. Consequently, for {NISQ} and beyond {NISQ} devices, it is expected that classical instrument sharing to be designed in the future quantum control architectures where several qubits are connected to an instrument and multiplexing is used to activate only the qubits performing the same quantum operation at a time. Existing quantum scheduling algorithms either rely on {ILP} formulations, which do not scale well, or use heuristic based algorithms such as list scheduling which are not versatile enough to deal with quantum requirements such as scheduling with exact relative timing constraints between instructions, situation that might occur when decomposing complex instructions into native ones and requiring to keep a fixed timing between the primitive ones to guarantee correctness. In this paper, we propose a novel resource constrained scheduling algorithm that is based on the {SDC} formulation, which is the state-of-the-art algorithm used in the reconfigurable computing. We evaluate it against a list scheduler and describe the benefits of the proposed approach. We find that the {SDC}-based scheduling is not only able to find better schedules but also model flexible relative timing constraints.},
	number = {{arXiv}:2210.00794},
	publisher = {{arXiv}},
	author = {Nane, Razvan},
	urldate = {2024-08-08},
	date = {2022-10-03},
	eprinttype = {arxiv},
	eprint = {2210.00794 [quant-ph]},
	keywords = {Quantum Physics, Computer Science - Hardware Architecture},
	file = {arXiv Fulltext PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\WFAI8442\\Nane - 2022 - SDC-based Resource Constrained Scheduling for Quan.pdf:application/pdf;arXiv.org Snapshot:C\:\\Users\\bvvandervecht\\Zotero\\storage\\V92LTBVE\\2210.html:text/html},
}

@misc{khalate_llvm-based_2022,
	title = {An {LLVM}-based C++ Compiler Toolchain for Variational Hybrid Quantum-Classical Algorithms and Quantum Accelerators},
	url = {http://arxiv.org/abs/2202.11142},
	doi = {10.48550/arXiv.2202.11142},
	abstract = {Variational algorithms are a representative class of quantum computing workloads that combine quantum and classical computing. This paper presents an {LLVM}-based C++ compiler toolchain to efficiently execute variational hybrid quantum-classical algorithms on a computational system in which the quantum device acts as an accelerator. We introduce a set of extensions to the C++ language for programming these algorithms. We define a novel Executable and Linking Format ({ELF}) for Quantum and create a quantum device compiler component in the {LLVM} framework to compile the quantum part of the C++ source and reuse the host compiler in the {LLVM} framework to compile the classical computing part of the C++ source. A variational algorithm runs a quantum circuit repeatedly, each time with different gate parameters. We add to the quantum runtime the capability to execute dynamically a quantum circuit with different parameters. Thus, programmers can call quantum routines the same way as classical routines. With these capabilities, a variational hybrid quantum-classical algorithm can be specified in a single-source code and only needs to be compiled once for all iterations. The single compilation significantly reduces the execution latency of variational algorithms. We evaluate the framework's performance by running quantum circuits that prepare Thermofield Double ({TFD}) states, a quantum-classical variational algorithm.},
	number = {{arXiv}:2202.11142},
	publisher = {{arXiv}},
	author = {Khalate, Pradnya and Wu, Xin-Chuan and Premaratne, Shavindra and Hogaboam, Justin and Holmes, Adam and Schmitz, Albert and Guerreschi, Gian Giacomo and Zou, Xiang and Matsuura, A. Y.},
	urldate = {2024-08-08},
	date = {2022-02-22},
	eprinttype = {arxiv},
	eprint = {2202.11142 [quant-ph]},
	keywords = {Quantum Physics, Computer Science - Mathematical Software},
	file = {arXiv Fulltext PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\ZZY9S6DF\\Khalate et al. - 2022 - An LLVM-based C++ Compiler Toolchain for Variation.pdf:application/pdf;arXiv.org Snapshot:C\:\\Users\\bvvandervecht\\Zotero\\storage\\TIHFIXG4\\2202.html:text/html},
}

@article{kreppel_quantum_2023,
	title = {Quantum Circuit Compiler for a Shuttling-Based Trapped-Ion Quantum Computer},
	volume = {7},
	url = {https://quantum-journal.org/papers/q-2023-11-08-1176/},
	doi = {10.22331/q-2023-11-08-1176},
	abstract = {Fabian Kreppel, Christian Melzer, Diego Olvera Millán, Janis Wagner, Janine Hilder, Ulrich Poschinger, Ferdinand Schmidt-Kaler, and André Brinkmann,
Quantum 7, 1176 (2023).
The increasing capabilities of quantum computing hardware and the challenge of realizing deep quantum circuits require fully automated and efficient tools for compiling quantum circuits. To…},
	pages = {1176},
	journaltitle = {Quantum},
	author = {Kreppel, Fabian and Melzer, Christian and Millán, Diego Olvera and Wagner, Janis and Hilder, Janine and Poschinger, Ulrich and Schmidt-Kaler, Ferdinand and Brinkmann, André},
	urldate = {2024-08-08},
	date = {2023-11-08},
	langid = {british},
	note = {Publisher: Verein zur Förderung des Open Access Publizierens in den Quantenwissenschaften},
	file = {Full Text PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\WCXX8MJX\\Kreppel et al. - 2023 - Quantum Circuit Compiler for a Shuttling-Based Tra.pdf:application/pdf},
}

@inproceedings{younis_quantum_2022,
	title = {Quantum Circuit Optimization and Transpilation via Parameterized Circuit Instantiation},
	url = {https://ieeexplore.ieee.org/abstract/document/9951320},
	doi = {10.1109/QCE53715.2022.00068},
	abstract = {Parameterized circuit instantiation is a common technique encountered in the generation of circuits for a large class of hybrid quantum-classical algorithms. Despite being supported by popular quantum compilation infrastructures such as {IBM} Qiskit and Google Cirq, instantiation has not been extensively considered in the context of circuit compilation and optimization pipelines. In this work, we describe algorithms to apply instantiation during two common compilation steps: circuit optimization and gate-set transpilation. When placed in a compilation workflow, our circuit optimization algorithm produces circuits with an average of 13\% fewer gates than other optimizing compilers. Our gate-set transpilation algorithm can target any gate-set, even sets with multiple two-qubit gates, and produces circuits with an average of 12\% fewer two-qubit gates than other compilers. Overall, we show how instantiation can be incorporated into a compiler workflow to improve circuit quality and enhance portability, all while maintaining a reasonably low compile time overhead.},
	eventtitle = {2022 {IEEE} International Conference on Quantum Computing and Engineering ({QCE})},
	pages = {465--475},
	booktitle = {2022 {IEEE} International Conference on Quantum Computing and Engineering ({QCE})},
	author = {Younis, Ed and Iancu, Costin},
	urldate = {2024-08-08},
	date = {2022-09},
	keywords = {Logic gates, Runtime, Hardware, circuit instantiation, circuit optimization, Circuit optimization, gatesets, Hybrid power systems, Optimizing compilers, Pipelines, synthesis, transpilation},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\bvvandervecht\\Zotero\\storage\\4NIJBU2Z\\9951320.html:text/html;Submitted Version:C\:\\Users\\bvvandervecht\\Zotero\\storage\\CMPH3L6L\\Younis and Iancu - 2022 - Quantum Circuit Optimization and Transpilation via.pdf:application/pdf},
}

@misc{singhal_quantum_2021,
	title = {Quantum Hoare Type Theory},
	url = {http://arxiv.org/abs/2012.02154},
	doi = {10.48550/arXiv.2012.02154},
	abstract = {As quantum computers become real, it is high time we come up with effective techniques that help programmers write correct quantum programs. Inspired by Hoare Type Theory in classical computing, we propose Quantum Hoare Type Theory ({QHTT}), in which precise specifications about the modification to the quantum state can be provided within the type of computation. These specifications within a Hoare type are given in the form of Hoare-logic style pre- and postconditions following the propositions-as-types principle. The type-checking process verifies that the implementation conforms to the provided specification. {QHTT} has the potential to be a unified system for programming, specifying, and reasoning about quantum programs.},
	number = {{arXiv}:2012.02154},
	publisher = {{arXiv}},
	author = {Singhal, Kartik},
	urldate = {2024-08-08},
	date = {2021-11-15},
	eprinttype = {arxiv},
	eprint = {2012.02154 [quant-ph]},
	keywords = {Computer Science - Programming Languages, Quantum Physics, Computer Science - Emerging Technologies, Computer Science - Logic in Computer Science, D.1.1, D.2.4, D.3.1, F.3.1, F.4.1},
	file = {arXiv Fulltext PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\JVU5ZKTV\\Singhal - 2021 - Quantum Hoare Type Theory.pdf:application/pdf;arXiv.org Snapshot:C\:\\Users\\bvvandervecht\\Zotero\\storage\\Q89H9857\\2012.html:text/html},
}

@misc{hua_synergistic_2023,
	title = {A Synergistic Compilation Workflow for Tackling Crosstalk in Quantum Machines},
	url = {http://arxiv.org/abs/2207.05751},
	doi = {10.48550/arXiv.2207.05751},
	abstract = {Near-term quantum systems tend to be noisy. Crosstalk noise has been recognized as one of several major types of noises in superconducting Noisy Intermediate-Scale Quantum ({NISQ}) devices. Crosstalk arises from the concurrent execution of two-qubit gates on nearby qubits, such as {\textbackslash}texttt\{{CX}\}. It might significantly raise the error rate of gates in comparison to running them individually. Crosstalk can be mitigated through scheduling or hardware machine tuning. Prior scientific studies, however, manage crosstalk at a really late phase in the compilation process, usually after hardware mapping is done. It may miss great opportunities of optimizing algorithm logic, routing, and crosstalk at the same time. In this paper, we push the envelope by considering all these factors simultaneously at the very early compilation stage. We propose a crosstalk-aware quantum program compilation framework called {CQC} that can enhance crosstalk mitigation while achieving satisfactory circuit depth. Moreover, we identify opportunities for translation from intermediate representation to the circuit for application-specific crosstalk mitigation, for instance, the {\textbackslash}texttt\{{CX}\} ladder construction in variational quantum eigensolvers ({VQE}). Evaluations through simulation and on real {IBM}-Q devices show that our framework can significantly reduce the error rate by up to 6\${\textbackslash}times\$, with only \${\textbackslash}sim\$60{\textbackslash}\% circuit depth compared to state-of-the-art gate scheduling approaches. In particular, for {VQE}, we demonstrate 49{\textbackslash}\% circuit depth reduction with 9.6{\textbackslash}\% fidelity improvement over prior art on the H4 molecule using {IBMQ} Guadalupe. Our {CQC} framework will be released on {GitHub}.},
	number = {{arXiv}:2207.05751},
	publisher = {{arXiv}},
	author = {Hua, Fei and Jin, Yuwei and Li, Ang and Liu, Chenxu and Wang, Meng and Chen, Yanhao and Zhang, Chi and Hayes, Ari and Stein, Samuel and Guo, Minghao and Huang, Yipeng and Zhang, Eddy Z.},
	urldate = {2024-08-08},
	date = {2023-12-08},
	eprinttype = {arxiv},
	eprint = {2207.05751 [quant-ph]},
	keywords = {Quantum Physics, Computer Science - Computation and Language},
	file = {arXiv Fulltext PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\Y3E5ZBLK\\Hua et al. - 2023 - A Synergistic Compilation Workflow for Tackling Cr.pdf:application/pdf;arXiv.org Snapshot:C\:\\Users\\bvvandervecht\\Zotero\\storage\\6TLGEGAB\\2207.html:text/html},
}

@misc{kharkov_arline_2022,
	title = {Arline Benchmarks: Automated Benchmarking Platform for Quantum Compilers},
	url = {http://arxiv.org/abs/2202.14025},
	doi = {10.48550/arXiv.2202.14025},
	shorttitle = {Arline Benchmarks},
	abstract = {Efficient compilation of quantum algorithms is vital in the era of Noisy Intermediate-Scale Quantum ({NISQ}) devices. While multiple open-source quantum compilation and circuit optimization frameworks are available, e.g. {IBM} Qiskit, {CQC} Tket, Google Cirq, Rigetti Quilc, {PyZX}, their relative performance is not always clear to a quantum programmer. The growth of complexity and diversity of quantum circuit compilation algorithms creates a demand for a dedicated tool for cross-benchmarking and profiling of inner workflow of the quantum compilation stack. We present an open-source software package, Arline Benchmarks, that is designed to perform automated benchmarking of quantum compilers with the focus on {NISQ} applications. The name "Arline" was given in honour of Arline Greenbaum Feynman, the first wife of Richard Feynman, the pioneer of quantum computing. We compared several quantum compilation frameworks based on a set of important metrics such as post-optimization gate counts, circuit depth, hardware-dependent circuit cost function, compiler run time etc. with a detailed analysis of metrics for each compilation stage. We performed a variety of compiler tests for random circuits and structured quantum algorithms ({VQE}, Trotter decomposition, Grover search, Option Pricing via Amplitude Estimation) for several popular quantum hardware architectures. Leveraging cross-platform functionality of Arline, we propose a concept of composite compilation pipeline that combines compiler-specific circuit optimization subroutines in a single compilation stack and finds an optimized sequence of compilation passes. By providing detailed insights into the compilation flow of quantum compilers, Arline Benchmarks offers a valuable toolkit for quantum computing researchers and software developers to gain additional insights into compilers' characteristics.},
	number = {{arXiv}:2202.14025},
	publisher = {{arXiv}},
	author = {Kharkov, Y. and Ivanova, A. and Mikhantiev, E. and Kotelnikov, A.},
	urldate = {2024-08-08},
	date = {2022-02-28},
	eprinttype = {arxiv},
	eprint = {2202.14025 [quant-ph]},
	keywords = {Quantum Physics, Computer Science - Software Engineering},
	file = {arXiv.org Snapshot:C\:\\Users\\bvvandervecht\\Zotero\\storage\\ITFH2S3C\\2202.html:text/html},
}

@inproceedings{evans_mcbeth_2023,
	title = {{MCBeth}: A Measurement-based Quantum Programming Language},
	url = {https://ieeexplore.ieee.org/abstract/document/10189152},
	doi = {10.1109/Q-SE59154.2023.00007},
	shorttitle = {{MCBeth}},
	abstract = {This work introduces {MCBeth}, a quantum programming language that bridges the gap between near-term and non-near-term languages. {MCBeth} allows users to directly program and simulate measurement-based computation by building upon the measurement calculus. While {MCBeth} programs are meant to be executed directly on hardware, to take advantage of current machines we also provide a compiler to gate-based instruction sets. We argue that {MCBeth} is more natural to use than common low-level languages, which are based upon the quantum circuit model, but still easily runnable in practice.},
	eventtitle = {2023 {IEEE}/{ACM} 4th International Workshop on Quantum Software Engineering (Q-{SE})},
	pages = {1--8},
	booktitle = {2023 {IEEE}/{ACM} 4th International Workshop on Quantum Software Engineering (Q-{SE})},
	author = {Evans, Aidan and Omonije, Seun and Soulé, Robert and Rand, Robert},
	urldate = {2024-08-08},
	date = {2023-05},
	keywords = {Logic gates, Quantum computing, programming languages, quantum computing, Adaptation models, Computational modeling, Computer languages, Current measurement, distributed computing, measurement-based quantum computing, one-way quantum computer, Programming},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\bvvandervecht\\Zotero\\storage\\KW44GUGL\\10189152.html:text/html;Submitted Version:C\:\\Users\\bvvandervecht\\Zotero\\storage\\P77A5YJI\\Evans et al. - 2023 - MCBeth A Measurement-based Quantum Programming La.pdf:application/pdf},
}

@misc{smith_practical_2017,
	title = {A Practical Quantum Instruction Set Architecture},
	url = {http://arxiv.org/abs/1608.03355},
	doi = {10.48550/arXiv.1608.03355},
	abstract = {We introduce an abstract machine architecture for classical/quantum computations---including compilation---along with a quantum instruction language called Quil for explicitly writing these computations. With this formalism, we discuss concrete implementations of the machine and non-trivial algorithms targeting them. The introduction of this machine dovetails with ongoing development of quantum computing technology, and makes possible portable descriptions of recent classical/quantum algorithms.},
	number = {{arXiv}:1608.03355},
	publisher = {{arXiv}},
	author = {Smith, Robert S. and Curtis, Michael J. and Zeng, William J.},
	urldate = {2024-08-20},
	date = {2017-02-17},
	eprinttype = {arxiv},
	eprint = {1608.03355 [quant-ph]},
	keywords = {Computer Science - Programming Languages, Quantum Physics, Computer Science - Emerging Technologies},
	file = {arXiv Fulltext PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\5W659AHC\\Smith et al. - 2017 - A Practical Quantum Instruction Set Architecture.pdf:application/pdf;arXiv.org Snapshot:C\:\\Users\\bvvandervecht\\Zotero\\storage\\M84HABGU\\1608.html:text/html},
}

@article{shi_resource-efficient_2020,
	title = {Resource-Efficient Quantum Computing by Breaking Abstractions},
	volume = {108},
	issn = {1558-2256},
	url = {https://ieeexplore.ieee.org/abstract/document/9116963},
	doi = {10.1109/JPROC.2020.2994765},
	abstract = {Building a quantum computer that surpasses the computational power of its classical counterpart is a great engineering challenge. Quantum software optimizations can provide an accelerated pathway to the first generation of quantum computing ({QC}) applications that might save years of engineering effort. Current quantum software stacks follow a layered approach similar to the stack of classical computers, which was designed to manage the complexity. In this review, we point out that greater efficiency of {QC} systems can be achieved by breaking the abstractions between these layers. We review several works along this line, including two hardware-aware compilation optimizations that break the quantum instruction set architecture ({ISA}) abstraction and two error-correction/information-processing schemes that break the qubit abstraction. Last, we discuss several possible future directions.},
	pages = {1353--1370},
	number = {8},
	journaltitle = {Proceedings of the {IEEE}},
	author = {Shi, Yunong and Gokhale, Pranav and Murali, Prakash and Baker, Jonathan M. and Duckering, Casey and Ding, Yongshan and Brown, Natalie C. and Chamberland, Christopher and Javadi-Abhari, Ali and Cross, Andrew W. and Schuster, David I. and Brown, Kenneth R. and Martonosi, Margaret and Chong, Frederic T.},
	urldate = {2024-08-20},
	date = {2020-08},
	note = {Conference Name: Proceedings of the {IEEE}},
	keywords = {Computer architecture, Logic gates, Qubit, Hardware, Optimization, Quantum computing ({QC}), software design, Software design, system analysis and design, System analysis and design},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\bvvandervecht\\Zotero\\storage\\NGKWBGY4\\9116963.html:text/html;Submitted Version:C\:\\Users\\bvvandervecht\\Zotero\\storage\\NEFFDYVY\\Shi et al. - 2020 - Resource-Efficient Quantum Computing by Breaking A.pdf:application/pdf},
}

@misc{bertels_quantum_2021,
	title = {Quantum Accelerator Stack: A Research Roadmap},
	url = {http://arxiv.org/abs/2102.02035},
	doi = {10.48550/arXiv.2102.02035},
	shorttitle = {Quantum Accelerator Stack},
	abstract = {This paper presents the definition and implementation of a quantum computer architecture to enable creating a new computational device - a quantum computer as an accelerator In this paper, we present explicitly the idea of a quantum accelerator which contains the full stack of the layers of an accelerator. Such a stack starts at the highest level describing the target application of the accelerator. Important to realise is that qubits are defined as perfect qubits, implying they do not decohere and perform good quantum gate operations. The next layer abstracts the quantum logic outlining the algorithm that is to be executed on the quantum accelerator. In our case, the logic is expressed in the universal quantum-classical hybrid computation language developed in the group, called {OpenQL}. We also have to start thinking about how to verify, validate and test the quantum software such that the compiler generates a correct version of the quantum circuit. The {OpenQL} compiler translates the program to a common assembly language, called {cQASM}. We need to develop a quantum operating system that manages all the hardware of the micro-architecture. The layer below the micro-architecture is responsible of the mapping and routing of the qubits on the topology such that the nearest-neighbour-constraint can be be respected. At any moment in the future when we are capable of generating multiple good qubits, the compiler can convert the {cQASM} to generate the {eQASM}, which is executable on a particular experimental device incorporating the platform-specific parameters. This way, we are able to distinguish clearly the experimental research towards better qubits, and the industrial and societal applications that need to be developed and executed on a quantum device.},
	number = {{arXiv}:2102.02035},
	publisher = {{arXiv}},
	author = {Bertels, K. and Sarkar, A. and Krol, A. and Budhrani, R. and Samadi, J. and Geoffroy, E. and Matos, J. and Abreu, R. and Gielen, G. and Ashraf, I.},
	urldate = {2024-08-19},
	date = {2021-05-17},
	eprinttype = {arxiv},
	eprint = {2102.02035 [quant-ph]},
	keywords = {Quantum Physics, Computer Science - Hardware Architecture},
	file = {arXiv Fulltext PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\NP7BRIPP\\Bertels et al. - 2021 - Quantum Accelerator Stack A Research Roadmap.pdf:application/pdf;arXiv.org Snapshot:C\:\\Users\\bvvandervecht\\Zotero\\storage\\SKQL78TR\\2102.html:text/html},
}

@article{ohkura_simultaneous_2022,
	title = {Simultaneous Execution of Quantum Circuits on Current and Near-Future {NISQ} Systems},
	volume = {3},
	issn = {2689-1808},
	url = {https://ieeexplore.ieee.org/abstract/document/9749894},
	doi = {10.1109/TQE.2022.3164716},
	abstract = {In the noisy intermediate-scale quantum ({NISQ}) era, the idea of quantum multiprogramming, running multiple quantum circuits ({QCs}) simultaneously on the same hardware, helps to improve the throughput of quantum computation. However, the crosstalk, unwanted interference between qubits on {NISQ} processors, may cause performance degradation when using multiprogramming. To address this challenge, we introduce palloq (parallel allocation of {QCs}), a novel compilation protocol. Palloq improves the performance of quantum multiprogramming on {NISQ} processors, while paying attention to 1) the combination of {QCs} chosen for parallel execution and 2) the assignment of program qubit variables to physical qubits, to reduce unwanted interference among the active set of {QCs}. We also propose a software-based crosstalk detection protocol using a new combination of randomized benchmarking methods. Our method successfully characterizes the suitability of hardware for multiprogramming with relatively low detection costs. We found a tradeoff between the success rate and execution time of the multiprogramming. Our results will be of value when device throughput becomes a significant bottleneck. Until service providers have enough quantum processors available to more than meet demand, this approach will be attractive to the service providers and users who want to optimize job management and throughput of the processor.},
	pages = {1--10},
	journaltitle = {{IEEE} Transactions on Quantum Engineering},
	author = {Ohkura, Yasuhiro and Satoh, Takahiko and Van Meter, Rodney},
	urldate = {2024-08-19},
	date = {2022},
	note = {Conference Name: {IEEE} Transactions on Quantum Engineering},
	keywords = {Quantum circuit, Quantum computing, Qubit, Program processors, quantum computing, Cloud computing, Compiler, crosstalk, Crosstalk, multiprogramming, noisy intermediate-scale quantum ({NISQ}), Throughput},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\bvvandervecht\\Zotero\\storage\\GI2KCX6M\\9749894.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\LEBXXTZJ\\Ohkura et al. - 2022 - Simultaneous Execution of Quantum Circuits on Curr.pdf:application/pdf},
}

@inproceedings{xu_synthesizing_2021,
	location = {New York, {NY}, {USA}},
	title = {Synthesizing safe and efficient kernel extensions for packet processing},
	isbn = {978-1-4503-8383-7},
	url = {https://dl.acm.org/doi/10.1145/3452296.3472929},
	doi = {10.1145/3452296.3472929},
	series = {{SIGCOMM} '21},
	abstract = {Extended Berkeley Packet Filter ({BPF}) has emerged as a powerful method to extend packet-processing functionality in the Linux operating system. {BPF} allows users to write code in high-level languages (like C or Rust) and execute them at specific hooks in the kernel, such as the network device driver. To ensure safe execution of a user-developed {BPF} program in kernel context, Linux uses an in-kernel static checker. The checker allows a program to execute only if it can prove that the program is crash-free, always accesses memory within safe bounds, and avoids leaking kernel data.{BPF} programming is not easy. One, even modest-sized {BPF} programs are deemed too large to analyze and rejected by the kernel checker. Two, the kernel checker may incorrectly determine that a {BPF} program exhibits unsafe behaviors. Three, even small performance optimizations to {BPF} code (e.g., 5\% gains) must be meticulously hand-crafted by expert developers. Traditional optimizing compilers for {BPF} are often inadequate since the kernel checker's safety constraints are incompatible with rule-based optimizations.We present K2, a program-synthesis-based compiler that automatically optimizes {BPF} bytecode with formal correctness and safety guarantees. K2 produces code with 6--26\% reduced size, 1.36\%--55.03\% lower average packet-processing latency, and 0--4.75\% higher throughput (packets per second per core) relative to the best clang-compiled program, across benchmarks drawn from Cilium, Facebook, and the Linux kernel. K2 incorporates several domain-specific techniques to make synthesis practical by accelerating equivalence-checking of {BPF} programs by 6 orders of magnitude.},
	pages = {50--64},
	booktitle = {Proceedings of the 2021 {ACM} {SIGCOMM} 2021 Conference},
	publisher = {Association for Computing Machinery},
	author = {Xu, Qiongwen and Wong, Michael D. and Wagle, Tanvi and Narayana, Srinivas and Sivaraman, Anirudh},
	urldate = {2024-08-19},
	date = {2021-08-09},
	file = {Full Text PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\G53T6UB7\\Xu et al. - 2021 - Synthesizing safe and efficient kernel extensions .pdf:application/pdf},
}

@misc{bezati_streamblocks_2021,
	title = {{StreamBlocks}: A compiler for heterogeneous dataflow computing (technical report)},
	url = {http://arxiv.org/abs/2107.09333},
	doi = {10.48550/arXiv.2107.09333},
	shorttitle = {{StreamBlocks}},
	abstract = {To increase performance and efficiency, systems use {FPGAs} as reconfigurable accelerators. A key challenge in designing these systems is partitioning computation between processors and an {FPGA}. An appropriate division of labor may be difficult to predict in advance and require experiments and measurements. When an investigation requires rewriting part of the system in a new language or with a new programming model, its high cost can retard the study of different configurations. A single-language system with an appropriate programming model and compiler that targets both platforms simplifies this exploration to a simple recompile with new compiler directives. This work introduces {StreamBlocks}, an open-source compiler and runtime that uses the {CAL} dataflow programming language to partition computations across heterogeneous ({CPU}/accelerator) platforms. Because of the dataflow model's semantics and the {CAL} language, {StreamBlocks} can exploit both thread parallelism in multi-core {CPUs} and the inherent parallelism of {FPGAs}. {StreamBlocks} supports exploring the design space with a profile-guided tool that helps identify the best hardware-software partitions.},
	number = {{arXiv}:2107.09333},
	publisher = {{arXiv}},
	author = {Bezati, Endri and Emami, Mahyar and Janneck, Jörn and Larus, James},
	urldate = {2024-08-19},
	date = {2021-07-20},
	eprinttype = {arxiv},
	eprint = {2107.09333 [cs]},
	keywords = {Computer Science - Hardware Architecture, Computer Science - Computation and Language, B.4.0, B.6.0, B.8.2, C.5, Computer Science - Performance, D.1.3, D.3.0, I.6.5},
	file = {arXiv Fulltext PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\SP59RBL3\\Bezati et al. - 2021 - StreamBlocks A compiler for heterogeneous dataflo.pdf:application/pdf;arXiv.org Snapshot:C\:\\Users\\bvvandervecht\\Zotero\\storage\\RQPQCBPW\\2107.html:text/html},
}

@inproceedings{amini_static_2013,
	location = {Berlin, Heidelberg},
	title = {Static Compilation Analysis for Host-Accelerator Communication Optimization},
	isbn = {978-3-642-36036-7},
	doi = {10.1007/978-3-642-36036-7_16},
	abstract = {We present an automatic, static program transformation that schedules and generates efficient memory transfers between a computer host and its hardware accelerator, addressing a well-known performance bottleneck. Our automatic approach uses two simple heuristics: to perform transfers to the accelerator as early as possible and to delay transfers back from the accelerator as late as possible. We implemented this transformation as a middle-end compilation pass in the pips /Par4All compiler. In the generated code, redundant communications due to data reuse between kernel executions are avoided. Instructions that initiate transfers are scheduled effectively at compile-time. We present experimental results obtained with the Polybench 2.0, some Rodinia benchmarks, and with a real numerical simulation. We obtain an average speedup of 4 to 5 when compared to a naïve parallelization using a modern gpu with Par4All , hmpp , and pgi , and 3.5 when compared to an {OpenMP} version using a 12-core multiprocessor.},
	pages = {237--251},
	booktitle = {Languages and Compilers for Parallel Computing},
	publisher = {Springer},
	author = {Amini, Mehdi and Coelho, Fabien and Irigoin, François and Keryell, Ronan},
	editor = {Rajopadhye, Sanjay and Mills Strout, Michelle},
	date = {2013},
	langid = {english},
	keywords = {Automatic parallelization, communication optimization, {GPU}, heterogeneous parallel architecture, source-to-source compilation},
	file = {Full Text PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\PKIPZI65\\Amini et al. - 2013 - Static Compilation Analysis for Host-Accelerator C.pdf:application/pdf},
}

@article{amy_staqfull-stack_2020,
	title = {staq—A full-stack quantum processing toolkit},
	volume = {5},
	issn = {2058-9565},
	url = {https://dx.doi.org/10.1088/2058-9565/ab9359},
	doi = {10.1088/2058-9565/ab9359},
	abstract = {We describe staq, a full-stack quantum processing toolkit written in standard C++. staq is a quantum compiler toolkit, comprising of tools that range from quantum optimizers and translators to physical mappers for quantum devices with restricted connectives. The design of staq is inspired from the {UNIX} philosophy of ‘less is more’, i.e. staq achieves complex functionality via combining (piping) small tools, each of which performs a single task using the most advanced current state-of-the-art methods. We also provide a set of illustrative benchmarks.},
	pages = {034016},
	number = {3},
	journaltitle = {Quantum Science and Technology},
	shortjournal = {Quantum Sci. Technol.},
	author = {Amy, Matthew and Gheorghiu, Vlad},
	urldate = {2024-08-19},
	date = {2020-06},
	langid = {english},
	note = {Publisher: {IOP} Publishing},
	file = {Submitted Version:C\:\\Users\\bvvandervecht\\Zotero\\storage\\RI4VNNLC\\Amy and Gheorghiu - 2020 - staq—A full-stack quantum processing toolkit.pdf:application/pdf},
}

@article{sivarajah_tket_2020,
	title = {t{\textbar}ket⟩: a retargetable compiler for {NISQ} devices},
	volume = {6},
	issn = {2058-9565},
	url = {https://dx.doi.org/10.1088/2058-9565/ab8e92},
	doi = {10.1088/2058-9565/ab8e92},
	shorttitle = {t{\textbar}ket⟩},
	abstract = {We present t{\textbar}ket⟩, a quantum software development platform produced by Cambridge Quantum Computing Ltd. The heart of t{\textbar}ket⟩ is a language-agnostic optimising compiler designed to generate code for a variety of {NISQ} devices, which has several features designed to minimise the influence of device error. The compiler has been extensively benchmarked and outperforms most competitors in terms of circuit optimisation and qubit routing.},
	pages = {014003},
	number = {1},
	journaltitle = {Quantum Science and Technology},
	shortjournal = {Quantum Sci. Technol.},
	author = {Sivarajah, Seyon and Dilkes, Silas and Cowtan, Alexander and Simmons, Will and Edgington, Alec and Duncan, Ross},
	urldate = {2024-08-19},
	date = {2020-11},
	langid = {english},
	note = {Publisher: {IOP} Publishing},
	file = {Accepted Version:C\:\\Users\\bvvandervecht\\Zotero\\storage\\K4CR84NZ\\Sivarajah et al. - 2020 - tket⟩ a retargetable compiler for NISQ devices.pdf:application/pdf},
}

@article{haner_software_2018,
	title = {A software methodology for compiling quantum programs},
	volume = {3},
	issn = {2058-9565},
	url = {https://dx.doi.org/10.1088/2058-9565/aaa5cc},
	doi = {10.1088/2058-9565/aaa5cc},
	abstract = {Quantum computers promise to transform our notions of computation by offering a completely new paradigm. To achieve scalable quantum computation, optimizing compilers and a corresponding software design flow will be essential. We present a software architecture for compiling quantum programs from a high-level language program to hardware-specific instructions. We describe the necessary layers of abstraction and their differences and similarities to classical layers of a computer-aided design flow. For each layer of the stack, we discuss the underlying methods for compilation and optimization. Our software methodology facilitates more rapid innovation among quantum algorithm designers, quantum hardware engineers, and experimentalists. It enables scalable compilation of complex quantum algorithms and can be targeted to any specific quantum hardware implementation.},
	pages = {020501},
	number = {2},
	journaltitle = {Quantum Science and Technology},
	shortjournal = {Quantum Sci. Technol.},
	author = {Häner, Thomas and Steiger, Damian S. and Svore, Krysta and Troyer, Matthias},
	urldate = {2024-08-19},
	date = {2018-02},
	langid = {english},
	note = {Publisher: {IOP} Publishing},
	file = {IOP Full Text PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\T7DCFH24\\Häner et al. - 2018 - A software methodology for compiling quantum progr.pdf:application/pdf},
}

@article{mccaskey_xacc_2020,
	title = {{XACC}: a system-level software infrastructure for heterogeneous quantum–classical computing*},
	volume = {5},
	issn = {2058-9565},
	url = {https://dx.doi.org/10.1088/2058-9565/ab6bf6},
	doi = {10.1088/2058-9565/ab6bf6},
	shorttitle = {{XACC}},
	abstract = {Quantum programming techniques and software have advanced significantly over the past five years, with a majority focusing on high-level language frameworks targeting remote {REST} library {APIs}. As quantum computing architectures advance and become more widely available, lower-level, system software infrastructures will be needed to enable tighter, co-processor programming and access models. Here we present {XACC}, a system-level software infrastructure for quantum–classical computing that promotes a service-oriented architecture to expose interfaces for core quantum programming, compilation, and execution tasks. We detail {XACC}'s interfaces, their interactions, and its implementation as a hardware-agnostic framework for both near-term and future quantum–classical architectures. We provide concrete examples demonstrating the utility of this framework with paradigmatic tasks. Our approach lays the foundation for the development of compilers, associated runtimes, and low-level system tools tightly integrating quantum and classical workflows.},
	pages = {024002},
	number = {2},
	journaltitle = {Quantum Science and Technology},
	shortjournal = {Quantum Sci. Technol.},
	author = {{McCaskey}, Alexander J. and Lyakh, Dmitry I. and Dumitrescu, Eugene F. and Powers, Sarah S. and Humble, Travis S.},
	urldate = {2024-08-13},
	date = {2020-02},
	langid = {english},
	note = {Publisher: {IOP} Publishing},
	file = {Submitted Version:C\:\\Users\\bvvandervecht\\Zotero\\storage\\KXDJN22P\\McCaskey et al. - 2020 - XACC a system-level software infrastructure for h.pdf:application/pdf},
}

@article{li_verified_2022,
	title = {Verified compilation of Quantum oracles},
	volume = {6},
	url = {https://dl.acm.org/doi/10.1145/3563309},
	doi = {10.1145/3563309},
	abstract = {Quantum algorithms often apply classical operations, such as arithmetic or predicate checks, over a quantum superposition of classical data; these so-called oracles are often the largest components of a quantum program. To ease the construction of efficient, correct oracle functions, this paper presents {VQO}, a high-assurance framework implemented with the Coq proof assistant. The core of {VQO} is {OQASM}, the oracle quantum assembly language. {OQASM} operations move qubits between two different bases via the quantum Fourier transform, thus admitting important optimizations, but without inducing entanglement and the exponential blowup that comes with it. {OQASM}’s design enabled us to prove correct {VQO}’s compilers—from a simple imperative language called {OQIMP} to {OQASM}, and from {OQASM} to {SQIR}, a general-purpose quantum assembly language—and allowed us to efficiently test properties of {OQASM} programs using the {QuickChick} property-based testing framework. We have used {VQO} to implement a variety of arithmetic and geometric operators that are building blocks for important oracles, including those used in Shor’s and Grover’s algorithms. We found that {VQO}’s {QFT}-based arithmetic oracles require fewer qubits, sometimes substantially fewer, than those constructed using “classical” gates; {VQO}’s versions of the latter were nevertheless on par with or better than (in terms of both qubit and gate counts) oracles produced by Quipper, a state-of-the-art but unverified quantum programming platform.},
	pages = {146:589--146:615},
	issue = {{OOPSLA}2},
	journaltitle = {Reproduction Package for "Verified Compilation of Quantum Oracles"},
	shortjournal = {Proc. {ACM} Program. Lang.},
	author = {Li, Liyi and Voichick, Finn and Hietala, Kesha and Peng, Yuxiang and Wu, Xiaodi and Hicks, Michael},
	urldate = {2024-08-13},
	date = {2022-10-31},
	file = {Full Text PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\N3JAIRFZ\\Li et al. - 2022 - Verified compilation of Quantum oracles.pdf:application/pdf},
}

@inproceedings{li_tackling_2019,
	location = {New York, {NY}, {USA}},
	title = {Tackling the Qubit Mapping Problem for {NISQ}-Era Quantum Devices},
	isbn = {978-1-4503-6240-5},
	url = {https://dl.acm.org/doi/10.1145/3297858.3304023},
	doi = {10.1145/3297858.3304023},
	series = {{ASPLOS} '19},
	abstract = {Due to little considerations in the hardware constraints, e.g., limited connections between physical qubits to enable two-qubit gates, most quantum algorithms cannot be directly executed on the Noisy Intermediate-Scale Quantum ({NISQ}) devices. Dynamically remapping logical qubits to physical qubits in the compiler is needed to enable the two-qubit gates in the algorithm, which introduces additional operations and inevitably reduces the fidelity of the algorithm. Previous solutions in finding such remapping suffer from high complexity, poor initial mapping quality, and limited flexibility and control. To address these drawbacks mentioned above, this paper proposes a {SWAP}-based Bidirectional heuristic search algorithm ({SABRE}), which is applicable to {NISQ} devices with arbitrary connections between qubits. By optimizing every search attempt, globally optimizing the initial mapping using a novel reverse traversal technique, introducing the decay effect to enable the trade-off between the depth and the number of gates of the entire algorithm, {SABRE} outperforms the best known algorithm with exponential speedup and comparable or better results on various benchmarks.},
	pages = {1001--1014},
	booktitle = {Proceedings of the Twenty-Fourth International Conference on Architectural Support for Programming Languages and Operating Systems},
	publisher = {Association for Computing Machinery},
	author = {Li, Gushu and Ding, Yufei and Xie, Yuan},
	urldate = {2024-08-13},
	date = {2019-04-04},
	file = {Full Text PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\GC3VGP7P\\Li et al. - 2019 - Tackling the Qubit Mapping Problem for NISQ-Era Qu.pdf:application/pdf},
}

@article{chatterjee_qurzon_2022,
	title = {Qurzon: A Prototype for a Divide and Conquer-Based Quantum Compiler for Distributed Quantum Systems},
	volume = {3},
	issn = {2661-8907},
	url = {https://doi.org/10.1007/s42979-022-01207-9},
	doi = {10.1007/s42979-022-01207-9},
	shorttitle = {Qurzon},
	abstract = {When working with algorithms on quantum devices, quantum memory becomes a crucial bottleneck due to low qubit count in {NISQ}-era devices. In this context, the concept of ‘divide and compute’, wherein a quantum circuit is broken into several subcircuits and executed separately, while stitching the results of the circuits via classical post-processing, becomes a viable option, especially in {NISQ}-era devices. This paper introduces Qurzon, a proposed novel quantum compiler that incorporates the marriage of techniques of divide and compute with the state-of-the-art algorithms of optimal qubit placement for executing on real quantum devices. A scheduling algorithm is also introduced within the compiler that can explore the power of distributed quantum computing while paving the way for quantum parallelism for large algorithms. Several benchmark circuits have been executed using the compiler, thereby demonstrating the power of the divide and compute when working with real {NISQ}-era quantum devices.},
	pages = {323},
	number = {4},
	journaltitle = {{SN} Computer Science},
	shortjournal = {{SN} {COMPUT}. {SCI}.},
	author = {Chatterjee, Turbasu and Das, Arnav and Mohtashim, Shah Ishmam and Saha, Amit and Chakrabarti, Amlan},
	urldate = {2024-08-13},
	date = {2022-06-10},
	langid = {english},
	keywords = {Quantum computing, Compilers, Conquer, Distributed systems, Divide},
	file = {Full Text PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\A4I4BCVW\\Chatterjee et al. - 2022 - Qurzon A Prototype for a Divide and Conquer-Based.pdf:application/pdf},
}

@article{voichick_qunity_2023,
	title = {Qunity: A Unified Language for Quantum and Classical Computing},
	volume = {7},
	url = {https://dl.acm.org/doi/10.1145/3571225},
	doi = {10.1145/3571225},
	shorttitle = {Qunity},
	abstract = {We introduce Qunity, a new quantum programming language designed to treat quantum computing as a natural generalization of classical computing. Qunity presents a unified syntax where familiar programming constructs can have both quantum and classical effects. For example, one can use sum types to implement the direct sum of linear operators, exception-handling syntax to implement projective measurements, and aliasing to induce entanglement. Further, Qunity takes advantage of the overlooked {BQP} subroutine theorem, allowing one to construct reversible subroutines from irreversible quantum algorithms through the uncomputation of "garbage" outputs. Unlike existing languages that enable quantum aspects with separate add-ons (like a classical language with quantum gates bolted on), Qunity provides a unified syntax and a novel denotational semantics that guarantees that programs are quantum mechanically valid. We present Qunity's syntax, type system, and denotational semantics, showing how it can cleanly express several quantum algorithms. We also detail how Qunity can be compiled into a low-level qubit circuit language like {OpenQASM}, proving the realizability of our design.},
	pages = {32:921--32:951},
	issue = {{POPL}},
	journaltitle = {Qunity: A Unified Language for Quantum and Classical Computing (Type Checker)},
	shortjournal = {Proc. {ACM} Program. Lang.},
	author = {Voichick, Finn and Li, Liyi and Rand, Robert and Hicks, Michael},
	urldate = {2024-08-13},
	date = {2023-01-11},
	file = {Full Text PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\UC4JL47T\\Voichick et al. - 2023 - Qunity A Unified Language for Quantum and Classic.pdf:application/pdf},
}

@article{fang_quantum_2023,
	title = {Quantum {NETwork}: from theory to practice},
	volume = {66},
	issn = {1869-1919},
	url = {https://doi.org/10.1007/s11432-023-3773-4},
	doi = {10.1007/s11432-023-3773-4},
	shorttitle = {Quantum {NETwork}},
	abstract = {The quantum internet is envisioned as the ultimate stage of the quantum revolution, which surpasses its classical counterpart in various aspects, such as the efficiency of data transmission, the security of network services, and the capability of information processing. Given its disruptive impact on the national security and the digital economy, a global race to build scalable quantum networks has already begun. With the joint effort of national governments, industrial participants, and research institutes, the development of quantum networks has advanced rapidly in recent years, bringing the first primitive quantum networks within reach. In this work, we aim to provide an up-to-date review of the field of quantum networks from both theoretical and experimental perspectives, contributing to a better understanding of the building blocks required for the establishment of a global quantum internet. We also introduce a newly developed quantum network toolkit to facilitate the exploration and evaluation of innovative ideas. Particularly, it provides dual quantum computing engines, supporting simulations in both the quantum circuit and measurement-based models. It also includes a compilation scheme for mapping quantum network protocols onto quantum circuits, enabling their emulations on real-world quantum hardware devices. We showcase the power of this toolkit with several featured demonstrations, including a simulation of the Micius quantum satellite experiment, a testing of a four-layer quantum network architecture with resource management, and a quantum emulation of the {CHSH} game. We hope this work can give a better understanding of the state-of-the-art development of quantum networks and provide the necessary tools to make further contributions along the way.},
	pages = {180509},
	number = {8},
	journaltitle = {Science China Information Sciences},
	shortjournal = {Sci. China Inf. Sci.},
	author = {Fang, Kun and Zhao, Jingtian and Li, Xiufan and Li, Yifei and Duan, Runyao},
	urldate = {2024-08-13},
	date = {2023-07-05},
	langid = {english},
	keywords = {quantum internet, quantum network, quantum network architecture, quantum network protocol, quantum network simulation, quantum software toolkit},
	file = {Full Text PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\ZZNRDCBL\\Fang et al. - 2023 - Quantum NETwork from theory to practice.pdf:application/pdf},
}

@article{cuomo_optimized_2023,
	title = {Optimized Compiler for Distributed Quantum Computing},
	volume = {4},
	url = {https://dl.acm.org/doi/10.1145/3579367},
	doi = {10.1145/3579367},
	abstract = {Practical distributed quantum computing requires the development of efficient compilers, able to make quantum circuits compatible with some given hardware constraints. This problem is known to be tough, even for local computing. Here, we address it on distributed architectures. As generally assumed in this scenario, telegates represent the fundamental remote (inter-processor) operations. Each telegate consists of several tasks: (i) entanglement generation and distribution, (ii) local operations, and (iii) classical communications. Entanglement generations and distribution is an expensive resource, as it is time-consuming. To mitigate its impact, we model an optimization problem that combines running-time minimization with the usage of distributed entangled states. Specifically, we formulated the distributed compilation problem as a dynamic network flow. To enhance the solution space, we extend the formulation, by introducing a predicate that manipulates the circuit given in input and parallelizes telegate tasks.To evaluate our framework, we split the problem into three sub-problems, and solve it by means of an approximation routine. Experiments demonstrate that the run-time is resistant to the problem size scaling. Moreover, we apply the proposed algorithm to compile circuits under different topologies, showing that topologies with a higher ratio between edges and nodes give rise to shallower circuits.},
	pages = {15:1--15:29},
	number = {2},
	journaltitle = {{ACM} Transactions on Quantum Computing},
	author = {Cuomo, Daniele and Caleffi, Marcello and Krsulich, Kevin and Tramonto, Filippo and Agliardi, Gabriele and Prati, Enrico and Cacciapuoti, Angela Sara},
	urldate = {2024-08-13},
	date = {2023-02-24},
	file = {Full Text PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\HKFC5677\\Cuomo et al. - 2023 - Optimized Compiler for Distributed Quantum Computi.pdf:application/pdf},
}

@article{anderson_netkat_2014,
	title = {{NetKAT}: semantic foundations for networks},
	volume = {49},
	issn = {0362-1340},
	url = {https://dl.acm.org/doi/10.1145/2578855.2535862},
	doi = {10.1145/2578855.2535862},
	shorttitle = {{NetKAT}},
	abstract = {Recent years have seen growing interest in high-level languages for programming networks. But the design of these languages has been largely ad hoc, driven more by the needs of applications and the capabilities of network hardware than by foundational principles. The lack of a semantic foundation has left language designers with little guidance in determining how to incorporate new features, and programmers without a means to reason precisely about their code.This paper presents {NetKAT}, a new network programming language that is based on a solid mathematical foundation and comes equipped with a sound and complete equational theory. We describe the design of {NetKAT}, including primitives for filtering, modifying, and transmitting packets; union and sequential composition operators; and a Kleene star operator that iterates programs. We show that {NetKAT} is an instance of a canonical and well-studied mathematical structure called a Kleene algebra with tests ({KAT}) and prove that its equational theory is sound and complete with respect to its denotational semantics. Finally, we present practical applications of the equational theory including syntactic techniques for checking reachability, proving non-interference properties that ensure isolation between programs, and establishing the correctness of compilation algorithms.},
	pages = {113--126},
	number = {1},
	journaltitle = {{SIGPLAN} Not.},
	author = {Anderson, Carolyn Jane and Foster, Nate and Guha, Arjun and Jeannin, Jean-Baptiste and Kozen, Dexter and Schlesinger, Cole and Walker, David},
	urldate = {2024-08-13},
	date = {2014-01-08},
	file = {Full Text PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\CF33RP74\\Anderson et al. - 2014 - NetKAT semantic foundations for networks.pdf:application/pdf},
}

@inproceedings{saki_muzzle_2022,
	title = {Muzzle the Shuttle: Efficient Compilation for Multi-Trap Trapped-Ion Quantum Computers},
	url = {https://ieeexplore.ieee.org/abstract/document/9774619},
	doi = {10.23919/DATE54114.2022.9774619},
	shorttitle = {Muzzle the Shuttle},
	abstract = {Trapped-ion systems can have a limited number of ions (qubits) in a single trap. Increasing the qubit count to run meaningful quantum algorithms would require multiple traps where ions need to shuttle between traps to communicate. The existing compiler has several limitations, which result in a high number of shuttle operations and degraded fidelity. In this paper, we target this gap and propose compiler optimizations to reduce the number of shuttles. Our technique achieves a maximum reduction of 51.17\% in shuttles (average 33\%) tested over 125 circuits. Furthermore, the improved compilation enhances the program fidelity up to 22.68X with a modest increase in the compilation time.},
	eventtitle = {2022 Design, Automation \& Test in Europe Conference \& Exhibition ({DATE})},
	pages = {322--327},
	booktitle = {2022 Design, Automation \& Test in Europe Conference \& Exhibition ({DATE})},
	author = {Saki, Abdullah Ash and Topaloglu, Rasit Onur and Ghosh, Swaroop},
	urldate = {2024-08-13},
	date = {2022-03},
	note = {{ISSN}: 1558-1101},
	keywords = {Qubit, Computers, Quantum algorithm, Optimization, Compiler, Quantum Computing, Ions, Shuttle, Trapped-Ion},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\bvvandervecht\\Zotero\\storage\\TMBZCTJT\\9774619.html:text/html;Submitted Version:C\:\\Users\\bvvandervecht\\Zotero\\storage\\NC24WUBW\\Saki et al. - 2022 - Muzzle the Shuttle Efficient Compilation for Mult.pdf:application/pdf},
}

@inproceedings{bandic_mapping_2023,
	title = {Mapping Quantum Circuits to Modular Architectures with {QUBO}},
	volume = {01},
	url = {https://ieeexplore.ieee.org/abstract/document/10313719},
	doi = {10.1109/QCE57702.2023.00094},
	abstract = {Modular quantum computing architectures are a promising alternative to monolithic {QPU} (Quantum Processing Unit) designs for scaling up quantum devices. They refer to a set of interconnected {QPUs} or cores consisting of tightly coupled quantum bits that can communicate via quantum-coherent and classical links. In multi-core architectures, it is crucial to minimize the amount of communication between cores when executing an algorithm. Therefore, mapping a quantum circuit onto a modular architecture involves finding an optimal assignment of logical qubits (qubits in the quantum circuit) to different cores with the aim to minimize the number of expensive inter-core operations while adhering to given hardware constraints. In this paper, we propose for the first time a Quadratic Unconstrained Binary Optimization ({QUBO}) technique to encode the problem and the solution for both qubit allocation and inter-core communication costs in binary decision variables. To this end, the quantum circuit is split into slices, and qubit assignment is formulated as a graph partitioning problem for each circuit slice. The costly inter-core communication is reduced by penalizing inter-core qubit communications. The final solution is obtained by minimizing the overall cost across all circuit slices. To evaluate the effectiveness of our approach, we conduct a detailed analysis using a representative set of benchmarks having a high number of qubits on two different multi-core architectures. Our method showed promising results and performed exceptionally well with very dense and highly-parallelized circuits that require on average 0.78 inter-core communications per two-qubit gate.},
	eventtitle = {2023 {IEEE} International Conference on Quantum Computing and Engineering ({QCE})},
	pages = {790--801},
	booktitle = {2023 {IEEE} International Conference on Quantum Computing and Engineering ({QCE})},
	author = {Bandic, Medina and Prielinger, Luise and Nüßlein, Jonas and Ovide, Anabel and Rodrigo, Santiago and Abadal, Sergi and van Someren, Hans and Vardoyan, Gayane and Alarcon, Eduard and Almudever, Carmen G. and Feld, Sebastian},
	urldate = {2024-08-13},
	date = {2023-09},
	keywords = {Computer architecture, Logic gates, Qubit, Hardware, Multicore processing, Costs, Integrated circuit interconnections, distributed multi-core quantum computing architectures, full-stack quantum computing systems, Quadratic Unconstrained Binary Optimization ({QUBO}), quantum circuit mapping, quantum compilation},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\bvvandervecht\\Zotero\\storage\\N9PMCZ65\\10313719.html:text/html;Submitted Version:C\:\\Users\\bvvandervecht\\Zotero\\storage\\SXUSUMD7\\Bandic et al. - 2023 - Mapping Quantum Circuits to Modular Architectures .pdf:application/pdf},
}

@misc{wecker_liqui_2014,
	title = {{LIQUi}{\textbar}{\textgreater}: A Software Design Architecture and Domain-Specific Language for Quantum Computing},
	url = {http://arxiv.org/abs/1402.4467},
	doi = {10.48550/arXiv.1402.4467},
	shorttitle = {{LIQUi}{\textbar}{\textgreater}},
	abstract = {Languages, compilers, and computer-aided design tools will be essential for scalable quantum computing, which promises an exponential leap in our ability to execute complex tasks. {LIQUi}{\textbar}{\textgreater} is a modular software architecture designed to control quantum hardware. It enables easy programming, compilation, and simulation of quantum algorithms and circuits, and is independent of a specific quantum architecture. {LIQUi}{\textbar}{\textgreater} contains an embedded, domain-specific language designed for programming quantum algorithms, with F\# as the host language. It also allows the extraction of a circuit data structure that can be used for optimization, rendering, or translation. The circuit can also be exported to external hardware and software environments. Two different simulation environments are available to the user which allow a trade-off between number of qubits and class of operations. {LIQUi}{\textbar}{\textgreater} has been implemented on a wide range of runtimes as back-ends with a single user front-end. We describe the significant components of the design architecture and how to express any given quantum algorithm.},
	number = {{arXiv}:1402.4467},
	publisher = {{arXiv}},
	author = {Wecker, Dave and Svore, Krysta M.},
	urldate = {2024-08-13},
	date = {2014-02-18},
	eprinttype = {arxiv},
	eprint = {1402.4467 [quant-ph]},
	keywords = {Computer Science - Programming Languages, Quantum Physics, Computer Science - Emerging Technologies},
	file = {arXiv Fulltext PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\3HFINU3V\\Wecker and Svore - 2014 - LIQUi A Software Design Architecture and Domain.pdf:application/pdf;arXiv.org Snapshot:C\:\\Users\\bvvandervecht\\Zotero\\storage\\FAES36VG\\1402.html:text/html},
}

@inproceedings{burgholzer_handling_2022,
	location = {New York, {NY}, {USA}},
	title = {Handling non-unitaries in quantum circuit equivalence checking},
	isbn = {978-1-4503-9142-9},
	url = {https://dl.acm.org/doi/10.1145/3489517.3530482},
	doi = {10.1145/3489517.3530482},
	series = {{DAC} '22},
	abstract = {Quantum computers are reaching a level where interactions between classical and quantum computations can happen in real-time. This marks the advent of a new, broader class of quantum circuits: dynamic quantum circuits. They offer a broader range of available computing primitives that lead to new challenges for design tasks such as simulation, compilation, and verification. Due to the non-unitary nature of dynamic circuit primitives, most existing techniques and tools for these tasks are no longer applicable in an out-of-the-box fashion. In this work, we discuss the resulting consequences for quantum circuit verification, specifically equivalence checking, and propose two different schemes that eventually allow to treat the involved circuits as if they did not contain non-unitaries at all. As a result, we demonstrate methodically, as well as, experimentally that existing techniques for verifying the equivalence of quantum circuits can be kept applicable for this broader class of circuits.},
	pages = {529--534},
	booktitle = {Proceedings of the 59th {ACM}/{IEEE} Design Automation Conference},
	publisher = {Association for Computing Machinery},
	author = {Burgholzer, Lukas and Wille, Robert},
	urldate = {2024-08-13},
	date = {2022-08-23},
	file = {Full Text PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\GBZT8S83\\Burgholzer and Wille - 2022 - Handling non-unitaries in quantum circuit equivale.pdf:application/pdf},
}

@misc{luo_formalization_2023,
	title = {Formalization of Quantum Intermediate Representations for Code Safety},
	url = {http://arxiv.org/abs/2303.14500},
	doi = {10.48550/arXiv.2303.14500},
	abstract = {Quantum Intermediate Representation ({QIR}) is a Microsoft-developed, {LLVM}-based intermediate representation for quantum program compilers. {QIR} aims to provide a general solution for quantum program compilers independent of front-end languages and back-end hardware, thus avoiding duplicate development of intermediate representations and compilers. Since it is still under development, {QIR} is described in natural language and lacks a formal definition, leading to ambiguity in its interpretation and a lack of rigor in implementing quantum functions. In this paper, we provide formal definitions for the data types and instruction sets of {QIR}, aiming to provide correctness and security guarantees for operations and intermediate code conversions in {QIR}. To validate our design, we show some samples of unsafe {QIR} code where errors can be detected by our formal approach.},
	number = {{arXiv}:2303.14500},
	publisher = {{arXiv}},
	author = {Luo, Junjie and Zhao, Jianjun},
	urldate = {2024-08-13},
	date = {2023-03-25},
	eprinttype = {arxiv},
	eprint = {2303.14500 [quant-ph]},
	keywords = {Computer Science - Programming Languages, Quantum Physics},
	file = {arXiv Fulltext PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\3Y5BZRDX\\Luo and Zhao - 2023 - Formalization of Quantum Intermediate Representati.pdf:application/pdf;arXiv.org Snapshot:C\:\\Users\\bvvandervecht\\Zotero\\storage\\IR7YI32M\\2303.html:text/html},
}

@inproceedings{das_case_2019,
	location = {New York, {NY}, {USA}},
	title = {A Case for Multi-Programming Quantum Computers},
	isbn = {978-1-4503-6938-1},
	url = {https://dl.acm.org/doi/10.1145/3352460.3358287},
	doi = {10.1145/3352460.3358287},
	series = {{MICRO} '52},
	abstract = {Existing and near-term quantum computers face significant reliability challenges because of high error rates caused by noise. Such machines are operated in the Noisy Intermediate Scale Quantum ({NISQ}) model of computing. As {NISQ} machines exhibit high error-rates, only programs that require a few qubits can be executed reliably. Therefore, {NISQ} machines tend to underutilize its resources. In this paper, we propose to improve the throughput and utilization of {NISQ} machines by using multi-programming and enabling the {NISQ} machine to concurrently execute multiple workloads.Multi-programming a {NISQ} machine is non-trivial. This is because, a multi-programmed {NISQ} machine can have an adverse impact on the reliability of the individual workloads. To enable multi-programming in a robust manner, we propose three solutions. First, we develop methods to partition the qubits into multiple reliable regions using error information from machine calibration so that each program can have a fair allocation of reliable qubits. Second, we observe that when two programs are of unequal lengths, measurement operations can impact the reliability of the co-running program. To reduce this interference, we propose a Delayed Instruction Scheduling ({DIS}) policy that delays the start of the shorter program so that all the measurement operations can be performed at the end. Third, we develop an Adaptive Multi-Programming ({AMP}) design that monitors the reliability at runtime and reverts to single program mode if the reliability impact of multi-programming is greater than a predefined threshold. Our evaluations with {IBM}-Q16 show that our proposals can improve resource utilization and throughput by up to 2x, while limiting the impact on reliability.},
	pages = {291--303},
	booktitle = {Proceedings of the 52nd Annual {IEEE}/{ACM} International Symposium on Microarchitecture},
	publisher = {Association for Computing Machinery},
	author = {Das, Poulami and Tannu, Swamit S. and Nair, Prashant J. and Qureshi, Moinuddin},
	urldate = {2024-08-13},
	date = {2019-10-12},
	file = {Full Text PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\KTWQZSK3\\Das et al. - 2019 - A Case for Multi-Programming Quantum Computers.pdf:application/pdf},
}

@misc{smith_error_2021,
	title = {Error Mitigation in Quantum Computers through Instruction Scheduling},
	url = {http://arxiv.org/abs/2105.01760},
	doi = {10.48550/arXiv.2105.01760},
	abstract = {Quantum systems have potential to demonstrate significant computational advantage, but current quantum devices suffer from the rapid accumulation of error that prevents the storage of quantum information over extended periods. The unintentional coupling of qubits to their environment and each other adds significant noise to computation, and improved methods to combat decoherence are required to boost the performance of quantum algorithms on real machines. While many existing techniques for mitigating error rely on adding extra gates to the circuit, calibrating new gates, or extending a circuit's runtime, this paper's primary contribution leverages the gates already present in a quantum program without extending circuit duration. We exploit circuit slack for single-qubit gates that occur in idle windows, scheduling the gates such that their timing can counteract some errors. Spin-echo corrections that mitigate decoherence on idling qubits act as inspiration for this work. Theoretical models, however, fail to capture all sources of noise in {NISQ} devices, making practical solutions necessary that better minimize the impact of unpredictable errors in quantum machines. This paper presents {TimeStitch}: a novel framework that pinpoints the optimum execution schedules for single-qubit gates within quantum circuits. {TimeStitch}, implemented as a compilation pass, leverages the reversible nature of quantum computation to boost the success of circuits on real quantum machines.},
	number = {{arXiv}:2105.01760},
	publisher = {{arXiv}},
	author = {Smith, Kaitlin N. and Ravi, Gokul Subramanian and Murali, Prakash and Baker, Jonathan M. and Earnest, Nathan and Javadi-Abhari, Ali and Chong, Frederic T.},
	urldate = {2024-08-23},
	date = {2021-11-10},
	eprinttype = {arxiv},
	eprint = {2105.01760 [quant-ph]},
	keywords = {Quantum Physics},
	file = {arXiv Fulltext PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\GZ32JUA8\\Smith et al. - 2021 - Error Mitigation in Quantum Computers through Inst.pdf:application/pdf;arXiv.org Snapshot:C\:\\Users\\bvvandervecht\\Zotero\\storage\\GPEH84ZU\\2105.html:text/html},
}

@article{diadamo_distributed_2021,
	title = {Distributed Quantum Computing and Network Control for Accelerated {VQE}},
	volume = {2},
	issn = {2689-1808},
	url = {https://ieeexplore.ieee.org/abstract/document/9351762},
	doi = {10.1109/TQE.2021.3057908},
	abstract = {Interconnecting small quantum computers will be essential in the future for creating large-scale, robust quantum computers. Methods for distributing monolithic quantum algorithms efficiently are, thus, needed. In this article, we consider an approach for distributing the accelerated variational quantum eigensolver algorithm over arbitrary sized—in terms of number of qubits—distributed quantum computers. We consider approaches for distributing qubit assignments of the Ansatz states required to estimate the expectation value of Hamiltonian operators in quantum chemistry in a parallelized computation and provide a systematic approach to generate distributed quantum circuits for distributed quantum computing. Moreover, we propose an architecture for a distributed quantum control system in the context of centralized and decentralized network control.},
	pages = {1--21},
	journaltitle = {{IEEE} Transactions on Quantum Engineering},
	author = {{DiAdamo}, Stephen and Ghibaudi, Marco and Cruise, James},
	urldate = {2024-08-23},
	date = {2021},
	note = {Conference Name: {IEEE} Transactions on Quantum Engineering},
	keywords = {Distributed quantum computing, Logic gates, Quantum computing, Qubit, Computers, Hardware, Quantum algorithm, Control systems, network control, quantum multicomputing, variational quantum eigensolver},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\bvvandervecht\\Zotero\\storage\\JZ55BFEJ\\9351762.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\AFFJH3QW\\DiAdamo et al. - 2021 - Distributed Quantum Computing and Network Control .pdf:application/pdf},
}

@misc{zhang_context-sensitive_2020,
	title = {Context-Sensitive and Duration-Aware Qubit Mapping for Various {NISQ} Devices},
	url = {http://arxiv.org/abs/2001.06887},
	doi = {10.48550/arXiv.2001.06887},
	abstract = {Quantum computing ({QC}) technologies have reached a second renaissance in the last decade. Some fully programmable {QC} devices have been built based on superconducting or ion trap technologies. Although different quantum technologies have their own parameter indicators, {QC} devices in the {NISQ} era share common features and challenges such as limited qubits and connectivity, short coherence time and high gate error rates. Quantum programs written by programmers could hardly run on real hardware directly since two-qubit gates are usually allowed on few pairs of qubits. Therefore, quantum computing compilers must resolve the mapping problem and transform original programs to fit the hardware limitation. To address the issues mentioned above, we summarize different quantum technologies and abstractly define Quantum Abstract Machine ({QAM}); then propose a {COntext}-sensitive and Duration-Aware Remapping algorithm (Codar) based on the {QAM}. By introducing lock for each qubit, Codar is aware of gate duration difference and program context, which bring it abilities to extract more program's parallelism and reduce program execution time. Compared to the best-known algorithm, Codar halves the total execution time of several quantum algorithms and cut down 17.5\% - 19.4\% total execution time on average in different architectures.},
	number = {{arXiv}:2001.06887},
	publisher = {{arXiv}},
	author = {Zhang, Yu and Deng, Haowei and Li, Quanxi},
	urldate = {2024-08-23},
	date = {2020-01-19},
	eprinttype = {arxiv},
	eprint = {2001.06887 [quant-ph]},
	keywords = {Quantum Physics, Computer Science - Emerging Technologies},
	file = {arXiv Fulltext PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\XEB5HXP8\\Zhang et al. - 2020 - Context-Sensitive and Duration-Aware Qubit Mapping.pdf:application/pdf;arXiv.org Snapshot:C\:\\Users\\bvvandervecht\\Zotero\\storage\\5D2TV6JL\\2001.html:text/html},
}

@article{wetering_constructing_2021,
	title = {Constructing quantum circuits with global gates},
	volume = {23},
	issn = {1367-2630},
	url = {https://dx.doi.org/10.1088/1367-2630/abf1b3},
	doi = {10.1088/1367-2630/abf1b3},
	abstract = {There are various gate sets that can be used to describe a quantum computation. A particularly popular gate set in the literature on quantum computing consists of arbitrary single-qubit gates and two-qubit {CNOT} gates. A {CNOT} gate is however not always the natural multi-qubit interaction that can be implemented on a given physical quantum computer, necessitating a compilation step that transforms these {CNOT} gates to the native gate set. An especially interesting case where compilation is necessary is for ion trap quantum computers, where the natural entangling operation can act on more than two qubits and can even act globally on all qubits at once. This calls for an entirely different approach to constructing efficient circuits. In this paper we study the problem of converting a given circuit that uses two-qubit gates to one that uses global gates. Our three main contributions are as follows. First, we find an efficient algorithm for transforming an arbitrary circuit consisting of Clifford gates and arbitrary phase gates into a circuit consisting of single-qubit gates and a number of global interactions proportional to the number of non-Clifford phases present in the original circuit. Second, we find a general strategy to transform a global gate that targets all qubits into one that targets only a subset of the qubits. This approach scales linearly with the number of qubits that are not targeted, in contrast to the exponential scaling reported in (Maslov and Nam 2018 New J. Phys. 20 033018). Third, we improve on the number of global gates required to synthesise an arbitrary n-qubit Clifford circuit from the 12n − 18 reported in (Maslov and Nam 2018 New J. Phys. 20 033018) to 6n − 8.},
	pages = {043015},
	number = {4},
	journaltitle = {New Journal of Physics},
	shortjournal = {New J. Phys.},
	author = {Wetering, John van de},
	urldate = {2024-08-23},
	date = {2021-04},
	langid = {english},
	note = {Publisher: {IOP} Publishing},
	file = {IOP Full Text PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\ULD7SLDH\\Wetering - 2021 - Constructing quantum circuits with global gates.pdf:application/pdf},
}

@inproceedings{heckey_compiler_2015,
	location = {New York, {NY}, {USA}},
	title = {Compiler Management of Communication and Parallelism for Quantum Computation},
	isbn = {978-1-4503-2835-7},
	url = {https://dl.acm.org/doi/10.1145/2694344.2694357},
	doi = {10.1145/2694344.2694357},
	series = {{ASPLOS} '15},
	abstract = {Quantum computing ({QC}) offers huge promise to accelerate a range of computationally intensive benchmarks. Quantum computing is limited, however, by the challenges of decoherence: i.e., a quantum state can only be maintained for short windows of time before it decoheres. While quantum error correction codes can protect against decoherence, fast execution time is the best defense against decoherence, so efficient architectures and effective scheduling algorithms are necessary. This paper proposes the Multi-{SIMD} {QC} architecture and then proposes and evaluates effective schedulers to map benchmark descriptions onto Multi-{SIMD} architectures. The Multi-{SIMD} model consists of a small number of {SIMD} regions, each of which may support operations on up to thousands of qubits per cycle.Efficient Multi-{SIMD} operation requires efficient scheduling. This work develops schedulers to reduce communication requirements of qubits between operating regions, while also improving parallelism.We find that communication to global memory is a dominant cost in {QC}. We also note that many quantum benchmarks have long serial operation paths (although each operation may be data parallel). To exploit this characteristic, we introduce Longest-Path-First Scheduling ({LPFS}) which pins operations to {SIMD} regions to keep data in-place and reduce communication to memory. The use of small, local scratchpad memories also further reduces communication. Our results show a 3\% to 308\% improvement for {LPFS} over conventional scheduling algorithms, and an additional 3\% to 64\% improvement using scratchpad memories. Our work is the most comprehensive software-to-quantum toolflow published to date, with efficient and practical scheduling techniques that reduce communication and increase parallelism for full-scale quantum code executing up to a trillion quantum gate operations.},
	pages = {445--456},
	booktitle = {Proceedings of the Twentieth International Conference on Architectural Support for Programming Languages and Operating Systems},
	publisher = {Association for Computing Machinery},
	author = {Heckey, Jeff and Patil, Shruti and {JavadiAbhari}, Ali and Holmes, Adam and Kudrow, Daniel and Brown, Kenneth R. and Franklin, Diana and Chong, Frederic T. and Martonosi, Margaret},
	urldate = {2024-08-23},
	date = {2015-03-14},
	file = {Full Text PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\KQ8Q2NB6\\Heckey et al. - 2015 - Compiler Management of Communication and Paralleli.pdf:application/pdf},
}

@inproceedings{webb_formal_2021,
	location = {Cham},
	title = {A Formal Semantics of the {GraalVM} Intermediate Representation},
	isbn = {978-3-030-88885-5},
	doi = {10.1007/978-3-030-88885-5_8},
	abstract = {The optimization phase of a compiler is responsible for transforming an intermediate representation ({IR}) of a program into a more efficient form. Modern optimizers, such as that used in the {GraalVM} compiler, use an {IR} consisting of a sophisticated graph data structure that combines data flow and control flow into the one structure. As part of a wider project on the verification of optimization passes of {GraalVM}, this paper describes a semantics for its {IR} within Isabelle/{HOL}. The semantics consists of a big-step operational semantics for data nodes (which are represented in a graph-based static single assignment ({SSA}) form) and a small-step operational semantics for handling control flow including heap-based reads and writes, exceptions, and method calls. We have proved a suite of canonicalization optimizations and conditional elimination optimizations with respect to the semantics.},
	pages = {111--126},
	booktitle = {Automated Technology for Verification and Analysis},
	publisher = {Springer International Publishing},
	author = {Webb, Brae J. and Utting, Mark and Hayes, Ian J.},
	editor = {Hou, Zhe and Ganesh, Vijay},
	date = {2021},
	langid = {english},
	file = {Full Text PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\I6DHWVUZ\\Webb et al. - 2021 - A Formal Semantics of the GraalVM Intermediate Rep.pdf:application/pdf},
}

@inproceedings{fu_experimental_2017,
	location = {New York, {NY}, {USA}},
	title = {An experimental microarchitecture for a superconducting quantum processor},
	isbn = {978-1-4503-4952-9},
	url = {https://dl.acm.org/doi/10.1145/3123939.3123952},
	doi = {10.1145/3123939.3123952},
	series = {{MICRO}-50 '17},
	abstract = {Quantum computers promise to solve certain problems that are intractable for classical computers, such as factoring large numbers and simulating quantum systems. To date, research in quantum computer engineering has focused primarily at opposite ends of the required system stack: devising high-level programming languages and compilers to describe and optimize quantum algorithms, and building reliable low-level quantum hardware. Relatively little attention has been given to using the compiler output to fully control the operations on experimental quantum processors. Bridging this gap, we propose and build a prototype of a flexible control microarchitecture supporting quantum-classical mixed code for a superconducting quantum processor. The microarchitecture is based on three core elements: (i) a codeword-based event control scheme, (ii) queue-based precise event timing control, and (iii) a flexible multilevel instruction decoding mechanism for control. We design a set of quantum microinstructions that allows flexible control of quantum operations with precise timing. We demonstrate the microarchitecture and microinstruction set by performing a standard gate-characterization experiment on a transmon qubit.},
	pages = {813--825},
	booktitle = {Proceedings of the 50th Annual {IEEE}/{ACM} International Symposium on Microarchitecture},
	publisher = {Association for Computing Machinery},
	author = {Fu, X. and Rol, M. A. and Bultink, C. C. and van Someren, J. and Khammassi, N. and Ashraf, I. and Vermeulen, R. F. L. and de Sterke, J. C. and Vlothuizen, W. J. and Schouten, R. N. and Almudever, C. G. and {DiCarlo}, L. and Bertels, K.},
	urldate = {2024-09-10},
	date = {2017-10-14},
}

@article{smith_open-source_2020,
	title = {An open-source, industrial-strength optimizing compiler for quantum programs},
	volume = {5},
	issn = {2058-9565},
	url = {https://dx.doi.org/10.1088/2058-9565/ab9acb},
	doi = {10.1088/2058-9565/ab9acb},
	abstract = {Quilc is an open-source, optimizing compiler for gate-based quantum programs written in Quil or {QASM}, two popular quantum programming languages. The compiler was designed with attention toward {NISQ}-era quantum computers, specifically recognizing that each quantum gate has a non-negligible and often irrecoverable cost toward a program’s successful execution. Quilc’s primary goal is to make authoring quantum software a simpler exercise by making architectural details less burdensome to the author. Using Quilc allows one to write programs faster while usually not compromising—and indeed sometimes improving—their execution fidelity on a given hardware architecture. In this paper, we describe many of the principles behind Quilc’s design, and demonstrate the compiler with various examples.},
	pages = {044001},
	number = {4},
	journaltitle = {Quantum Science and Technology},
	shortjournal = {Quantum Sci. Technol.},
	author = {Smith, R. S. and Peterson, E. C. and Skilbeck, M. G. and Davis, E. J.},
	urldate = {2024-09-10},
	date = {2020-07},
	langid = {english},
	note = {Publisher: {IOP} Publishing},
	file = {Submitted Version:C\:\\Users\\bvvandervecht\\Zotero\\storage\\XE9HTTIR\\Smith et al. - 2020 - An open-source, industrial-strength optimizing com.pdf:application/pdf},
}

@article{nguyen_extending_2022,
	title = {Extending Python for Quantum-classical Computing via Quantum Just-in-time Compilation},
	volume = {3},
	url = {https://dl.acm.org/doi/10.1145/3544496},
	doi = {10.1145/3544496},
	abstract = {Python is a popular programming language known for its flexibility, usability, readability, and focus on developer productivity. The quantum software community has adopted Python on a number of large-scale efforts due to these characteristics, as well as the remote nature of near-term quantum processors. The use of Python has enabled quick prototyping for quantum code that directly benefits pertinent research and development efforts in quantum scientific computing. However, this rapid prototyping ability comes at the cost of future performant integration for tightly coupled {CPU}-{QPU} architectures with fast-feedback. Here, we present a language extension to Python that enables heterogeneous quantum-classical computing via a robust C++ infrastructure for quantum just-in-time ({QJIT}) compilation. Our work builds off the {QCOR} C++ language extension and compiler infrastructure to enable a single-source, quantum hardware-agnostic approach to quantum-classical computing that retains the performance required for tightly coupled {CPU}-{QPU} compute models. We detail this Python extension, its programming model and underlying software architecture, and provide a robust set of examples to demonstrate the utility of our approach.},
	pages = {24:1--24:25},
	number = {4},
	journaltitle = {{ACM} Transactions on Quantum Computing},
	author = {Nguyen, Thien and {McCaskey}, Alexander J.},
	urldate = {2024-09-10},
	date = {2022-07-27},
	file = {Full Text PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\DHG3GWLS\\Nguyen and McCaskey - 2022 - Extending Python for Quantum-classical Computing v.pdf:application/pdf},
}

@article{caleffi_distributed_2024,
	title = {Distributed quantum computing: A survey},
	volume = {254},
	issn = {1389-1286},
	url = {https://www.sciencedirect.com/science/article/pii/S1389128624005048},
	doi = {10.1016/j.comnet.2024.110672},
	shorttitle = {Distributed quantum computing},
	abstract = {Nowadays, quantum computing has reached the engineering phase, with fully-functional quantum processors integrating hundreds of noisy qubits. Yet – to fully unveil the potential of quantum computing out of the labs into the business reality – the challenge ahead is to substantially scale the qubit number, reaching orders of magnitude exceeding thousands of fault-tolerant qubits. To this aim, the distributed quantum computing paradigm is recognized as the key solution for scaling the number of qubits. Indeed, accordingly to such a paradigm, multiple small-to-moderate-scale quantum processors communicate and cooperate for executing computational tasks exceeding the computational power of single processing devices. The aim of this survey is to provide the reader with an overview about the main challenges and open problems arising with distributed quantum computing from a computer and communications engineering perspective. Furthermore, this survey provides an easy access and guide towards the relevant literature and the prominent results in the field.},
	pages = {110672},
	journaltitle = {Computer Networks},
	shortjournal = {Computer Networks},
	author = {Caleffi, Marcello and Amoretti, Michele and Ferrari, Davide and Illiano, Jessica and Manzalini, Antonio and Cacciapuoti, Angela Sara},
	urldate = {2024-09-13},
	date = {2024-12-01},
	keywords = {Distributed quantum computing, Quantum computing, Quantum networks, Quantum computation, Quantum algorithms, Quantum communications, Quantum compiler, Quantum compiling, Quantum internet, Simulator},
	file = {1-s2.0-S1389128624005048-main.pdf:C\:\\Users\\bartv\\Zotero\\storage\\HRGJ2UXW\\1-s2.0-S1389128624005048-main.pdf:application/pdf;ScienceDirect Snapshot:C\:\\Users\\bvvandervecht\\Zotero\\storage\\HRGJ2UXW\\S1389128624005048.html:text/html},
}

@article{ferrari_modular_2023,
	title = {A Modular Quantum Compilation Framework for Distributed Quantum Computing},
	volume = {4},
	issn = {2689-1808},
	url = {http://arxiv.org/abs/2305.02969},
	doi = {10.1109/TQE.2023.3303935},
	abstract = {For most practical applications, quantum algorithms require large resources in terms of qubit number, much larger than those available with current {NISQ} processors. With the network and communication functionalities provided by the Quantum Internet, Distributed Quantum Computing ({DQC}) is considered as a scalable approach for increasing the number of available qubits for computational tasks. For {DQC} to be effective and efficient, a quantum compiler must find the best partitioning for the quantum algorithm and then perform smart remote operation scheduling to optimize {EPR} pair consumption. At the same time, the quantum compiler should also find the best local transformation for each partition. In this paper we present a modular quantum compilation framework for {DQC} that takes into account both network and device constraints and characteristics. We implemented and tested a quantum compiler based on the proposed framework with some circuits of interest, such as the {VQE} and {QFT} ones, considering different network topologies, with quantum processors characterized by heavy hexagon coupling maps. We also devised a strategy for remote scheduling that can exploit both {TeleGate} and {TeleData} operations and tested the impact of using either only {TeleGates} or both. The evaluation results show that {TeleData} operations may have a positive impact on the number of consumed {EPR} pairs, while choosing a more connected network topology helps reduce the number of layers dedicated to remote operations.},
	pages = {1--13},
	journaltitle = {{IEEE} Transactions on Quantum Engineering},
	shortjournal = {{IEEE} Trans. Quantum Eng.},
	author = {Ferrari, Davide and Carretta, Stefano and Amoretti, Michele},
	urldate = {2024-09-13},
	date = {2023},
	eprinttype = {arxiv},
	eprint = {2305.02969 [quant-ph]},
	keywords = {Quantum Physics},
	file = {arXiv Fulltext PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\S4QEEL9P\\Ferrari et al. - 2023 - A Modular Quantum Compilation Framework for Distri.pdf:application/pdf;arXiv.org Snapshot:C\:\\Users\\bvvandervecht\\Zotero\\storage\\W7ABEH6E\\2305.html:text/html},
}

@article{stone_opencl_2010,
	title = {{OpenCL}: A Parallel Programming Standard for Heterogeneous Computing Systems},
	volume = {12},
	issn = {1521-9615},
	url = {https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2964860/},
	doi = {10.1109/MCSE.2010.69},
	shorttitle = {{OpenCL}},
	abstract = {We provide an overview of the key architectural features of recent microprocessor designs and describe the programming model and abstractions provided by {OpenCL}, a new parallel programming standard targeting these architectures.},
	pages = {66--72},
	number = {3},
	journaltitle = {Computing in science \& engineering},
	shortjournal = {Comput Sci Eng},
	author = {Stone, John E. and Gohara, David and Shi, Guochun},
	urldate = {2024-09-13},
	date = {2010-05},
	pmid = {21037981},
	pmcid = {PMC2964860},
	file = {PubMed Central Full Text PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\V28IFE7V\\Stone et al. - 2010 - OpenCL A Parallel Programming Standard for Hetero.pdf:application/pdf},
}

@inproceedings{menetrey_twine_2021,
	title = {Twine: An Embedded Trusted Runtime for {WebAssembly}},
	url = {http://arxiv.org/abs/2103.15860},
	doi = {10.1109/ICDE51399.2021.00025},
	shorttitle = {Twine},
	abstract = {{WebAssembly} is an increasingly popular lightweight binary instruction format, which can be efficiently embedded and sandboxed. Languages like C, C++, Rust, Go, and many others can be compiled into {WebAssembly}. This paper describes Twine, a {WebAssembly} trusted runtime designed to execute unmodified, language-independent applications. We leverage Intel {SGX} to build the runtime environment without dealing with language-specific, complex {APIs}. While {SGX} hardware provides secure execution within the processor, Twine provides a secure, sandboxed software runtime nested within an {SGX} enclave, featuring a {WebAssembly} system interface ({WASI}) for compatibility with unmodified {WebAssembly} applications. We evaluate Twine with a large set of general-purpose benchmarks and real-world applications. In particular, we used Twine to implement a secure, trusted version of {SQLite}, a well-known full-fledged embeddable database. We believe that such a trusted database would be a reasonable component to build many larger application services. Our evaluation shows that {SQLite} can be fully executed inside an {SGX} enclave via {WebAssembly} and existing system interface, with similar average performance overheads. We estimate that the performance penalties measured are largely compensated by the additional security guarantees and its full compatibility with standard {WebAssembly}. An in-depth analysis of our results indicates that performance can be greatly improved by modifying some of the underlying libraries. We describe and implement one such modification in the paper, showing up to \$4.1{\textbackslash}times\$ speedup. Twine is open-source, available at {GitHub} along with instructions to reproduce our experiments.},
	pages = {205--216},
	booktitle = {2021 {IEEE} 37th International Conference on Data Engineering ({ICDE})},
	author = {Ménétrey, Jämes and Pasin, Marcelo and Felber, Pascal and Schiavoni, Valerio},
	urldate = {2024-09-13},
	date = {2021-04},
	eprinttype = {arxiv},
	eprint = {2103.15860 [cs]},
	keywords = {Computer Science - Performance, Computer Science - Distributed, Parallel, and Cluster Computing, Computer Science - Cryptography and Security},
	file = {arXiv Fulltext PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\6TTHTZQ5\\Ménétrey et al. - 2021 - Twine An Embedded Trusted Runtime for WebAssembly.pdf:application/pdf;arXiv.org Snapshot:C\:\\Users\\bvvandervecht\\Zotero\\storage\\Y776WMFE\\2103.html:text/html},
}

@article{li_qasmbench_2023,
	title = {{QASMBench}: A Low-Level Quantum Benchmark Suite for {NISQ} Evaluation and Simulation},
	volume = {4},
	url = {https://dl.acm.org/doi/10.1145/3550488},
	doi = {10.1145/3550488},
	shorttitle = {{QASMBench}},
	abstract = {The rapid development of quantum computing ({QC}) in the {NISQ} era urgently demands a low-level benchmark suite and insightful evaluation metrics for characterizing the properties of prototype {NISQ} devices, the efficiency of {QC} programming compilers, schedulers and assemblers, and the capability of quantum system simulators in a classical computer. In this work, we fill this gap by proposing a low-level, easy-to-use benchmark suite called {QASMBench} based on the {OpenQASM} assembly representation. It consolidates commonly used quantum routines and kernels from a variety of domains including chemistry, simulation, linear algebra, searching, optimization, arithmetic, machine learning, fault tolerance, cryptography, and so on, trading-off between generality and usability. To analyze these kernels in terms of {NISQ} device execution, in addition to circuit width and depth, we propose four circuit metrics including gate density, retention lifespan, measurement density, and entanglement variance, to extract more insights about the execution efficiency, the susceptibility to {NISQ} error, and the potential gain from machine-specific optimizations. Applications in {QASMBench} can be launched and verified on several {NISQ} platforms, including {IBM}-Q, Rigetti, {IonQ} and Quantinuum. For evaluation, we measure the execution fidelity of a subset of {QASMBench} applications on 12 {IBM}-Q machines through density matrix state tomography, comprising 25K circuit evaluations. We also compare the fidelity of executions among the {IBM}-Q machines, the {IonQ} {QPU} and the Rigetti Aspen M-1 system. {QASMBench} is released at: .},
	pages = {10:1--10:26},
	number = {2},
	journaltitle = {{ACM} Transactions on Quantum Computing},
	author = {Li, Ang and Stein, Samuel and Krishnamoorthy, Sriram and Ang, James},
	urldate = {2024-09-13},
	date = {2023-02-24},
	file = {Full Text PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\Z4R2HYP7\\Li et al. - 2023 - QASMBench A Low-Level Quantum Benchmark Suite for.pdf:application/pdf},
}

@online{noauthor_protocol_nodate,
	title = {Protocol compilation: High-performance communication for parallel programs - {ProQuest}},
	url = {https://www.proquest.com/openview/a09ea07037657d727589a4a84284b17c/1?pq-origsite=gscholar&cbl=18750&diss=y},
	shorttitle = {Protocol compilation},
	abstract = {Explore millions of resources from scholarly journals, books, newspapers, videos and more, on the {ProQuest} Platform.},
	urldate = {2024-09-13},
	langid = {english},
	file = {Snapshot:C\:\\Users\\bvvandervecht\\Zotero\\storage\\4V2YA6GA\\1.html:text/html},
}

@article{steiger_projectq_2018,
	title = {{ProjectQ}: an open source software framework for quantum computing},
	volume = {2},
	url = {https://quantum-journal.org/papers/q-2018-01-31-49/},
	doi = {10.22331/q-2018-01-31-49},
	shorttitle = {{ProjectQ}},
	abstract = {Damian S. Steiger, Thomas Häner, and Matthias Troyer,
Quantum 2, 49 (2018).
We introduce {ProjectQ}, an open source software effort for quantum computing. The first release features a compiler framework capable of targeting various types of hardware, a high-performanc…},
	pages = {49},
	journaltitle = {Quantum},
	author = {Steiger, Damian S. and Häner, Thomas and Troyer, Matthias},
	urldate = {2024-09-13},
	date = {2018-01-31},
	langid = {british},
	note = {Publisher: Verein zur Förderung des Open Access Publizierens in den Quantenwissenschaften},
	file = {Full Text PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\ZXIUNLW5\\Steiger et al. - 2018 - ProjectQ an open source software framework for qu.pdf:application/pdf},
}

@misc{frey_programming_2021,
	title = {Programming the full stack of an open-access quantum computer},
	url = {http://arxiv.org/abs/2106.06549},
	doi = {10.48550/arXiv.2106.06549},
	abstract = {We present a new quantum programming language called "Quala" that enables true full-stack programming of quantum hardware. Quala allows seamless integration of abstraction layers such as the digital circuit layer and the analog control pulse waveform layer. Additionally, the language supports user-issued low-level hardware instructions like {FPGA} actions. Mid-circuit measurements and branching decision logic support real-time, adaptive programs. This flexibility allows users to write code for everything from quantum error correction to analog quantum simulation. The combination of a user-facing calibration database and a powerful symbolic algebra framework provides users with an unprecedented level of expressiveness and transparency. We display the salient characteristics of the language structure and describe how the accompanying compiler can translate programs written in any abstraction layer into precisely timed hardware commands. We intend for this language to bridge the gap between circuit-level programming and physical operations on real hardware while maintaining full transparency in each level of the stack. This eliminates the need for "behind-the-scenes" compilation and provides users with insights into the day-to-day calibration routines.},
	number = {{arXiv}:2106.06549},
	publisher = {{arXiv}},
	author = {Frey, Virginia and Rademacher, Richard and Durso-Sabina, Elijah and Greenberg, Noah and Videnov, Nikolay and Day, Matthew L. and Islam, Rajibul and Senko, Crystal},
	urldate = {2024-09-13},
	date = {2021-06-11},
	eprinttype = {arxiv},
	eprint = {2106.06549 [quant-ph]},
	keywords = {Quantum Physics},
	file = {arXiv Fulltext PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\7NIGB5JC\\Frey et al. - 2021 - Programming the full stack of an open-access quant.pdf:application/pdf;arXiv.org Snapshot:C\:\\Users\\bvvandervecht\\Zotero\\storage\\MVMTHQJ5\\2106.html:text/html},
}

@article{chong_programming_2017,
	title = {Programming languages and compiler design for realistic quantum hardware},
	volume = {549},
	rights = {2017 Macmillan Publishers Limited, part of Springer Nature. All rights reserved.},
	issn = {1476-4687},
	url = {https://www.nature.com/articles/nature23459},
	doi = {10.1038/nature23459},
	abstract = {Quantum computing sits at an important inflection point. For years, high-level algorithms for quantum computers have shown considerable promise, and recent advances in quantum device fabrication offer hope of utility. A gap still exists, however, between the hardware size and reliability requirements of quantum computing algorithms and the physical machines foreseen within the next ten years. To bridge this gap, quantum computers require appropriate software to translate and optimize applications (toolflows) and abstraction layers. Given the stringent resource constraints in quantum computing, information passed between layers of software and implementations will differ markedly from in classical computing. Quantum toolflows must expose more physical details between layers, so the challenge is to find abstractions that expose key details while hiding enough complexity.},
	pages = {180--187},
	number = {7671},
	journaltitle = {Nature},
	author = {Chong, Frederic T. and Franklin, Diana and Martonosi, Margaret},
	urldate = {2024-09-13},
	date = {2017-09},
	langid = {english},
	note = {Publisher: Nature Publishing Group},
	keywords = {Computer science, Software},
	file = {Full Text PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\AKAZ4UQF\\Chong et al. - 2017 - Programming languages and compiler design for real.pdf:application/pdf},
}

@misc{gokhale_optimized_2020,
	title = {Optimized Quantum Compilation for Near-Term Algorithms with {OpenPulse}},
	url = {http://arxiv.org/abs/2004.11205},
	doi = {10.48550/arXiv.2004.11205},
	abstract = {Quantum computers are traditionally operated by programmers at the granularity of a gate-based instruction set. However, the actual device-level control of a quantum computer is performed via analog pulses. We introduce a compiler that exploits direct control at this microarchitectural level to achieve significant improvements for quantum programs. Unlike quantum optimal control, our approach is bootstrapped from existing gate calibrations and the resulting pulses are simple. Our techniques are applicable to any quantum computer and realizable on current devices. We validate our techniques with millions of experimental shots on {IBM} quantum computers, controlled via the {OpenPulse} control interface. For representative benchmarks, our pulse control techniques achieve both 1.6x lower error rates and 2x faster execution time, relative to standard gate-based compilation. These improvements are critical in the near-term era of quantum computing, which is bottlenecked by error rates and qubit lifetimes.},
	number = {{arXiv}:2004.11205},
	publisher = {{arXiv}},
	author = {Gokhale, Pranav and Javadi-Abhari, Ali and Earnest, Nathan and Shi, Yunong and Chong, Frederic T.},
	urldate = {2024-09-13},
	date = {2020-05-08},
	eprinttype = {arxiv},
	eprint = {2004.11205 [quant-ph]},
	keywords = {Quantum Physics, Electrical Engineering and Systems Science - Systems and Control},
	file = {arXiv Fulltext PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\7JC4T7JK\\Gokhale et al. - 2020 - Optimized Quantum Compilation for Near-Term Algori.pdf:application/pdf;arXiv.org Snapshot:C\:\\Users\\bvvandervecht\\Zotero\\storage\\493946GJ\\2004.html:text/html},
}

@article{khammassi_openql_2021,
	title = {{OpenQL}: A Portable Quantum Programming Framework for Quantum Accelerators},
	volume = {18},
	issn = {1550-4832},
	url = {https://dl.acm.org/doi/10.1145/3474222},
	doi = {10.1145/3474222},
	shorttitle = {{OpenQL}},
	abstract = {With the potential of quantum algorithms to solve intractable classical problems, quantum computing is rapidly evolving, and more algorithms are being developed and optimized. Expressing these quantum algorithms using a high-level language and making them executable on a quantum processor while abstracting away hardware details is a challenging task. First, a quantum programming language should provide an intuitive programming interface to describe those algorithms. Then a compiler has to transform the program into a quantum circuit, optimize it, and map it to the target quantum processor respecting the hardware constraints such as the supported quantum operations, the qubit connectivity, and the control electronics limitations. In this article, we propose a quantum programming framework named {OpenQL}, which includes a high-level quantum programming language and its associated quantum compiler. We present the programming interface of {OpenQL}, we describe the different layers of the compiler and how we can provide portability over different qubit technologies. Our experiments show that {OpenQL} allows the execution of the same high-level algorithm on two different qubit technologies, namely superconducting qubits and Si-Spin qubits. Besides the executable code, {OpenQL} also produces an intermediate quantum assembly code, which is technology independent and can be simulated using the {QX} simulator.},
	pages = {13:1--13:24},
	number = {1},
	journaltitle = {J. Emerg. Technol. Comput. Syst.},
	author = {Khammassi, N. and Ashraf, I. and Someren, J. V. and Nane, R. and Krol, A. M. and Rol, M. A. and Lao, L. and Bertels, K. and Almudever, C. G.},
	urldate = {2024-09-13},
	date = {2021-12-20},
	file = {Full Text PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\XPT734HN\\Khammassi et al. - 2021 - OpenQL A Portable Quantum Programming Framework f.pdf:application/pdf},
}

@inproceedings{murali_noise-adaptive_2019,
	location = {New York, {NY}, {USA}},
	title = {Noise-Adaptive Compiler Mappings for Noisy Intermediate-Scale Quantum Computers},
	isbn = {978-1-4503-6240-5},
	url = {https://dl.acm.org/doi/10.1145/3297858.3304075},
	doi = {10.1145/3297858.3304075},
	series = {{ASPLOS} '19},
	abstract = {A massive gap exists between current quantum computing ({QC}) prototypes, and the size and scale required for many proposed {QC} algorithms. Current {QC} implementations are prone to noise and variability which affect their reliability, and yet with less than 80 quantum bits (qubits) total, they are too resource-constrained to implement error correction. The term Noisy Intermediate-Scale Quantum ({NISQ}) refers to these current and near-term systems of 1000 qubits or less. Given {NISQ}'s severe resource constraints, low reliability, and high variability in physical characteristics such as coherence time or error rates, it is of pressing importance to map computations onto them in ways that use resources efficiently and maximize the likelihood of successful runs. This paper proposes and evaluates backend compiler approaches to map and optimize high-level {QC} programs to execute with high reliability on {NISQ} systems with diverse hardware characteristics. Our techniques all start from an {LLVM} intermediate representation of the quantum program (such as would be generated from high-level {QC} languages like Scaffold) and generate {QC} executables runnable on the {IBM} Q public {QC} machine. We then use this framework to implement and evaluate several optimal and heuristic mapping methods. These methods vary in how they account for the availability of dynamic machine calibration data, the relative importance of various noise parameters, the different possible routing strategies, and the relative importance of compile-time scalability versus runtime success. Using real-system measurements, we show that fine grained spatial and temporal variations in hardware parameters can be exploited to obtain an average 2.9x (and up to 18x) improvement in program success rate over the industry standard {IBM} Qiskit compiler. Despite small qubit counts, {NISQ} systems will soon be large enough to demonstrate "quantum supremacy", i.e., an advantage over classical computing. Tools like ours provide significant improvements in program reliability and execution time, and offer high leverage in accelerating progress towards quantum supremacy.},
	pages = {1015--1029},
	booktitle = {Proceedings of the Twenty-Fourth International Conference on Architectural Support for Programming Languages and Operating Systems},
	publisher = {Association for Computing Machinery},
	author = {Murali, Prakash and Baker, Jonathan M. and Javadi-Abhari, Ali and Chong, Frederic T. and Martonosi, Margaret},
	urldate = {2024-09-13},
	date = {2019-04-04},
	file = {Full Text PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\5W95LH2E\\Murali et al. - 2019 - Noise-Adaptive Compiler Mappings for Noisy Interme.pdf:application/pdf},
}

@inproceedings{sonchack_lucid_2021,
	location = {New York, {NY}, {USA}},
	title = {Lucid: a language for control in the data plane},
	isbn = {978-1-4503-8383-7},
	url = {https://dl.acm.org/doi/10.1145/3452296.3472903},
	doi = {10.1145/3452296.3472903},
	series = {{SIGCOMM} '21},
	shorttitle = {Lucid},
	abstract = {Programmable switch hardware makes it possible to move fine-grained control logic inside the network data plane, improving performance for a wide range of applications. However, applications with integrated control are inherently hard to write in existing data-plane programming languages such as P4. This paper presents Lucid, a language that raises the level of abstraction for putting control functionality in the data plane. Lucid introduces abstractions that make it easy to write sophisticated data-plane applications with interleaved packet-handling and control logic, specialized type and syntax systems that prevent programmer bugs related to data-plane state, and an open-sourced compiler that translates Lucid programs into P4 optimized for the Intel Tofino. These features make Lucid general and easy to use, as we demonstrate by writing a suite of ten different data-plane applications in Lucid. Working prototypes take well under an hour to write, even for a programmer without prior Tofino experience, have around 10x fewer lines of code compared to P4, and compile efficiently to real hardware. In a stateful firewall written in Lucid, we find that moving control from a switch's {CPU} to its data-plane processor using Lucid reduces the latency of performance-sensitive operations by over 300X.},
	pages = {731--747},
	booktitle = {Proceedings of the 2021 {ACM} {SIGCOMM} 2021 Conference},
	publisher = {Association for Computing Machinery},
	author = {Sonchack, John and Loehr, Devon and Rexford, Jennifer and Walker, David},
	urldate = {2024-09-13},
	date = {2021-08-09},
	file = {Full Text PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\SP7ZWVV9\\Sonchack et al. - 2021 - Lucid a language for control in the data plane.pdf:application/pdf},
}

@misc{chareton_formal_2022,
	title = {Formal Methods for Quantum Programs: A Survey},
	url = {http://arxiv.org/abs/2109.06493},
	doi = {10.48550/arXiv.2109.06493},
	shorttitle = {Formal Methods for Quantum Programs},
	abstract = {While recent progress in quantum hardware open the door for significant speedup in certain key areas (cryptography, biology, chemistry, optimization, machine learning, etc), quantum algorithms are still hard to implement right, and the validation of such quantum programs is achallenge. Moreover, importing the testing and debugging practices at use in classical programming is extremely difficult in the quantum case, due to the destructive aspect of quantum measurement. As an alternative strategy, formal methods are prone to play a decisive role in the emerging field of quantum software. Recent works initiate solutions for problems occurring at every stage of the development process: high-level program design, implementation, compilation, etc. We review the induced challenges for an efficient use of formal methods in quantum computing and the current most promising research directions.},
	number = {{arXiv}:2109.06493},
	publisher = {{arXiv}},
	author = {Chareton, Christophe and Bardin, Sébastien and Lee, Dongho and Valiron, Benoît and Vilmart, Renaud and Xu, Zhaowei},
	urldate = {2024-09-13},
	date = {2022-04-08},
	eprinttype = {arxiv},
	eprint = {2109.06493 [cs]},
	keywords = {Computer Science - Programming Languages},
	file = {arXiv Fulltext PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\5LISGYDI\\Chareton et al. - 2022 - Formal Methods for Quantum Programs A Survey.pdf:application/pdf;arXiv.org Snapshot:C\:\\Users\\bvvandervecht\\Zotero\\storage\\5RKZVKTJ\\2109.html:text/html},
}

@article{smits_flowspec_2020,
	title = {{FlowSpec}: A declarative specification language for intra-procedural flow-Sensitive data-flow analysis},
	volume = {57},
	issn = {2590-1184},
	url = {https://www.sciencedirect.com/science/article/pii/S2590118419300474},
	doi = {10.1016/j.cola.2019.100924},
	shorttitle = {{FlowSpec}},
	abstract = {Data-flow analysis is the static analysis of programs to estimate their approximate run-time behavior or approximate intermediate run-time values. It is an integral part of modern language specifications and compilers. In the specification of static semantics of programming languages, the concept of data-flow allows the description of well-formedness such as definite assignment of a local variable before its first use. In the implementation of compiler back-ends, data-flow analyses inform optimizations. Data-flow analysis has an established theoretical foundation. What lags behind is implementations of data-flow analysis in compilers, which are usually ad-hoc. This makes such implementations difficult to extend and maintain. In previous work researchers have proposed higher-level formalisms suitable for whole-program analysis in a separate tool, incremental analysis within editors, or bound to a specific intermediate representation. In this paper, we present {FlowSpec}, an executable formalism for specification of data-flow analysis. {FlowSpec} is a domain-specific language that enables direct and concise specification of data-flow analysis for programming languages, designed to express flow-sensitive, intra-procedural analyses. We define the formal semantics of {FlowSpec} in terms of monotone frameworks. We describe the design of {FlowSpec} using examples of standard analyses. We also include a description of our implementation of {FlowSpec}. In a case study we evaluate {FlowSpec} with the static analyses for Green-Marl, a domain-specific programming language for graph analytics.},
	pages = {100924},
	journaltitle = {Journal of Computer Languages},
	shortjournal = {Journal of Computer Languages},
	author = {Smits, Jeff and Wachsmuth, Guido and Visser, Eelco},
	urldate = {2024-09-13},
	date = {2020-04-01},
	file = {ScienceDirect Snapshot:C\:\\Users\\bvvandervecht\\Zotero\\storage\\8CEBDXFV\\S2590118419300474.html:text/html},
}

@article{nishio_extracting_2020,
	title = {Extracting Success from {IBM}’s 20-Qubit Machines Using Error-Aware Compilation},
	volume = {16},
	issn = {1550-4832},
	url = {https://dl.acm.org/doi/10.1145/3386162},
	doi = {10.1145/3386162},
	abstract = {{NISQ} (Noisy, Intermediate-Scale Quantum) computing requires error mitigation to achieve meaningful computation. Our compilation tool development focuses on the fact that the error rates of individual qubits are not equal, with a goal of maximizing the success probability of real-world subroutines such as an adder circuit. We begin by establishing a metric for choosing among possible paths and circuit alternatives for executing gates between variables placed far apart within the processor, and test our approach on two {IBM} 20-qubit systems named Tokyo and Poughkeepsie. We find that a single-number metric describing the fidelity of individual gates is a useful but imperfect guide.Our compiler uses this subsystem and maps complete circuits onto the machine using a beam search-based heuristic that will scale as processor and program sizes grow. To evaluate the whole compilation process, we compiled and executed adder circuits, then calculated the Kullback–Leibler divergence ({KL}-divergence, a measure of the distance between two probability distributions). For a circuit within the capabilities of the hardware, our compilation increases estimated success probability and reduces {KL}-divergence relative to an error-oblivious placement.},
	pages = {32:1--32:25},
	number = {3},
	journaltitle = {J. Emerg. Technol. Comput. Syst.},
	author = {Nishio, Shin and Pan, Yulu and Satoh, Takahiko and Amano, Hideharu and Meter, Rodney Van},
	urldate = {2024-09-13},
	date = {2020-05-28},
	file = {Full Text PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\EQXLATDT\\Nishio et al. - 2020 - Extracting Success from IBM’s 20-Qubit Machines Us.pdf:application/pdf},
}

@inproceedings{peduri_qssa_2022,
	location = {New York, {NY}, {USA}},
	title = {{QSSA}: an {SSA}-based {IR} for Quantum computing},
	isbn = {978-1-4503-9183-2},
	url = {https://dl.acm.org/doi/10.1145/3497776.3517772},
	doi = {10.1145/3497776.3517772},
	series = {{CC} 2022},
	shorttitle = {{QSSA}},
	abstract = {Quantum computing hardware has progressed rapidly. Simultaneously, there has been a proliferation of programming languages and program optimization tools for quantum computing. Existing quantum compilers use intermediate representations ({IRs}) where quantum programs are described as circuits. Such {IRs} fail to leverage existing work on compiler optimizations. In such {IRs}, it is non-trivial to statically check for physical constraints such as the no-cloning theorem, which states that qubits cannot be copied. We introduce {QSSA}, a novel quantum {IR} based on static single assignment ({SSA}) that enables decades of research in compiler optimizations to be applied to quantum compilation. {QSSA} models quantum operations as being side-effect-free. The inputs and outputs of the operation are in one-to-one correspondence; qubits cannot be created or destroyed. As a result, our {IR} supports a static analysis pass that verifies no-cloning at compile-time. The quantum circuit is fully encoded within the def-use chain of the {IR}, allowing us to leverage existing optimization passes on {SSA} representations such as redundancy elimination and dead-code elimination. Running our {QSSA}-based compiler on the {QASMBench} and {IBM} Quantum Challenge datasets, we show that our optimizations perform comparably to {IBM}’s Qiskit quantum compiler infrastructure. {QSSA} allows us to represent, analyze, and transform quantum programs using the robust theory of {SSA} representations, bringing quantum compilation into the realm of well-understood theory and practice.},
	pages = {2--14},
	booktitle = {Proceedings of the 31st {ACM} {SIGPLAN} International Conference on Compiler Construction},
	publisher = {Association for Computing Machinery},
	author = {Peduri, Anurudh and Bhat, Siddharth and Grosser, Tobias},
	urldate = {2024-09-23},
	date = {2022-03-18},
	file = {Full Text PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\EUJBR3NU\\Peduri et al. - 2022 - QSSA an SSA-based IR for Quantum computing.pdf:application/pdf},
}

@article{ittah_enabling_2022,
	title = {Enabling Dataflow Optimization for Quantum Programs},
	volume = {3},
	issn = {2643-6809, 2643-6817},
	url = {http://arxiv.org/abs/2101.11030},
	doi = {10.1145/3491247},
	abstract = {We propose an {IR} for quantum computing that directly exposes quantum and classical data dependencies for the purpose of optimization. The Quantum Intermediate Representation for Optimization ({QIRO}) consists of two dialects, one input dialect and one that is specifically tailored to enable quantum-classical co-optimization. While the first employs a perhaps more intuitive memory-semantics (quantum operations act as side-effects), the latter uses value-semantics (operations consume and produce states). Crucially, this encodes the dataflow directly in the {IR}, allowing for a host of optimizations that leverage dataflow analysis. We discuss how to map existing quantum programming languages to the input dialect and how to lower the resulting {IR} to the optimization dialect. We present a prototype implementation based on {MLIR} that includes several quantum-specific optimization passes. Our benchmarks show that significant improvements in resource requirements are possible even through static optimization. In contrast to circuit optimization at run time, this is achieved while incurring only a small constant overhead in compilation time, making this a compelling approach for quantum program optimization at application scale.},
	pages = {1--32},
	number = {3},
	journaltitle = {{ACM} Transactions on Quantum Computing},
	shortjournal = {{ACM} Transactions on Quantum Computing},
	author = {Ittah, David and Häner, Thomas and Kliuchnikov, Vadym and Hoefler, Torsten},
	urldate = {2024-09-23},
	date = {2022-09-30},
	eprinttype = {arxiv},
	eprint = {2101.11030 [quant-ph]},
	keywords = {Computer Science - Emerging Technologies, Computer Science - Programming Languages, D.3.4, Quantum Physics},
	file = {arXiv Fulltext PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\QR7D8YSU\\Ittah et al. - 2022 - Enabling Dataflow Optimization for Quantum Program.pdf:application/pdf;arXiv.org Snapshot:C\:\\Users\\bvvandervecht\\Zotero\\storage\\2RBFE6HS\\2101.html:text/html},
}

@article{nguyen_retargetable_2022,
	title = {Retargetable Optimizing Compilers for Quantum Accelerators via a Multilevel Intermediate Representation},
	volume = {42},
	issn = {1937-4143},
	url = {https://ieeexplore.ieee.org/abstract/document/9795194},
	doi = {10.1109/MM.2022.3179654},
	abstract = {We present a multilevel quantum–classical intermediate representation ({IR}) that enables an optimizing, retargetable compiler for available quantum languages. Our work builds upon the multilevel intermediate representation ({MLIR}) framework and leverages its unique progressive lowering capabilities to map quantum languages to the low-level virtual machine ({LLVM}) machine-level {IR}. We provide both quantum and classical optimizations via the {MLIR} pattern rewriting subsystem and standard {LLVM} optimization passes, and demonstrate the programmability, compilation, and execution of our approach via standard benchmarks and test cases. In comparison to other standalone language and compiler efforts available today, our work results in compile times that are 1,000× faster than standard Pythonic approaches, and 5–10× faster than comparative standalone quantum language compilers. Our compiler provides quantum resource optimizations via standard programming patterns that result in a 10× reduction in entangling operations, a common source of program noise. We see this work as a vehicle for rapid quantum compiler prototyping.},
	pages = {17--33},
	number = {5},
	journaltitle = {{IEEE} Micro},
	author = {Nguyen, Thien and {McCaskey}, Alexander},
	urldate = {2024-09-23},
	date = {2022-09},
	note = {Conference Name: {IEEE} Micro},
	keywords = {Accelerators, Codes, Computational modeling, Multilevel systems, Optimization, Program processors, programming languages, quantum computing, quantum programming, Qubit, Runtime, Runtime library},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\bvvandervecht\\Zotero\\storage\\P489PC8T\\9795194.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\NIVUGWJV\\Nguyen and McCaskey - 2022 - Retargetable Optimizing Compilers for Quantum Acce.pdf:application/pdf},
}

@article{fux_quingo_2021,
	title = {Quingo: A Programming Framework for Heterogeneous Quantum-Classical Computing with {NISQ} Features},
	rights = {Permission to make digital or hard copies of part or all of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for third-party components of this work must be honored. For all other uses, contact the owner/author(s).},
	url = {https://dl.acm.org/doi/10.1145/3483528},
	doi = {10.1145/3483528},
	shorttitle = {Quingo},
	abstract = {The increasing control complexity of Noisy Intermediate-Scale Quantum ({NISQ}) systems
underlines the necessity of integrating quantum hardware with quantum software. While
mapping heterogeneous quantum-classical computing ({HQCC}) algorithms to {NISQ} hardware
...},
	journaltitle = {{ACM} Transactions on Quantum Computing},
	author = {{FuX} and {YuJintao} and {SuXing} and {JiangHanru} and {WuHua} and {ChengFucheng} and {DengXi} and {ZhangJinrong} and {JinLei} and {YangYihang} and {XuLe} and {HuChunchao} and {HuangAnqi} and {HuangGuangyao} and {QiangXiaogang} and {DengMingtang} and {XuPing} and {XuWeixia} and {LiuWanwei} and {ZhangYu} and {DengYuxin} and {WuJunjie} and {FengYuan}},
	urldate = {2024-08-13},
	date = {2021-12-21},
	note = {Publisher: {ACMPUB}27New York, {NY}},
	file = {Full Text:C\:\\Users\\bvvandervecht\\Zotero\\storage\\2DJ3CKRR\\FuX et al. - 2021 - Quingo A Programming Framework for Heterogeneous .pdf:application/pdf;Snapshot:C\:\\Users\\bvvandervecht\\Zotero\\storage\\39FJCQTS\\3483528.html:text/html},
}

@online{geller_introducing_2020,
	title = {Introducing Quantum Intermediate Representation ({QIR})},
	url = {https://devblogs.microsoft.com/qsharp/introducing-quantum-intermediate-representation-qir/},
	abstract = {{QIR} is a Microsoft-led intermediate representation for quantum programs. This post describes {QIR} and provides pointers to the specification and source code.},
	titleaddon = {Q\# Blog},
	author = {Geller, Alan},
	urldate = {2024-09-23},
	date = {2020-09-23},
	langid = {american},
	file = {Snapshot:C\:\\Users\\bvvandervecht\\Zotero\\storage\\FBRXXM83\\introducing-quantum-intermediate-representation-qir.html:text/html},
}

@misc{vazquez-perez_netqir_2024,
	title = {{NetQIR}: An Extension of {QIR} for Distributed Quantum Computing},
	url = {http://arxiv.org/abs/2408.03712},
	doi = {10.48550/arXiv.2408.03712},
	shorttitle = {{NetQIR}},
	abstract = {The rapid advance of quantum computing has highlighted the need for scalable and efficient software infrastructures to fully exploit its potential. While current quantum processors have significant scalability problems due to the limited number of qubits on each chip, distributed quantum computing offers a promising solution by networking multiple Quantum Processing Units ({QPUs}). To support this paradigm, robust Intermediate Representations ({IRs}) are crucial for translating high-level quantum algorithms into executable instructions across distributed systems. This paper introduces {NetQIR}, an extension of Microsoft's Quantum Intermediate Representation ({QIR}), specifically designed for distributed quantum computing. {NetQIR} is designed to meet the specific needs of distributed quantum systems by incorporating functions to manage quantum and classical communications between {QPUs}. The main objective is to facilitate the development of new distributed compilers by improving the integration and execution of quantum programmes in a distributed infrastructure, taking advantage of modular architectures to improve scalability. By extending {QIR} to support distributed quantum computing, {NetQIR} aims to complement and add capabilities to an already supported quantum {IR} and, at the same time, take advantage of the tools previously created for {QIR}. Throughout this paper the specification of the intermediate representation is introduced, including the basic instructions necessary to enable distributed quantum computing in an abstract form independent of the target machine.},
	number = {{arXiv}:2408.03712},
	publisher = {{arXiv}},
	author = {Vázquez-Pérez, Jorge and Cardama, F. Javier and Piñeiro, César and Pena, Tomás F. and Pichel, Juan C. and Gómez, Andrés},
	urldate = {2024-09-23},
	date = {2024-08-07},
	eprinttype = {arxiv},
	eprint = {2408.03712 [quant-ph]},
	keywords = {Quantum Physics},
	file = {arXiv Fulltext PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\EXSMNU8L\\Vázquez-Pérez et al. - 2024 - NetQIR An Extension of QIR for Distributed Quantu.pdf:application/pdf;arXiv.org Snapshot:C\:\\Users\\bvvandervecht\\Zotero\\storage\\IJBX4F3A\\2408.html:text/html},
}

@article{ferrari_compiler_2021,
	title = {Compiler Design for Distributed Quantum Computing},
	volume = {2},
	issn = {2689-1808},
	url = {https://ieeexplore.ieee.org/abstract/document/9334411},
	doi = {10.1109/TQE.2021.3053921},
	abstract = {In distributed quantum computing architectures, with the network and communications functionalities provided by the Quantum Internet, remote quantum processing units can communicate and cooperate for executing computational tasks that single, noisy, intermediate-scale quantum devices cannot handle by themselves. To this aim, distributed quantum computing requires a new generation of quantum compilers, for mapping any quantum algorithm to any distributed quantum computing architecture. With this perspective, in this article, we first discuss the main challenges arising with compiler design for distributed quantum computing. Then, we analytically derive an upper bound of the overhead induced by quantum compilation for distributed quantum computing. The derived bound accounts for the overhead induced by the underlying computing architecture as well as the additional overhead induced by the suboptimal quantum compiler—expressly designed in this article to achieve three key features, namely, general-purpose, efficient, and effective. Finally, we validate the analytical results, and we confirm the validity of the compiler design through an extensive performance analysis.},
	pages = {1--20},
	journaltitle = {{IEEE} Transactions on Quantum Engineering},
	author = {Ferrari, Davide and Cacciapuoti, Angela Sara and Amoretti, Michele and Caleffi, Marcello},
	urldate = {2024-08-08},
	date = {2021},
	note = {Conference Name: {IEEE} Transactions on Quantum Engineering},
	keywords = {Computer architecture, Distributed quantum computing, distributed quantum systems, Integrated circuit modeling, Logic gates, Quantum circuit, quantum compiling, Quantum computing, quantum Internet, quantum networks, Qubit, Task analysis},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\bvvandervecht\\Zotero\\storage\\5DFYF4SI\\9334411.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\ULARMCDC\\Ferrari et al. - 2021 - Compiler Design for Distributed Quantum Computing.pdf:application/pdf},
}

@inproceedings{parekh_quantum_2021,
	title = {Quantum Algorithms and Simulation for Parallel and Distributed Quantum Computing},
	url = {https://ieeexplore.ieee.org/abstract/document/9651415},
	doi = {10.1109/QCS54837.2021.00005},
	abstract = {A viable approach for building large-scale quantum computers is to interlink small-scale quantum computers with a quantum network to create a larger distributed quantum computer. When designing quantum algorithms for such a distributed quantum computer, one can make use of the added parallelization and distribution abilities inherent in the system. An added difficulty to then overcome for distributed quantum computing is that a complex control system to orchestrate the various components is required. In this work, we aim to address these issues. We explicitly define what it means for a quantum algorithm to be distributed and then present various quantum algorithms that fit the definition. We discuss potential benefits and propose a high-level scheme for controlling the system. With this, we present our software framework called Interlin-q, a simulation platform that aims to simplify designing and verifying parallel and distributed quantum algorithms. We demonstrate Interlin-q by implementing some of the discussed algorithms using Interlin-q and layout future steps for developing Interlin-q into a control system for distributed quantum computers.},
	eventtitle = {2021 {IEEE}/{ACM} Second International Workshop on Quantum Computing Software ({QCS})},
	pages = {9--19},
	booktitle = {2021 {IEEE}/{ACM} Second International Workshop on Quantum Computing Software ({QCS})},
	author = {Parekh, Rhea and Ricciardi, Andrea and Darwish, Ahmed and {DiAdamo}, Stephen},
	urldate = {2024-08-19},
	date = {2021-11},
	keywords = {Distributed quantum computing, Quantum computing, Computers, Quantum algorithm, Software algorithms, Computational modeling, quantum software, Conferences, distributed quantum algorithms, networked control systems, Networked control systems},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\bvvandervecht\\Zotero\\storage\\Z7HUGULN\\9651415.html:text/html;Submitted Version:C\:\\Users\\bvvandervecht\\Zotero\\storage\\Q5ZHBPP9\\Parekh et al. - 2021 - Quantum Algorithms and Simulation for Parallel and.pdf:application/pdf},
}

@misc{wang_verification_2021,
	title = {Verification of Distributed Quantum Protocols},
	url = {http://arxiv.org/abs/2110.11416},
	doi = {10.48550/arXiv.2110.11416},
	abstract = {Truly concurrent process algebras are generalizations to the traditional process algebras for true concurrency, {CTC} to {CCS}, {APTC} to {ACP}, \${\textbackslash}pi\_\{tc\}\$ to \${\textbackslash}pi\$ calculus, {APPTC} to probabilistic process algebra, {APTC} with localities to process algebra with localities. In quantum process algebras, there are several well-known work, and we ever did some work to unify quantum and classical computing under the framework of {ACP} {\textbackslash}cite\{{ACP}\} and probabilistic process algebra. Now, it is the time to utilize truly concurrent process algebras with localities to model quantum computing and unify quantum and classical computing in this book. Since this work is with localities, it is suitable to verify the distribution of quantum communication protocols.},
	number = {{arXiv}:2110.11416},
	publisher = {{arXiv}},
	author = {Wang, Yong},
	urldate = {2024-08-13},
	date = {2021-10-25},
	eprinttype = {arxiv},
	eprint = {2110.11416 [cs]},
	keywords = {Computer Science - Logic in Computer Science},
	file = {arXiv Fulltext PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\EEBSVBY8\\Wang - 2021 - Verification of Distributed Quantum Protocols.pdf:application/pdf;arXiv.org Snapshot:C\:\\Users\\bvvandervecht\\Zotero\\storage\\JNWW5FR7\\2110.html:text/html},
}

@article{feng_verification_2022,
	title = {Verification of Distributed Quantum Programs},
	volume = {23},
	issn = {1529-3785},
	url = {https://dl.acm.org/doi/10.1145/3517145},
	doi = {10.1145/3517145},
	abstract = {Distributed quantum systems and especially the Quantum Internet have the ever-increasing potential to fully demonstrate the power of quantum computation. This is particularly true given that developing a general-purpose quantum computer is much more difficult than connecting many small quantum devices. One major challenge of implementing distributed quantum systems is programming them and verifying their correctness. In this paper, we propose a {CSP}-like distributed programming language to facilitate the specification and verification of such systems. After presenting its operational and denotational semantics, we develop a Hoare-style logic for distributed quantum programs and establish its soundness and (relative) completeness with respect to both partial and total correctness. The effectiveness of the logic is demonstrated by its applications in the verification of quantum teleportation and local implementation of non-local {CNOT} gates, two important algorithms widely used in distributed quantum systems.},
	pages = {19:1--19:40},
	number = {3},
	journaltitle = {{ACM} Trans. Comput. Logic},
	author = {Feng, Yuan and Li, Sanjiang and Ying, Mingsheng},
	urldate = {2024-08-13},
	date = {2022-04-06},
	file = {Full Text PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\PXC54SJT\\Feng et al. - 2022 - Verification of Distributed Quantum Programs.pdf:application/pdf},
}

@misc{tang_scaleqc_2022,
	title = {{ScaleQC}: A Scalable Framework for Hybrid Computation on Quantum and Classical Processors},
	url = {http://arxiv.org/abs/2207.00933},
	doi = {10.48550/arXiv.2207.00933},
	shorttitle = {{ScaleQC}},
	abstract = {Quantum processing unit ({QPU}) has to satisfy highly demanding quantity and quality requirements on its qubits to produce accurate results for problems at useful scales. Furthermore, classical simulations of quantum circuits generally do not scale. Instead, quantum circuit cutting techniques cut and distribute a large quantum circuit into multiple smaller subcircuits feasible for less powerful {QPUs}. However, the classical post-processing incurred from the cutting introduces runtime and memory bottlenecks. Our tool, called {ScaleQC}, addresses the bottlenecks by developing novel algorithmic techniques including (1) a quantum states merging framework that quickly locates the solution states of large quantum circuits; (2) an automatic solver that cuts complex quantum circuits to fit on less powerful {QPUs}; and (3) a tensor network based post-processing that minimizes the classical overhead. Our experiments demonstrate both {QPU} requirement advantages over the purely quantum platforms, and runtime advantages over the purely classical platforms for benchmarks up to 1000 qubits.},
	number = {{arXiv}:2207.00933},
	publisher = {{arXiv}},
	author = {Tang, Wei and Martonosi, Margaret},
	urldate = {2024-08-13},
	date = {2022-07-02},
	eprinttype = {arxiv},
	eprint = {2207.00933 [quant-ph]},
	keywords = {Quantum Physics, Computer Science - Emerging Technologies},
	file = {arXiv Fulltext PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\5IBEEZSV\\Tang and Martonosi - 2022 - ScaleQC A Scalable Framework for Hybrid Computati.pdf:application/pdf;arXiv.org Snapshot:C\:\\Users\\bvvandervecht\\Zotero\\storage\\XACUB6VZ\\2207.html:text/html},
}

@article{chatterjee_qurzon_2022,
	title = {Qurzon: A Prototype for a Divide and Conquer-Based Quantum Compiler for Distributed Quantum Systems},
	volume = {3},
	issn = {2661-8907},
	url = {https://doi.org/10.1007/s42979-022-01207-9},
	doi = {10.1007/s42979-022-01207-9},
	shorttitle = {Qurzon},
	abstract = {When working with algorithms on quantum devices, quantum memory becomes a crucial bottleneck due to low qubit count in {NISQ}-era devices. In this context, the concept of ‘divide and compute’, wherein a quantum circuit is broken into several subcircuits and executed separately, while stitching the results of the circuits via classical post-processing, becomes a viable option, especially in {NISQ}-era devices. This paper introduces Qurzon, a proposed novel quantum compiler that incorporates the marriage of techniques of divide and compute with the state-of-the-art algorithms of optimal qubit placement for executing on real quantum devices. A scheduling algorithm is also introduced within the compiler that can explore the power of distributed quantum computing while paving the way for quantum parallelism for large algorithms. Several benchmark circuits have been executed using the compiler, thereby demonstrating the power of the divide and compute when working with real {NISQ}-era quantum devices.},
	pages = {323},
	number = {4},
	journaltitle = {{SN} Computer Science},
	shortjournal = {{SN} {COMPUT}. {SCI}.},
	author = {Chatterjee, Turbasu and Das, Arnav and Mohtashim, Shah Ishmam and Saha, Amit and Chakrabarti, Amlan},
	urldate = {2024-08-13},
	date = {2022-06-10},
	langid = {english},
	keywords = {Quantum computing, Compilers, Conquer, Distributed systems, Divide},
	file = {Full Text PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\A4I4BCVW\\Chatterjee et al. - 2022 - Qurzon A Prototype for a Divide and Conquer-Based.pdf:application/pdf},
}

@article{cuomo_optimized_2023,
	title = {Optimized Compiler for Distributed Quantum Computing},
	volume = {4},
	url = {https://dl.acm.org/doi/10.1145/3579367},
	doi = {10.1145/3579367},
	abstract = {Practical distributed quantum computing requires the development of efficient compilers, able to make quantum circuits compatible with some given hardware constraints. This problem is known to be tough, even for local computing. Here, we address it on distributed architectures. As generally assumed in this scenario, telegates represent the fundamental remote (inter-processor) operations. Each telegate consists of several tasks: (i) entanglement generation and distribution, (ii) local operations, and (iii) classical communications. Entanglement generations and distribution is an expensive resource, as it is time-consuming. To mitigate its impact, we model an optimization problem that combines running-time minimization with the usage of distributed entangled states. Specifically, we formulated the distributed compilation problem as a dynamic network flow. To enhance the solution space, we extend the formulation, by introducing a predicate that manipulates the circuit given in input and parallelizes telegate tasks.To evaluate our framework, we split the problem into three sub-problems, and solve it by means of an approximation routine. Experiments demonstrate that the run-time is resistant to the problem size scaling. Moreover, we apply the proposed algorithm to compile circuits under different topologies, showing that topologies with a higher ratio between edges and nodes give rise to shallower circuits.},
	pages = {15:1--15:29},
	number = {2},
	journaltitle = {{ACM} Transactions on Quantum Computing},
	author = {Cuomo, Daniele and Caleffi, Marcello and Krsulich, Kevin and Tramonto, Filippo and Agliardi, Gabriele and Prati, Enrico and Cacciapuoti, Angela Sara},
	urldate = {2024-08-13},
	date = {2023-02-24},
	file = {Full Text PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\HKFC5677\\Cuomo et al. - 2023 - Optimized Compiler for Distributed Quantum Computi.pdf:application/pdf},
}

@inproceedings{haner_distributed_2021,
	location = {New York, {NY}, {USA}},
	title = {Distributed quantum computing with {QMPI}},
	isbn = {978-1-4503-8442-1},
	url = {https://dl.acm.org/doi/10.1145/3458817.3476172},
	doi = {10.1145/3458817.3476172},
	series = {{SC} '21},
	abstract = {Practical applications of quantum computers require millions of physical qubits and it will be challenging for individual quantum processors to reach such qubit numbers. It is therefore timely to investigate the resource requirements of quantum algorithms in a distributed setting, where multiple quantum processors are interconnected by a coherent network. We introduce an extension of the Message Passing Interface ({MPI}) to enable high-performance implementations of distributed quantum algorithms. In turn, these implementations can be used for testing, debugging, and resource estimation. In addition to a prototype implementation of quantum {MPI}, we present a performance model for distributed quantum computing, {SENDQ}. The model is inspired by the classical {LogP} model, making it useful to inform algorithmic decisions when programming distributed quantum computers. Specifically, we consider several optimizations of two quantum algorithms for problems in physics and chemistry, and we detail their effects on performance in the {SENDQ} model.},
	pages = {1--13},
	booktitle = {Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis},
	publisher = {Association for Computing Machinery},
	author = {Häner, Thomas and Steiger, Damian S. and Hoefler, Torsten and Troyer, Matthias},
	urldate = {2024-08-23},
	date = {2021-11-13},
	file = {Full Text PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\Y7WKI4GW\\Häner et al. - 2021 - Distributed quantum computing with QMPI.pdf:application/pdf},
}

@article{diadamo_distributed_2021,
	title = {Distributed Quantum Computing and Network Control for Accelerated {VQE}},
	volume = {2},
	issn = {2689-1808},
	url = {https://ieeexplore.ieee.org/abstract/document/9351762},
	doi = {10.1109/TQE.2021.3057908},
	abstract = {Interconnecting small quantum computers will be essential in the future for creating large-scale, robust quantum computers. Methods for distributing monolithic quantum algorithms efficiently are, thus, needed. In this article, we consider an approach for distributing the accelerated variational quantum eigensolver algorithm over arbitrary sized—in terms of number of qubits—distributed quantum computers. We consider approaches for distributing qubit assignments of the Ansatz states required to estimate the expectation value of Hamiltonian operators in quantum chemistry in a parallelized computation and provide a systematic approach to generate distributed quantum circuits for distributed quantum computing. Moreover, we propose an architecture for a distributed quantum control system in the context of centralized and decentralized network control.},
	pages = {1--21},
	journaltitle = {{IEEE} Transactions on Quantum Engineering},
	author = {{DiAdamo}, Stephen and Ghibaudi, Marco and Cruise, James},
	urldate = {2024-08-23},
	date = {2021},
	note = {Conference Name: {IEEE} Transactions on Quantum Engineering},
	keywords = {Distributed quantum computing, Logic gates, Quantum computing, Qubit, Computers, Hardware, Quantum algorithm, Control systems, network control, quantum multicomputing, variational quantum eigensolver},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\bvvandervecht\\Zotero\\storage\\JZ55BFEJ\\9351762.html:text/html;IEEE Xplore Full Text PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\AFFJH3QW\\DiAdamo et al. - 2021 - Distributed Quantum Computing and Network Control .pdf:application/pdf},
}

@incollection{hutchison_runtime_2012,
	location = {Berlin, Heidelberg},
	title = {A Runtime Environment for Distributed Mashups in Multi-device Scenarios},
	volume = {7513},
	isbn = {978-3-642-35605-6 978-3-642-35606-3},
	url = {http://link.springer.com/10.1007/978-3-642-35606-3_63},
	abstract = {Multi-device scenarios pave the way for new applications that allow the user to interact collaboratively with other users or enhance the interaction through the combination of different devices. To realize such applications, a new development paradigm is needed. Traditional methods do not support the dynamic extension or alteration of the application's feature set. Our approach is based on the idea of modeling the composition and distribution of several application components, so that the component implementations and their assignment to specific execution environments (component distribution) can be determined dynamically. All application components are linked together as an overlay network in the context of the multi-device environment. Therefore, we propose an architecture of a runtime environment and an overview of the component distribution process during the load-time of a multi-device mashup.},
	pages = {532--541},
	booktitle = {Network and Parallel Computing},
	publisher = {Springer Berlin Heidelberg},
	author = {Mroß, Oliver and Meißner, Klaus},
	editor = {Park, James J. and Zomaya, Albert and Yeo, Sang-Soo and Sahni, Sartaj},
	editorb = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Doug and Vardi, Moshe Y. and Weikum, Gerhard},
	editorbtype = {redactor},
	urldate = {2024-09-10},
	date = {2012},
	langid = {english},
	doi = {10.1007/978-3-642-35606-3_63},
	note = {Series Title: Lecture Notes in Computer Science},
	file = {Mroß and Meißner - 2012 - A Runtime Environment for Distributed Mashups in M.pdf:C\:\\Users\\bvvandervecht\\Zotero\\storage\\SM7XULZX\\Mroß and Meißner - 2012 - A Runtime Environment for Distributed Mashups in M.pdf:application/pdf},
}

@article{caleffi_distributed_2024,
	title = {Distributed quantum computing: A survey},
	volume = {254},
	issn = {1389-1286},
	url = {https://www.sciencedirect.com/science/article/pii/S1389128624005048},
	doi = {10.1016/j.comnet.2024.110672},
	shorttitle = {Distributed quantum computing},
	abstract = {Nowadays, quantum computing has reached the engineering phase, with fully-functional quantum processors integrating hundreds of noisy qubits. Yet – to fully unveil the potential of quantum computing out of the labs into the business reality – the challenge ahead is to substantially scale the qubit number, reaching orders of magnitude exceeding thousands of fault-tolerant qubits. To this aim, the distributed quantum computing paradigm is recognized as the key solution for scaling the number of qubits. Indeed, accordingly to such a paradigm, multiple small-to-moderate-scale quantum processors communicate and cooperate for executing computational tasks exceeding the computational power of single processing devices. The aim of this survey is to provide the reader with an overview about the main challenges and open problems arising with distributed quantum computing from a computer and communications engineering perspective. Furthermore, this survey provides an easy access and guide towards the relevant literature and the prominent results in the field.},
	pages = {110672},
	journaltitle = {Computer Networks},
	shortjournal = {Computer Networks},
	author = {Caleffi, Marcello and Amoretti, Michele and Ferrari, Davide and Illiano, Jessica and Manzalini, Antonio and Cacciapuoti, Angela Sara},
	urldate = {2024-09-13},
	date = {2024-12-01},
	keywords = {Distributed quantum computing, Quantum computing, Quantum networks, Quantum computation, Quantum algorithms, Quantum communications, Quantum compiler, Quantum compiling, Quantum internet, Simulator},
	file = {1-s2.0-S1389128624005048-main.pdf:C\:\\Users\\bartv\\Zotero\\storage\\HRGJ2UXW\\1-s2.0-S1389128624005048-main.pdf:application/pdf;ScienceDirect Snapshot:C\:\\Users\\bvvandervecht\\Zotero\\storage\\HRGJ2UXW\\S1389128624005048.html:text/html},
}

@article{ferrari_modular_2023,
	title = {A Modular Quantum Compilation Framework for Distributed Quantum Computing},
	volume = {4},
	issn = {2689-1808},
	url = {http://arxiv.org/abs/2305.02969},
	doi = {10.1109/TQE.2023.3303935},
	abstract = {For most practical applications, quantum algorithms require large resources in terms of qubit number, much larger than those available with current {NISQ} processors. With the network and communication functionalities provided by the Quantum Internet, Distributed Quantum Computing ({DQC}) is considered as a scalable approach for increasing the number of available qubits for computational tasks. For {DQC} to be effective and efficient, a quantum compiler must find the best partitioning for the quantum algorithm and then perform smart remote operation scheduling to optimize {EPR} pair consumption. At the same time, the quantum compiler should also find the best local transformation for each partition. In this paper we present a modular quantum compilation framework for {DQC} that takes into account both network and device constraints and characteristics. We implemented and tested a quantum compiler based on the proposed framework with some circuits of interest, such as the {VQE} and {QFT} ones, considering different network topologies, with quantum processors characterized by heavy hexagon coupling maps. We also devised a strategy for remote scheduling that can exploit both {TeleGate} and {TeleData} operations and tested the impact of using either only {TeleGates} or both. The evaluation results show that {TeleData} operations may have a positive impact on the number of consumed {EPR} pairs, while choosing a more connected network topology helps reduce the number of layers dedicated to remote operations.},
	pages = {1--13},
	journaltitle = {{IEEE} Transactions on Quantum Engineering},
	shortjournal = {{IEEE} Trans. Quantum Eng.},
	author = {Ferrari, Davide and Carretta, Stefano and Amoretti, Michele},
	urldate = {2024-09-13},
	date = {2023},
	eprinttype = {arxiv},
	eprint = {2305.02969 [quant-ph]},
	keywords = {Quantum Physics},
	file = {arXiv Fulltext PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\S4QEEL9P\\Ferrari et al. - 2023 - A Modular Quantum Compilation Framework for Distri.pdf:application/pdf;arXiv.org Snapshot:C\:\\Users\\bvvandervecht\\Zotero\\storage\\W7ABEH6E\\2305.html:text/html},
}

@inproceedings{ferrari_design_2024,
	location = {New York, {NY}, {USA}},
	title = {A Design Framework for the Simulation of Distributed Quantum Computing},
	isbn = {9798400706431},
	url = {https://dl.acm.org/doi/10.1145/3659996.3660035},
	doi = {10.1145/3659996.3660035},
	series = {{HPQCI} '24},
	abstract = {The growing demand for large-scale quantum computers is pushing research on Distributed Quantum Computing ({DQC}). Recent experimental efforts have demonstrated some of the building blocks for such a design. {DQC} systems are clusters of quantum processing units ({QPUs}) connected by means of quantum network infrastructures. Their extension ranges from the single box to the geographical scale. Furthermore, they can be integrated with classical High Performance Computing systems. Simulation modeling of {DQC} architectures provides a safe way to test and explore different what-if scenarios. Many simulation tools have been developed to support the research community in designing and evaluating quantum computer and quantum network technologies, including hardware, protocols, and applications. However, a framework for {DQC} simulation putting equal emphasis on computational and networking aspects has never been proposed, so far. In this paper, a design framework for {DQC} simulation is presented, whose core component is an Execution Manager that schedules {DQC} jobs for running on networked quantum computers. Two metrics are proposed for evaluating the impact of the job scheduling algorithms with respect to {QPU} utilization and quantum network utilization, beyond the traditional concept of makespan. The discussion is supported by a {DQC} job scheduling example, where two different strategies are compared in terms of the proposed metrics.},
	pages = {4--10},
	booktitle = {Proceedings of the 2024 Workshop on High Performance and Quantum Computing Integration},
	publisher = {Association for Computing Machinery},
	author = {Ferrari, Davide and Amoretti, Michele},
	urldate = {2024-09-13},
	date = {2024-08-30},
	file = {Full Text PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\9A9DIQ49\\Ferrari and Amoretti - 2024 - A Design Framework for the Simulation of Distribut.pdf:application/pdf},
}

@misc{vazquez-perez_netqir_2024,
	title = {{NetQIR}: An Extension of {QIR} for Distributed Quantum Computing},
	url = {http://arxiv.org/abs/2408.03712},
	doi = {10.48550/arXiv.2408.03712},
	shorttitle = {{NetQIR}},
	abstract = {The rapid advance of quantum computing has highlighted the need for scalable and efficient software infrastructures to fully exploit its potential. While current quantum processors have significant scalability problems due to the limited number of qubits on each chip, distributed quantum computing offers a promising solution by networking multiple Quantum Processing Units ({QPUs}). To support this paradigm, robust Intermediate Representations ({IRs}) are crucial for translating high-level quantum algorithms into executable instructions across distributed systems. This paper introduces {NetQIR}, an extension of Microsoft's Quantum Intermediate Representation ({QIR}), specifically designed for distributed quantum computing. {NetQIR} is designed to meet the specific needs of distributed quantum systems by incorporating functions to manage quantum and classical communications between {QPUs}. The main objective is to facilitate the development of new distributed compilers by improving the integration and execution of quantum programmes in a distributed infrastructure, taking advantage of modular architectures to improve scalability. By extending {QIR} to support distributed quantum computing, {NetQIR} aims to complement and add capabilities to an already supported quantum {IR} and, at the same time, take advantage of the tools previously created for {QIR}. Throughout this paper the specification of the intermediate representation is introduced, including the basic instructions necessary to enable distributed quantum computing in an abstract form independent of the target machine.},
	number = {{arXiv}:2408.03712},
	publisher = {{arXiv}},
	author = {Vázquez-Pérez, Jorge and Cardama, F. Javier and Piñeiro, César and Pena, Tomás F. and Pichel, Juan C. and Gómez, Andrés},
	urldate = {2024-09-23},
	date = {2024-08-07},
	eprinttype = {arxiv},
	eprint = {2408.03712 [quant-ph]},
	keywords = {Quantum Physics},
	file = {arXiv Fulltext PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\EXSMNU8L\\Vázquez-Pérez et al. - 2024 - NetQIR An Extension of QIR for Distributed Quantu.pdf:application/pdf;arXiv.org Snapshot:C\:\\Users\\bvvandervecht\\Zotero\\storage\\IJBX4F3A\\2408.html:text/html},
}

@article{bartoletti_timed_2017,
	title = {Timed Session Types},
	volume = {Volume 13, Issue 4},
	issn = {1860-5974},
	url = {https://lmcs.episciences.org/4133},
	doi = {10.23638/LMCS-13(4:25)2017},
	abstract = {Timed session types formalise timed communication protocols between two participants at the endpoints of a session. They feature a decidable compliance relation, which generalises to the timed setting the progress-based compliance between untimed session types. We show a sound and complete technique to decide when a timed session type admits a compliant one. Then, we show how to construct the most precise session type compliant with a given one, according to the subtyping preorder induced by compliance. Decidability of subtyping follows from these results.},
	journaltitle = {Logical Methods in Computer Science},
	author = {Bartoletti, Massimo and Cimoli, Tiziana and Murgia, Maurizio},
	urldate = {2024-08-08},
	date = {2017-12-08},
	note = {Publisher: Episciences.org},
	file = {Full Text PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\LHTRMVIG\\Bartoletti et al. - 2017 - Timed Session Types.pdf:application/pdf},
}

@inproceedings{bartoletti_compliance_2015,
	location = {Cham},
	title = {Compliance and Subtyping in Timed Session Types},
	isbn = {978-3-319-19195-9},
	doi = {10.1007/978-3-319-19195-9_11},
	abstract = {We propose an extension of binary session types, to formalise timed communication protocols between two participants at the endpoints of a session. We introduce a decidable compliance relation, which generalises to the timed setting the usual progress-based notion of compliance between untimed session types. We then show a sound and complete technique to decide when a timed session type admits a compliant one, and if so, to construct the least session type compliant with a given one, according to the subtyping preorder induced by compliance. Decidability of subtyping follows from these results. We exploit our theory to design and implement a message-oriented middleware, where distributed modules with compliant protocols can be dynamically composed, and their communications monitored, so to guarantee safe interactions.},
	pages = {161--177},
	booktitle = {Formal Techniques for Distributed Objects, Components, and Systems},
	publisher = {Springer International Publishing},
	author = {Bartoletti, Massimo and Cimoli, Tiziana and Murgia, Maurizio and Podda, Alessandro Sebastian and Pompianu, Livio},
	editor = {Graf, Susanne and Viswanathan, Mahesh},
	date = {2015},
	langid = {english},
	keywords = {Follow Theorem State, Runtime Monitoring, Service Composition, Session Type, Success State},
	file = {Full Text PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\R2KSIH9F\\Bartoletti et al. - 2015 - Compliance and Subtyping in Timed Session Types.pdf:application/pdf},
}

@inproceedings{bocchi_timed_2014,
	location = {Berlin, Heidelberg},
	title = {Timed Multiparty Session Types},
	isbn = {978-3-662-44584-6},
	doi = {10.1007/978-3-662-44584-6_29},
	abstract = {We propose a typing theory, based on multiparty session types, for modular verification of real-time choreographic interactions. To model real-time implementations, we introduce a simple calculus with delays and a decidable static proof system. The proof system ensures type safety and time-error freedom, namely processes respect the prescribed timing and causalities between interactions. A decidable condition on timed global types guarantees time-progress for validated processes with delays, and gives a sound and complete characterisation of a new class of {CTAs} with general topologies that enjoys progress and liveness.},
	pages = {419--434},
	booktitle = {{CONCUR} 2014 – Concurrency Theory},
	publisher = {Springer},
	author = {Bocchi, Laura and Yang, Weizhen and Yoshida, Nobuko},
	editor = {Baldan, Paolo and Gorla, Daniele},
	date = {2014},
	langid = {english},
	keywords = {Clock Constraint, Global Type, Proof Rule, Proof System, Ready Action},
	file = {Full Text PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\TLULUK25\\Bocchi et al. - 2014 - Timed Multiparty Session Types.pdf:application/pdf},
}

@article{gay_types_2006,
	title = {Types and typechecking for Communicating Quantum Processes},
	volume = {16},
	issn = {1469-8072, 0960-1295},
	url = {https://www.cambridge.org/core/journals/mathematical-structures-in-computer-science/article/types-and-typechecking-for-communicating-quantum-processes/1864228FD42E39441B68CEF69FB1E398#},
	doi = {10.1017/S0960129506005263},
	abstract = {We define a language {CQP} (Communicating Quantum Processes) for modelling systems that combine quantum and classical communication and computation. {CQP} combines the communication primitives of the pi-calculus with primitives for measurement and transformation of the quantum state; in particular, quantum bits (qubits) can be transmitted from process to process along communication channels. {CQP} has a static type system, which classifies channels, distinguishes between quantum and classical data, and controls the use of quantum states. We formally define the syntax, operational semantics and type system of {CQP}, prove that the semantics preserves typing, and prove that typing guarantees that each qubit is owned by a unique process within a system. We also define a typechecking algorithm and prove that it is sound and complete with respect to the type system. We illustrate {CQP} by defining models of several quantum communication systems, and outline our plans for using {CQP} as the foundation for formal analysis and verification of combined quantum and classical systems.},
	pages = {375--406},
	number = {3},
	journaltitle = {Mathematical Structures in Computer Science},
	author = {Gay, Simon J. and Nagarajan, Rajagopal},
	urldate = {2024-08-08},
	date = {2006-06},
	langid = {english},
	file = {Full Text PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\V7Q2WUUL\\Gay and Nagarajan - 2006 - Types and typechecking for Communicating Quantum P.pdf:application/pdf},
}

@article{ardeshir-larijani_automated_2018,
	title = {Automated Equivalence Checking of Concurrent Quantum Systems},
	volume = {19},
	issn = {1529-3785},
	url = {https://dl.acm.org/doi/10.1145/3231597},
	doi = {10.1145/3231597},
	abstract = {The novel field of quantum computation and quantum information has gathered significant momentum in the last few years. It has the potential to radically impact the future of information technology and influence the development of modern society. The construction of practical, general purpose quantum computers has been challenging, but quantum cryptographic and communication devices have been available in the commercial marketplace for several years. Quantum networks have been built in various cities around the world and a dedicated satellite has been launched by China to provide secure quantum communication. Such new technologies demand rigorous analysis and verification before they can be trusted in safety- and security-critical applications. Experience with classical hardware and software systems has shown the difficulty of achieving robust and reliable implementations.We present {CCSq}, a concurrent language for describing quantum systems, and develop verification techniques for checking equivalence between {CCSq} processes. {CCSq} has well-defined operational and superoperator semantics for protocols that are functional, in the sense of computing a deterministic input-output relation for all interleavings arising from concurrency in the system. We have implemented {QEC} (Quantum Equivalence Checker), a tool that takes the specification and implementation of quantum protocols, described in {CCSq}, and automatically checks their equivalence. {QEC} is the first fully automatic equivalence checking tool for concurrent quantum systems. For efficiency purposes, we restrict ourselves to Clifford operators in the stabilizer formalism, but we are able to verify protocols over all input states. We have specified and verified a collection of interesting and practical quantum protocols, ranging from quantum communication and quantum cryptography to quantum error correction.},
	pages = {28:1--28:32},
	number = {4},
	journaltitle = {{ACM} Trans. Comput. Logic},
	author = {Ardeshir-Larijani, Ebrahim and Gay, Simon J. and Nagarajan, Rajagopal},
	urldate = {2024-08-08},
	date = {2018-11-20},
	file = {Full Text PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\WT4978C7\\Ardeshir-Larijani et al. - 2018 - Automated Equivalence Checking of Concurrent Quant.pdf:application/pdf},
}

@article{honda_multiparty_2016,
	title = {Multiparty Asynchronous Session Types},
	volume = {63},
	issn = {0004-5411},
	url = {https://dl.acm.org/doi/10.1145/2827695},
	doi = {10.1145/2827695},
	abstract = {Communication is a central elements in software development. As a potential typed foundation for structured communication-centered programming, session types have been studied over the past decade for a wide range of process calculi and programming languages, focusing on binary (two-party) sessions. This work extends the foregoing theories of binary session types to multiparty, asynchronous sessions, which often arise in practical communication-centered applications. Presented as a typed calculus for mobile processes, the theory introduces a new notion of types in which interactions involving multiple peers are directly abstracted as a global scenario. Global types retain the friendly type syntax of binary session types while specifying dependencies and capturing complex causal chains of multiparty asynchronous interactions. A global type plays the role of a shared agreement among communication peers and is used as a basis of efficient type-checking through its projection onto individual peers. The fundamental properties of the session type discipline, such as communication safety, progress, and session fidelity, are established for general n-party asynchronous interactions.},
	pages = {9:1--9:67},
	number = {1},
	journaltitle = {J. {ACM}},
	author = {Honda, Kohei and Yoshida, Nobuko and Carbone, Marco},
	urldate = {2024-08-08},
	date = {2016-03-03},
	file = {Full Text PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\LUUEPEJR\\Honda et al. - 2016 - Multiparty Asynchronous Session Types.pdf:application/pdf},
}

@article{kreppel_quantum_2023,
	title = {Quantum Circuit Compiler for a Shuttling-Based Trapped-Ion Quantum Computer},
	volume = {7},
	url = {https://quantum-journal.org/papers/q-2023-11-08-1176/},
	doi = {10.22331/q-2023-11-08-1176},
	abstract = {Fabian Kreppel, Christian Melzer, Diego Olvera Millán, Janis Wagner, Janine Hilder, Ulrich Poschinger, Ferdinand Schmidt-Kaler, and André Brinkmann,
Quantum 7, 1176 (2023).
The increasing capabilities of quantum computing hardware and the challenge of realizing deep quantum circuits require fully automated and efficient tools for compiling quantum circuits. To…},
	pages = {1176},
	journaltitle = {Quantum},
	author = {Kreppel, Fabian and Melzer, Christian and Millán, Diego Olvera and Wagner, Janis and Hilder, Janine and Poschinger, Ulrich and Schmidt-Kaler, Ferdinand and Brinkmann, André},
	urldate = {2024-08-08},
	date = {2023-11-08},
	langid = {british},
	note = {Publisher: Verein zur Förderung des Open Access Publizierens in den Quantenwissenschaften},
	file = {Full Text PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\WCXX8MJX\\Kreppel et al. - 2023 - Quantum Circuit Compiler for a Shuttling-Based Tra.pdf:application/pdf},
}

@article{unruh_quantum_2019,
	title = {Quantum relational Hoare logic},
	volume = {3},
	url = {https://dl.acm.org/doi/10.1145/3290346},
	doi = {10.1145/3290346},
	abstract = {We present a logic for reasoning about pairs of interactive quantum programs – quantum relational Hoare logic ({qRHL}). This logic follows the spirit of probabilistic relational Hoare logic (Barthe et al. 2009) and allows us to formulate how the outputs of two quantum programs relate given the relationship of their inputs. Probabilistic {RHL} was used extensively for computer-verified security proofs of classical cryptographic protocols. Since {pRHL} is not suitable for analyzing quantum cryptography, we present {qRHL} as a replacement, suitable for the security analysis of post-quantum cryptography and quantum protocols. The design of {qRHL} poses some challenges unique to the quantum setting, e.g., the definition of equality on quantum registers. Finally, we implemented a tool for verifying proofs in {qRHL} and developed several example security proofs in it.},
	pages = {33:1--33:31},
	issue = {{POPL}},
	journaltitle = {Verification tool for quantum relational Hoare Logic},
	shortjournal = {Proc. {ACM} Program. Lang.},
	author = {Unruh, Dominique},
	urldate = {2024-08-08},
	date = {2019-01-02},
	file = {Full Text PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\22CWJ6EP\\Unruh - 2019 - Quantum relational Hoare logic.pdf:application/pdf},
}

@article{hinrichsen_actris_2022,
	title = {Actris 2.0: Asynchronous Session-Type Based Reasoning in Separation Logic},
	volume = {Volume 18, Issue 2},
	issn = {1860-5974},
	url = {https://lmcs.episciences.org/9689},
	doi = {10.46298/lmcs-18(2:16)2022},
	shorttitle = {Actris 2.0},
	abstract = {Message passing is a useful abstraction for implementing concurrent programs. For real-world systems, however, it is often combined with other programming and concurrency paradigms, such as higher-order functions, mutable state, shared-memory concurrency, and locks. We present Actris: a logic for proving functional correctness of programs that use a combination of the aforementioned features. Actris combines the power of modern concurrent separation logics with a first-class protocol mechanism -- based on session types -- for reasoning about message passing in the presence of other concurrency paradigms. We show that Actris provides a suitable level of abstraction by proving functional correctness of a variety of examples, including a channel-based merge sort, a channel-based load-balancing mapper, and a variant of the map-reduce model, using concise specifications. While Actris was already presented in a conference paper ({POPL}'20), this paper expands the prior presentation significantly. Moreover, it extends Actris to Actris 2.0 with a notion of subprotocols -- based on session-type subtyping -- that permits additional flexibility when composing channel endpoints, and that takes full advantage of the asynchronous semantics of message passing in Actris. Soundness of Actris 2.0 is proven using a model of its protocol mechanism in the Iris framework. We have mechanised the theory of Actris, together with custom tactics, as well as all examples in the paper, in the Coq proof assistant.},
	journaltitle = {Logical Methods in Computer Science},
	author = {Hinrichsen, Jonas Kastberg and Bengtson, Jesper and Krebbers, Robbert},
	urldate = {2024-08-08},
	date = {2022-06-10},
	note = {Publisher: Episciences.org},
	file = {Full Text PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\Z7GBVXMP\\Hinrichsen et al. - 2022 - Actris 2.0 Asynchronous Session-Type Based Reason.pdf:application/pdf},
}

@article{davidson_model_nodate,
	title = {Model Checking for Communicating Quantum Processes},
	author = {Davidson, Tim and Gay, Simon J and Ik, Hynek Mlnarˇ and Nagarajan, Rajagopal and Papanikolaou, Nick},
	langid = {english},
	file = {Davidson et al. - Model Checking for Communicating Quantum Processes.pdf:C\:\\Users\\bvvandervecht\\Zotero\\storage\\LT6D8M4H\\Davidson et al. - Model Checking for Communicating Quantum Processes.pdf:application/pdf},
}

@misc{wang_verification_2021,
	title = {Verification of Distributed Quantum Protocols},
	url = {http://arxiv.org/abs/2110.11416},
	doi = {10.48550/arXiv.2110.11416},
	abstract = {Truly concurrent process algebras are generalizations to the traditional process algebras for true concurrency, {CTC} to {CCS}, {APTC} to {ACP}, \${\textbackslash}pi\_\{tc\}\$ to \${\textbackslash}pi\$ calculus, {APPTC} to probabilistic process algebra, {APTC} with localities to process algebra with localities. In quantum process algebras, there are several well-known work, and we ever did some work to unify quantum and classical computing under the framework of {ACP} {\textbackslash}cite\{{ACP}\} and probabilistic process algebra. Now, it is the time to utilize truly concurrent process algebras with localities to model quantum computing and unify quantum and classical computing in this book. Since this work is with localities, it is suitable to verify the distribution of quantum communication protocols.},
	number = {{arXiv}:2110.11416},
	publisher = {{arXiv}},
	author = {Wang, Yong},
	urldate = {2024-08-13},
	date = {2021-10-25},
	eprinttype = {arxiv},
	eprint = {2110.11416 [cs]},
	keywords = {Computer Science - Logic in Computer Science},
	file = {arXiv Fulltext PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\EEBSVBY8\\Wang - 2021 - Verification of Distributed Quantum Protocols.pdf:application/pdf;arXiv.org Snapshot:C\:\\Users\\bvvandervecht\\Zotero\\storage\\JNWW5FR7\\2110.html:text/html},
}

@article{feng_verification_2022,
	title = {Verification of Distributed Quantum Programs},
	volume = {23},
	issn = {1529-3785},
	url = {https://dl.acm.org/doi/10.1145/3517145},
	doi = {10.1145/3517145},
	abstract = {Distributed quantum systems and especially the Quantum Internet have the ever-increasing potential to fully demonstrate the power of quantum computation. This is particularly true given that developing a general-purpose quantum computer is much more difficult than connecting many small quantum devices. One major challenge of implementing distributed quantum systems is programming them and verifying their correctness. In this paper, we propose a {CSP}-like distributed programming language to facilitate the specification and verification of such systems. After presenting its operational and denotational semantics, we develop a Hoare-style logic for distributed quantum programs and establish its soundness and (relative) completeness with respect to both partial and total correctness. The effectiveness of the logic is demonstrated by its applications in the verification of quantum teleportation and local implementation of non-local {CNOT} gates, two important algorithms widely used in distributed quantum systems.},
	pages = {19:1--19:40},
	number = {3},
	journaltitle = {{ACM} Trans. Comput. Logic},
	author = {Feng, Yuan and Li, Sanjiang and Ying, Mingsheng},
	urldate = {2024-08-13},
	date = {2022-04-06},
	file = {Full Text PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\PXC54SJT\\Feng et al. - 2022 - Verification of Distributed Quantum Programs.pdf:application/pdf},
}

@inproceedings{ardeshir-larijani_verification_2014,
	location = {Berlin, Heidelberg},
	title = {Verification of Concurrent Quantum Protocols by Equivalence Checking},
	isbn = {978-3-642-54862-8},
	doi = {10.1007/978-3-642-54862-8_42},
	abstract = {We present a tool which uses a concurrent language for describing quantum systems, and performs verification by checking equivalence between specification and implementation. In general, simulation of quantum systems using current computing technology is infeasible. We restrict ourselves to the stabilizer formalism, in which there are efficient simulation algorithms. In particular, we consider concurrent quantum protocols that behave functionally in the sense of computing a deterministic input-output relation for all interleavings of the concurrent system. Crucially, these input-output relations can be abstracted by superoperators, enabling us to take advantage of linearity. This allows us to analyse the behaviour of protocols with arbitrary input, by simulating their operation on a finite basis set consisting of stabilizer states. Despite the limitations of the stabilizer formalism and also the range of protocols that can be analysed using this approach, we have applied our equivalence checking tool to specify and verify interesting and practical quantum protocols from teleportation to secret sharing.},
	pages = {500--514},
	booktitle = {Tools and Algorithms for the Construction and Analysis of Systems},
	publisher = {Springer},
	author = {Ardeshir-Larijani, Ebrahim and Gay, Simon J. and Nagarajan, Rajagopal},
	editor = {Ábrahám, Erika and Havelund, Klaus},
	date = {2014},
	langid = {english},
	keywords = {Density Operator, Equivalence Check, Model Check, Quantum State, Secret Sharing},
	file = {Full Text PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\M8GSMZHN\\Ardeshir-Larijani et al. - 2014 - Verification of Concurrent Quantum Protocols by Eq.pdf:application/pdf},
}

@inproceedings{ardeshir-larijani_equivalence_2013,
	location = {Berlin, Heidelberg},
	title = {Equivalence Checking of Quantum Protocols},
	isbn = {978-3-642-36742-7},
	doi = {10.1007/978-3-642-36742-7_33},
	abstract = {Quantum Information Processing ({QIP}) is an emerging area at the intersection of physics and computer science. It aims to establish the principles of communication and computation for systems based on the theory of quantum mechanics. Interesting {QIP} protocols such as quantum key distribution, teleportation, and blind quantum computation have already been realised in the laboratory and are now in the realm of mainstream industrial applications. The complexity of these protocols, along with possible inaccuracies in implementation, demands systematic and formal analysis. In this paper, we present a new technique and a tool, with a high-level interface, for verification of quantum protocols using equivalence checking. Previous work by Gay, Nagarajan and Papanikolaou used model-checking to verify quantum protocols represented in the stabilizer formalism, a restricted model which can be simulated efficiently on classical computers. Here, we are able to go beyond stabilizer states and verify protocols efficiently on all input states.},
	pages = {478--492},
	booktitle = {Tools and Algorithms for the Construction and Analysis of Systems},
	publisher = {Springer},
	author = {Ardeshir-Larijani, Ebrahim and Gay, Simon J. and Nagarajan, Rajagopal},
	editor = {Piterman, Nir and Smolka, Scott A.},
	date = {2013},
	langid = {english},
	keywords = {equivalence checking, model checking, quantum protocols, stabilizers},
	file = {Full Text PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\J873P64S\\Ardeshir-Larijani et al. - 2013 - Equivalence Checking of Quantum Protocols.pdf:application/pdf},
}

@misc{majumdar_generalising_2022,
	title = {Generalising Projection in Asynchronous Multiparty Session Types},
	url = {http://arxiv.org/abs/2107.03984},
	doi = {10.48550/arXiv.2107.03984},
	abstract = {Multiparty session types ({MSTs}) provide an efficient methodology for specifying and verifying message passing software systems. In the theory of {MSTs}, a global type specifies the interaction among the roles at the global level. A local specification for each role is generated by projecting from the global type on to the message exchanges it participates in. Whenever a global type can be projected on to each role, the composition of the projections is deadlock free and has exactly the behaviours specified by the global type. The key to the usability of {MSTs} is the projection operation: a more expressive projection allows more systems to be type-checked but requires a more difficult soundness argument. In this paper, we generalise the standard projection operation in {MSTs}. This allows us to model and type-check many design patterns in distributed systems, such as load balancing, that are rejected by the standard projection. The key to the new projection is an analysis that tracks causality between messages. Our soundness proof uses novel graph-theoretic techniques from the theory of message-sequence charts. We demonstrate the efficacy of the new projection operation by showing many global types for common patterns that can be projected under our projection but not under the standard projection operation.},
	number = {{arXiv}:2107.03984},
	publisher = {{arXiv}},
	author = {Majumdar, Rupak and Mukund, Madhavan and Stutz, Felix and Zufferey, Damien},
	urldate = {2024-09-13},
	date = {2022-08-10},
	eprinttype = {arxiv},
	eprint = {2107.03984 [cs]},
	keywords = {Computer Science - Programming Languages, Computer Science - Formal Languages and Automata Theory},
	file = {arXiv Fulltext PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\SNB9IYIS\\Majumdar et al. - 2022 - Generalising Projection in Asynchronous Multiparty.pdf:application/pdf;arXiv.org Snapshot:C\:\\Users\\bvvandervecht\\Zotero\\storage\\N8U7KDHF\\2107.html:text/html},
}

@article{lewis_formal_2023,
	title = {Formal Verification of Quantum Programs: Theory, Tools, and Challenges},
	volume = {5},
	url = {https://dl.acm.org/doi/10.1145/3624483},
	doi = {10.1145/3624483},
	shorttitle = {Formal Verification of Quantum Programs},
	abstract = {Over the past 27 years, quantum computing has seen a huge rise in interest from both academia and industry. At the current rate, quantum computers are growing in size rapidly backed up by the increase of research in the field. Significant efforts are being made to improve the reliability of quantum hardware and to develop suitable software to program quantum computers.In contrast, the verification of quantum programs has received relatively less attention. Verifying programs is especially important in the quantum setting due to how difficult it is to program complex algorithms correctly on resource-constrained and error-prone quantum hardware. Research into creating verification frameworks for quantum programs has seen recent development, with a variety of tools implemented using a collection of theoretical ideas.This survey aims to be a short introduction into the area of formal verification of quantum programs, bringing together theory and tools developed to date. Further, this survey examines some of the challenges that the field may face in the future, namely the development of complex quantum algorithms.},
	pages = {1:1--1:35},
	number = {1},
	journaltitle = {{ACM} Transactions on Quantum Computing},
	author = {Lewis, Marco and Soudjani, Sadegh and Zuliani, Paolo},
	urldate = {2024-09-13},
	date = {2023-12-16},
	file = {Full Text PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\C3QSTZF6\\Lewis et al. - 2023 - Formal Verification of Quantum Programs Theory, T.pdf:application/pdf},
}

@misc{lanese_towards_2024,
	title = {Towards Quantum Multiparty Session Types},
	url = {http://arxiv.org/abs/2409.11133},
	doi = {10.48550/arXiv.2409.11133},
	abstract = {Multiparty Session Types ({MPSTs}) offer a structured way of specifying communication protocols and guarantee relevant communication properties, such as deadlock-freedom. In this paper, we extend a minimal {MPST} system with quantum data and operations, enabling the specification of quantum protocols. Quantum {MPSTs} ({QMPSTs}) provide a formal notation to describe quantum protocols, both at the abstract level of global types, describing which communications can take place in the system and their dependencies, and at the concrete level of local types and quantum processes, describing the expected behavior of each participant in the protocol. Type-checking relates these two levels formally, ensuring that processes behave as prescribed by the global type. Beyond usual communication properties, {QMPSTs} also allow us to prove that qubits are owned by a single process at any time, capturing the quantum no-cloning and no-deleting theorems. We use our approach to verify four quantum protocols from the literature, respectively Teleportation, Secret Sharing, Bit-Commitment, and Key Distribution.},
	number = {{arXiv}:2409.11133},
	publisher = {{arXiv}},
	author = {Lanese, Ivan and Lago, Ugo Dal and Choudhury, Vikraman},
	urldate = {2024-09-24},
	date = {2024-09-17},
	eprinttype = {arxiv},
	eprint = {2409.11133 [cs]},
	keywords = {Computer Science - Programming Languages},
	file = {arXiv Fulltext PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\KTXSI9S6\\Lanese et al. - 2024 - Towards Quantum Multiparty Session Types.pdf:application/pdf;arXiv.org Snapshot:C\:\\Users\\bvvandervecht\\Zotero\\storage\\E62ABR4S\\2409.html:text/html},
}

@inproceedings{honda_language_1998,
	location = {Berlin, Heidelberg},
	title = {Language primitives and type discipline for structured communication-based programming},
	isbn = {978-3-540-69722-0},
	doi = {10.1007/BFb0053567},
	abstract = {We introduce basic language constructs and a type discipline as a foundation of structured communication-based concurrent programming. The constructs, which are easily translatable into the summation-less asynchronous π-calculus, allow programmers to organise programs as a combination of multiple flows of (possibly unbounded) reciprocal interactions in a simple and elegant way, subsuming the preceding communication primitives such as method invocation and rendez-vous. The resulting syntactic structure is exploited by a type discipline à la {ML}, which offers a high-level type abstraction of interactive behaviours of programs as well as guaranteeing the compatibility of interaction patterns between processes in a well-typed program. After presenting the formal semantics, the use of language constructs is illustrated through examples, and the basic syntactic results of the type discipline are established. Implementation concerns are also addressed.},
	pages = {122--138},
	booktitle = {Programming Languages and Systems},
	publisher = {Springer},
	author = {Honda, Kohei and Vasconcelos, Vasco T. and Kubo, Makoto},
	editor = {Hankin, Chris},
	date = {1998},
	langid = {english},
	keywords = {Communication Pattern, Concurrent Programming, Interactive Behaviour, Operational Semantic, Typing System},
	file = {Full Text PDF:C\:\\Users\\bvvandervecht\\Zotero\\storage\\BW7GI5RJ\\Honda et al. - 1998 - Language primitives and type discipline for struct.pdf:application/pdf},
}

@article{heim_quantum_2020,
	title = {Quantum programming languages},
	volume = {2},
	rights = {2020 Springer Nature Limited},
	issn = {2522-5820},
	url = {https://www.nature.com/articles/s42254-020-00245-7},
	doi = {10.1038/s42254-020-00245-7},
	abstract = {Quantum programming languages are essential to translate ideas into instructions that can be executed by a quantum computer. Not only are they crucial to the programming of quantum computers at scale but also they can facilitate the discovery and development of quantum algorithms even before hardware exists that is capable of executing them. Quantum programming languages are used for controlling existing physical devices, for estimating the execution costs of quantum algorithms on future devices, for teaching quantum computing concepts, or for verifying quantum algorithms and their implementations. They are used by newcomers and seasoned practitioners, researchers and developers working on the next ground-breaking discovery or applying known concepts to real-world problems. This variety in purpose and target audiences is reflected in the design and ecosystem of the existing quantum programming languages, depending on which factors a language prioritizes. In this Review, we highlight important aspects of quantum programming and how it differs from conventional programming. We overview a selection of several state-of-the-art quantum programming languages, highlight their salient features, and provide code samples for each of the languages and Docker files to facilitate installation of the software packages.},
	pages = {709--722},
	number = {12},
	journaltitle = {Nature Reviews Physics},
	shortjournal = {Nat Rev Phys},
	author = {Heim, Bettina and Soeken, Mathias and Marshall, Sarah and Granade, Chris and Roetteler, Martin and Geller, Alan and Troyer, Matthias and Svore, Krysta},
	urldate = {2024-08-13},
	date = {2020-12},
	langid = {english},
	note = {Publisher: Nature Publishing Group},
	keywords = {Quantum physics, Software},
	file = {Full Text PDF:C\:\\Users\\bartv\\Zotero\\storage\\Q7X3Z4DE\\Heim et al. - 2020 - Quantum programming languages.pdf:application/pdf},
}

@misc{cross_open_2017,
	title = {Open Quantum Assembly Language},
	url = {http://arxiv.org/abs/1707.03429},
	doi = {10.48550/arXiv.1707.03429},
	abstract = {This document describes a quantum assembly language ({QASM}) called {OpenQASM} that is used to implement experiments with low depth quantum circuits. {OpenQASM} represents universal physical circuits over the {CNOT} plus {SU}(2) basis with straight-line code that includes measurement, reset, fast feedback, and gate subroutines. The simple text language can be written by hand or by higher level tools and may be executed on the {IBM} Q Experience.},
	number = {{arXiv}:1707.03429},
	publisher = {{arXiv}},
	author = {Cross, Andrew W. and Bishop, Lev S. and Smolin, John A. and Gambetta, Jay M.},
	urldate = {2024-08-13},
	date = {2017-07-13},
	eprinttype = {arxiv},
	eprint = {1707.03429 [quant-ph]},
	keywords = {Quantum Physics},
	file = {arXiv Fulltext PDF:C\:\\Users\\bartv\\Zotero\\storage\\4M7B7NEN\\Cross et al. - 2017 - Open Quantum Assembly Language.pdf:application/pdf;arXiv.org Snapshot:C\:\\Users\\bartv\\Zotero\\storage\\V43EWZEK\\1707.html:text/html},
}

@misc{khammassi_cqasm_2018,
	title = {{cQASM} v1.0: Towards a Common Quantum Assembly Language},
	url = {http://arxiv.org/abs/1805.09607},
	doi = {10.48550/arXiv.1805.09607},
	shorttitle = {{cQASM} v1.0},
	abstract = {The quantum assembly language ({QASM}) is a popular intermediate representation used in many quantum compilation and simulation tools to describe quantum circuits. Currently, multiple different dialects of {QASM} are used in different quantum computing tools. This makes the interaction between those tools tedious and time-consuming due to the need for translators between theses different syntaxes. Beside requiring a multitude of translators, the translation process exposes the constant risk of loosing information due to the potential incompatibilities between the different dialects. Moreover, several tools introduce details of specific target hardware or qubit technologies within the {QASM} syntax and prevent porting the code to other hardwares. In this paper, we propose a common {QASM} syntax definition, named {cQASM}, which aims to abstract away qubit technology details and guarantee the interoperability between all the quantum compilation and simulation tools supporting this standard. Our vision is to enable an extensive quantum computing toolbox shared by all the quantum computing community.},
	number = {{arXiv}:1805.09607},
	publisher = {{arXiv}},
	author = {Khammassi, N. and Guerreschi, G. G. and Ashraf, I. and Hogaboam, J. W. and Almudever, C. G. and Bertels, K.},
	urldate = {2024-09-23},
	date = {2018-05-24},
	eprinttype = {arxiv},
	eprint = {1805.09607 [quant-ph]},
	keywords = {Quantum Physics},
	file = {arXiv Fulltext PDF:C\:\\Users\\bartv\\Zotero\\storage\\BRQD5Z7Z\\Khammassi et al. - 2018 - cQASM v1.0 Towards a Common Quantum Assembly Lang.pdf:application/pdf;arXiv.org Snapshot:C\:\\Users\\bartv\\Zotero\\storage\\GPHFCC96\\1805.html:text/html},
}

@inproceedings{svore_q_2018,
	location = {New York, {NY}, {USA}},
	title = {Q\#: Enabling Scalable Quantum Computing and Development with a High-level {DSL}},
	isbn = {978-1-4503-6355-6},
	url = {https://dl.acm.org/doi/10.1145/3183895.3183901},
	doi = {10.1145/3183895.3183901},
	series = {{RWDSL}2018},
	shorttitle = {Q\#},
	abstract = {Quantum computing exploits quantum phenomena such as superposition and entanglement to realize a form of parallelism that is not available to traditional computing. It offers the potential of significant computational speed-ups in quantum chemistry, materials science, cryptography, and machine learning.The dominant approach to programming quantum computers is to provide an existing high-level language with libraries that allow for the expression of quantum programs. This approach can permit computations that are meaningless in a quantum context; prohibits succint expression of interaction between classical and quantum logic; and does not provide important constructs that are required for quantum programming.We present Q\#, a quantum-focused domain-specific language explicitly designed to correctly, clearly and completely express quantum algorithms. Q\# provides a type system; a tightly constrained environment to safely interleave classical and quantum computations; specialized syntax; symbolic code manipulation to automatically generate correct transformations of quantum operations; and powerful functional constructs which aid composition.},
	pages = {1--10},
	booktitle = {Proceedings of the Real World Domain Specific Languages Workshop 2018},
	publisher = {Association for Computing Machinery},
	author = {Svore, Krysta and Geller, Alan and Troyer, Matthias and Azariah, John and Granade, Christopher and Heim, Bettina and Kliuchnikov, Vadym and Mykhailova, Mariia and Paz, Andres and Roetteler, Martin},
	urldate = {2024-10-09},
	date = {2018-02-24},
	file = {Full Text PDF:C\:\\Users\\bartv\\Zotero\\storage\\GJL43K3H\\Svore et al. - 2018 - Q# Enabling Scalable Quantum Computing and Development with a High-level DSL.pdf:application/pdf},
}

@article{monsanto_compiler_2012,
	title = {A compiler and run-time system for network programming languages},
	volume = {47},
	issn = {0362-1340},
	url = {https://dl.acm.org/doi/10.1145/2103621.2103685},
	doi = {10.1145/2103621.2103685},
	abstract = {Software-defined networks ({SDNs}) are a new kind of network architecture in which a controller machine manages a distributed collection of switches by instructing them to install or uninstall packet-forwarding rules and report traffic statistics. The recently formed Open Networking Consortium, whose members include Google, Facebook, Microsoft, Verizon, and others, hopes to use this architecture to transform the way that enterprise and data center networks are implemented.In this paper, we define a high-level, declarative language, called {NetCore}, for expressing packet-forwarding policies on {SDNs}. {NetCore} is expressive, compositional, and has a formal semantics. To ensure that a majority of packets are processed efficiently on switches---instead of on the controller---we present new compilation algorithms for {NetCore} and couple them with a new run-time system that issues rule installation commands and traffic-statistics queries to switches. Together, the compiler and run-time system generate efficient rules whenever possible and outperform the simple, manual techniques commonly used to program {SDNs} today. In addition, the algorithms we develop are generic, assuming only that the packet-matching capabilities available on switches satisfy some basic algebraic laws.Overall, this paper delivers a new design for a high-level network programming language; an improved set of compiler algorithms; a new run-time system for {SDN} architectures; the first formal semantics and proofs of correctness in this domain; and an implementation and evaluation that demonstrates the performance benefits over traditional manual techniques.},
	pages = {217--230},
	number = {1},
	journaltitle = {{SIGPLAN} Not.},
	author = {Monsanto, Christopher and Foster, Nate and Harrison, Rob and Walker, David},
	urldate = {2024-10-09},
	date = {2012-01-25},
	file = {Full Text PDF:C\:\\Users\\bartv\\Zotero\\storage\\8J92NCKB\\Monsanto et al. - 2012 - A compiler and run-time system for network programming languages.pdf:application/pdf},
}

@inproceedings{li_modular_2020,
	location = {New York, {NY}, {USA}},
	title = {A modular compiler for network programming languages},
	isbn = {978-1-4503-7948-9},
	url = {https://dl.acm.org/doi/10.1145/3386367.3432063},
	doi = {10.1145/3386367.3432063},
	series = {{CoNEXT} '20},
	abstract = {Network programming languages ({NPLs}) empower operators to program network data planes ({NDPs}) with unprecedented efficiency. Currently, various {NPLs} and {NDPs} coexist and no one can prevail over others in the short future. Such diversity is raising many problems including: (1) programs written with different {NPLs} can hardly interoperate in the same network, (2) most {NPLs} are bound to specific {NDPs}, hindering their independent evolution, and (3) compilation techniques cannot be readily reused, resulting in much wasteful work. These problems are mostly owing to the lack of modularity in the compilers, where the missing part is an intermediate representation ({IR}) for {NPLs}. To this end, we propose Network Transaction Automaton ({NTA}), a highly-expressive and language-independent {IR}, and show it can express semantics of 7 mainstream {NPLs}. Then, we design {CODER}, a modular compiler based on {NTA}, which currently supports 2 {NPLs} and 3 {NDPs}. Experiments with real and synthetic network programs show {CODER} is efficient and scalable.},
	pages = {198--210},
	booktitle = {Proceedings of the 16th International Conference on emerging Networking {EXperiments} and Technologies},
	publisher = {Association for Computing Machinery},
	author = {Li, Hao and Zhang, Peng and Sun, Guangda and Hu, Chengchen and Shan, Danfeng and Pan, Tian and Fu, Qiang},
	urldate = {2024-10-09},
	date = {2020-11-24},
	file = {Full Text PDF:C\:\\Users\\bartv\\Zotero\\storage\\8HAT8XLT\\Li et al. - 2020 - A modular compiler for network programming languages.pdf:application/pdf},
}

@inproceedings{lattner_llvm_2004,
	title = {{LLVM}: a compilation framework for lifelong program analysis \& transformation},
	url = {https://ieeexplore.ieee.org/abstract/document/1281665?casa_token=gQgC58ULIh8AAAAA:AxZ4gp-f7r55ifnsOzk-prIE_cqJU89JslPCaqDl4QSCAnh2DlPK4MD_vzAifu7qA2dxCkunGQ},
	doi = {10.1109/CGO.2004.1281665},
	shorttitle = {{LLVM}},
	abstract = {We describe {LLVM} (low level virtual machine), a compiler framework designed to support transparent, lifelong program analysis and transformation for arbitrary programs, by providing high-level information to compiler transformations at compile-time, link-time, run-time, and in idle time between runs. {LLVM} defines a common, low-level code representation in static single assignment ({SSA}) form, with several novel features: a simple, language-independent type-system that exposes the primitives commonly used to implement high-level language features; an instruction for typed address arithmetic; and a simple mechanism that can be used to implement the exception handling features of high-level languages (and setjmp/longjmp in C) uniformly and efficiently. The {LLVM} compiler framework and code representation together provide a combination of key capabilities that are important for practical, lifelong analysis and transformation of programs. To our knowledge, no existing compilation approach provides all these capabilities. We describe the design of the {LLVM} representation and compiler framework, and evaluate the design in three ways: (a) the size and effectiveness of the representation, including the type information it provides; (b) compiler performance for several interprocedural problems; and (c) illustrative examples of the benefits {LLVM} provides for several challenging compiler problems.},
	eventtitle = {International Symposium on Code Generation and Optimization, 2004. {CGO} 2004.},
	pages = {75--86},
	booktitle = {International Symposium on Code Generation and Optimization, 2004. {CGO} 2004.},
	author = {Lattner, C. and Adve, V.},
	urldate = {2024-10-09},
	date = {2004-03},
	keywords = {Algorithm design and analysis, Application software, Arithmetic, High level languages, Information analysis, Performance analysis, Program processors, Runtime, Software safety, Virtual machining},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\bartv\\Zotero\\storage\\YKB5TTRV\\1281665.html:text/html},
}

@inproceedings{danalis_mpi-aware_2009,
	location = {New York, {NY}, {USA}},
	title = {{MPI}-aware compiler optimizations for improving communication-computation overlap},
	isbn = {978-1-60558-498-0},
	url = {https://doi.org/10.1145/1542275.1542321},
	doi = {10.1145/1542275.1542321},
	series = {{ICS} '09},
	abstract = {Several existing compiler transformations can help improve communication-computation overlap in {MPI} applications. However, traditional compilers treat calls to the {MPI} library as a black box with unknown side effects and thus miss potential optimizations. This paper's contributions enable the development of an {MPI}-aware optimizing compiler that can perform transformations exploiting knowledge of {MPI} call effects to increase communication-computa-tion overlap. We formulate a set of data flow equations and rules to describe the side effects of key {MPI} functions so an {MPI}-aware compiler can automatically assess the safety of transformations. After categorizing existing compiler transformations based on their effect on the application code, we present an optimization algorithm that specifies when and how to apply these optimizing transformations to achieve improved communication-computation overlap. By manually applying the optimization algorithm to kernels extracted from {HYCOM} and the {NAS} benchmarks, we show that even when transforming these highly optimized codes, execution time can be decreased by an average of over 30\%.},
	pages = {316--325},
	booktitle = {Proceedings of the 23rd international conference on Supercomputing},
	publisher = {Association for Computing Machinery},
	author = {Danalis, Anthony and Pollock, Lori and Swany, Martin and Cavazos, John},
	urldate = {2024-10-11},
	date = {2009-06-08},
}

@article{knoop_partial_1994,
	title = {Partial dead code elimination},
	volume = {29},
	issn = {0362-1340},
	url = {https://dl.acm.org/doi/10.1145/773473.178256},
	doi = {10.1145/773473.178256},
	abstract = {A new aggressive algorithm for the elimination of partially dead code is presented, i.e., of code which is only dead on some program paths. Besides being more powerful than the usual approaches to dead code elimination, this algorithm is optimal in the following sense: partially dead code remaining in the resulting program cannot be eliminated without changing the branching structure or the semantics of the program, or without impairing some program executions.Our approach is based on techniques for partial redundancy elimination. Besides some new technical problems there is a significant difference here: partial dead code elimination introduces second order effects, which we overcome by means of exhaustive motion and elimination steps. The optimality and  the uniqueness of the program obtained is proved by means of a new technique which is universally applicable and particularly useful in the case of mutually interdependent program optimizations.},
	pages = {147--158},
	number = {6},
	journaltitle = {{SIGPLAN} Not.},
	author = {Knoop, Jens and Rüthing, Oliver and Steffen, Bernhard},
	urldate = {2024-10-24},
	date = {1994-06-01},
	file = {Full Text PDF:C\:\\Users\\bartv\\Zotero\\storage\\WQMTJUTT\\Knoop et al. - 1994 - Partial dead code elimination.pdf:application/pdf},
}

@inproceedings{schneck_survey_1973,
	location = {New York, {NY}, {USA}},
	title = {A survey of compiler optimization techniques},
	isbn = {978-1-4503-7490-3},
	url = {https://dl.acm.org/doi/10.1145/800192.805690},
	doi = {10.1145/800192.805690},
	series = {{ACM} '73},
	abstract = {This survey describes the major optimization techniques of compilers and groups them into three categories: machine dependent, architecture dependent, and architecture independent. Machine-dependent optimizations tend to be local and are performed upon short spans of generated code by using particular properties of an instruction set to reduce the time or space required by a program. Architecture-dependent optimizations are global and are performed while generating code. These optimizations consider the structure of a computer, but not its detailed instruction set. Architecture-independent optimizations are also global but are based on analysis of the program flow graph and the dependencies among statements of source program. The paper also presents a conceptual review of a universal optimizer that performs architecture-independent optimizations at source-code level.},
	pages = {106--113},
	booktitle = {Proceedings of the {ACM} annual conference},
	publisher = {Association for Computing Machinery},
	author = {Schneck, Paul B.},
	urldate = {2024-10-24},
	date = {1973-08-27},
	file = {Full Text PDF:C\:\\Users\\bartv\\Zotero\\storage\\BZ69QRRG\\Schneck - 1973 - A survey of compiler optimization techniques.pdf:application/pdf},
}

@inproceedings{frailey_intermediate_1979,
	location = {New York, {NY}, {USA}},
	title = {An intermediate language for source and target independent code optimization},
	isbn = {978-0-89791-002-6},
	url = {https://dl.acm.org/doi/10.1145/800229.806969},
	doi = {10.1145/800229.806969},
	series = {{SIGPLAN} '79},
	abstract = {This paper describes an intermediate language to be generated by a syntax analyzer and processed by a code generator. An (essentially) optional code optimization phase may be used before code generation. The language is designed to exclude source and target dependencies (these are specified in a set of auxiliary tables) and has been used to implement a general purpose code optimization module. This module has been incorporated into compilers for several source languages and has resulted in production-quality target code.The paper focuses on the features of the language and reviews the optimizations for which it has been designed. A major benefit of this approach has been to isolate many of the characteristics which lead to code optimization opportunities. Of particular note are numerous facts which can be gathered in a target-independent manner, even though their utilization will depend on the details of the target machine.},
	pages = {188--200},
	booktitle = {Proceedings of the 1979 {SIGPLAN} symposium on Compiler construction},
	publisher = {Association for Computing Machinery},
	author = {Frailey, Dennis J.},
	urldate = {2024-10-24},
	date = {1979-08-01},
	file = {Full Text PDF:C\:\\Users\\bartv\\Zotero\\storage\\UNJU9ITZ\\Frailey - 1979 - An intermediate language for source and target independent code optimization.pdf:application/pdf},
}

@article{chaitin_register_1981,
	title = {Register allocation via coloring},
	volume = {6},
	issn = {0096-0551},
	url = {https://www.sciencedirect.com/science/article/pii/0096055181900485},
	doi = {10.1016/0096-0551(81)90048-5},
	abstract = {Register allocation may be viewed as a graph coloring problem. Each node in the graph stands for a computed quantity that resides in a machine register, and two nodes are connected by an edge if the quantities interfere with each other, that is, if they are simultaneously live at some point in the object program. This approach, though mentioned in the literature, was never implemented before. Preliminary results of an experimental implementation in a {PL}/I optimizing compiler suggest that global register allocation approaching that of hand-coded assembly language may be attainable.},
	pages = {47--57},
	number = {1},
	journaltitle = {Computer Languages},
	shortjournal = {Computer Languages},
	author = {Chaitin, Gregory J. and Auslander, Marc A. and Chandra, Ashok K. and Cocke, John and Hopkins, Martin E. and Markstein, Peter W.},
	urldate = {2024-10-24},
	date = {1981-01-01},
	keywords = {Graph coloring, Optimizing compilers, Register allocation},
	file = {ScienceDirect Snapshot:C\:\\Users\\bartv\\Zotero\\storage\\Y9IN3PZS\\0096055181900485.html:text/html},
}

@inproceedings{smith_study_1981,
	location = {Washington, {DC}, {USA}},
	title = {A study of branch prediction strategies},
	series = {{ISCA} '81},
	abstract = {In high-performance computer systems, performance losses due to conditional branch instructions can be minimized by predicting a branch outcome and fetching, decoding, and/or issuing subsequent instructions before the actual outcome is known. This paper discusses branch prediction strategies with the goal of maximizing prediction accuracy. First, currently used techniques are discussed and analyzed using instruction trace data. Then, new techniques are proposed and are shown to provide greater accuracy and more flexibility at low cost.},
	pages = {135--148},
	booktitle = {Proceedings of the 8th annual symposium on Computer Architecture},
	publisher = {{IEEE} Computer Society Press},
	author = {Smith, James E.},
	urldate = {2024-10-24},
	date = {1981-05-12},
	file = {Full Text PDF:C\:\\Users\\bartv\\Zotero\\storage\\78U638EL\\Smith - 1981 - A study of branch prediction strategies.pdf:application/pdf},
}

@inproceedings{tomesh_supermarq_2022,
	title = {{SupermarQ}: A Scalable Quantum Benchmark Suite},
	url = {https://ieeexplore.ieee.org/abstract/document/9773202?casa_token=82wnIncpqAwAAAAA:N7fcMYNuEzaqdMbHPbkYVlxVh11xHsEmwuabebXS-8aLoqtG-Q4qm1fnvClPnjZkhGiB5gRgig},
	doi = {10.1109/HPCA53966.2022.00050},
	shorttitle = {{SupermarQ}},
	abstract = {The emergence of quantum computers as a new computational paradigm has been accompanied by speculation concerning the scope and timeline of their anticipated revolutionary changes. While quantum computing is still in its infancy, the variety of different architectures used to implement quantum computations make it difficult to reliably measure and compare performance. This problem motivates our introduction of {SupermarQ}, a scalable, hardware-agnostic quantum benchmark suite which uses application-level metrics to measure performance. {SupermarQ} is the first attempt to systematically apply techniques from classical benchmarking methodology to the quantum domain. We define a set of feature vectors to quantify coverage, select applications from a variety of domains to ensure the suite is representative of real workloads, and collect benchmark results from the {IBM}, {IonQ}, and {AQT}@{LBNL} platforms. Looking forward, we envision that quantum benchmarking will encompass a large cross-community effort built on open source, constantly evolving benchmark suites. We introduce {SupermarQ} as an important step in this direction.},
	eventtitle = {2022 {IEEE} International Symposium on High-Performance Computer Architecture ({HPCA})},
	pages = {587--603},
	booktitle = {2022 {IEEE} International Symposium on High-Performance Computer Architecture ({HPCA})},
	author = {Tomesh, Teague and Gokhale, Pranav and Omole, Victory and Ravi, Gokul Subramanian and Smith, Kaitlin N. and Viszlai, Joshua and Wu, Xin-Chuan and Hardavellas, Nikos and Martonosi, Margaret R. and Chong, Frederic T.},
	urldate = {2024-10-24},
	date = {2022-04},
	note = {{ISSN}: 2378-203X},
	keywords = {Benchmark testing, Benchmarking, Computer architecture, Computers, Measurement, Program Characterization, Quantum computing, Quantum Computing, Reliability},
	file = {IEEE Xplore Abstract Record:C\:\\Users\\bartv\\Zotero\\storage\\3FTF629B\\9773202.html:text/html;Submitted Version:C\:\\Users\\bartv\\Zotero\\storage\\H5VNIKXU\\Tomesh et al. - 2022 - SupermarQ A Scalable Quantum Benchmark Suite.pdf:application/pdf},
}
